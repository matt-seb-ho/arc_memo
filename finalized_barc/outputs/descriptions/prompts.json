["You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: count the number of holes in an guide object (i.e. the number of enclosed\n  pixels that are not the guide object's color)\nPuzzle ID: 0a2355a6\nConcept: hole counting\nKind: intermediate operation\nRoutine Subtype: ''\nOutput Typing: int\nParameters: \"- name: guide object\\n  typing: object\\n  description: object within\\\n  \\ which to count enclosed background regions\\n- name: color\\n  typing: colour |\\\n  \\ set[colour]\\n  description: which colours count as background for holes (e.g.,\\\n  \\ 0)\\n- name: hole_connectivity\\n  typing: 4 | 8\\n  description: connectivity used\\\n  \\ for counting holes\"\nImplementation: \"- Flood-fill background from the grid border to mark exterior 0-regions.\\n\\\n  - Compute mask of the guide object; treat any 0-region fully enclosed by the object\\n\\\n  \\  as a hole.\\n- Count holes (connected components) according to hole_connectivity\\\n  \\ if provided.\"\nCues: '- Donut/ring shapes where 0-cells are fully enclosed by an object.\n\n  - Outputs or later steps depend on the number of interior holes.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: holes are empty spaces in the guide object that can be filled by the\n  target object\nPuzzle ID: 0a2355a6\nConcept: holes\nKind: term definition\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: \"- Define holes as background-colour regions fully enclosed by the\\\n  \\ guide object (not\\n  connected to the grid border).\\n- Detect by flood-filling\\\n  \\ background from the border to mark exterior; any remaining\\n  background component\\\n  \\ inside the object is a hole.\"\nCues: '- Donut/ring-like shapes or enclosed 0-regions inside an object.\n\n  - Tasks that count, recolour, or otherwise reference interior empty regions.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: count the number of odd or even pixels in a guide object (i.e. the number\n  of pixels with odd or even values)\nPuzzle ID: 0a2355a6\nConcept: odd/even counting\nKind: intermediate operation\nRoutine Subtype: ''\nOutput Typing: int\nParameters: \"- name: guide object\\n  typing: object\\n  description: the object whose\\\n  \\ pixels are checked for parity\\n- name: color\\n  typing: colour | set[colour]\\n\\\n  \\  description: restrict counting to specific colours (e.g., only background 0)\"\nImplementation: \"- Build a mask of the guide object; iterate its pixels and apply\\\n  \\ parity test on colour\\n  index.\\n- If 'color' provided, restrict to those colours;\\\n  \\ otherwise consider all colours within\\n  the object except its own if specified.\\n\\\n  - Sum pixels satisfying the chosen parity.\"\nCues: '- Task logic references odd vs even counts or colour-index parity.\n\n  - Examples show decisions based on whether a count is odd or even.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: set the shape of the output grid according to the guide object, other\n  concepts, or a fixed size\nPuzzle ID: 0a2355a6\nConcept: set output grid shape\nKind: grid manipulation\nRoutine Subtype: ''\nOutput Typing: grid\nParameters: \"- name: output grid shape\\n  typing: tuple[int, int] | Callable[[object],\\\n  \\ tuple[int, int]]\\n  description: target (rows, cols) or a function deriving shape\\\n  \\ from a guide object\"\nImplementation: '- Derive (rows, cols) from the chosen scheme (e.g., guide object''s\n  bbox or fixed size).\n\n  - Allocate a new zero-initialised grid with that shape (dtype uint8).'\nCues: \"- Output dimensions are independent of specific drawing but match a rule (bbox,\\\n  \\ fixed\\n  N\\xD7M).\\n- Specification mentions output shape explicitly.\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: use a guide object's position as a starting point for counting holes\nPuzzle ID: 0a2355a6\nConcept: start from guide object\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: \"- name: starting point\\n  typing: coord | object\\n  description: anchor\\\n  \\ derived from the guide object\"\nImplementation: \"- Detect candidate objects; select the guide by uniqueness criterion\\\n  \\ (e.g., colour\\n  or size).\\n- Use the guide's anchor (e.g., centroid or top-left)\\\n  \\ as the starting point for downstream\\n  steps.\"\nCues: '- One object has a unique role or colour; subsequent steps originate from that\n  object.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: use the color of a guide object for identifying holes\nPuzzle ID: 0a2355a6\nConcept: use guide object color\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: \"- name: color scheme\\n  typing: colour | Callable[[object], colour]\\n\\\n  \\  description: use the guide object's colour value\"\nImplementation: \"- Read the guide object's colour index and propagate it to the target\\\n  \\ operation (e.g.,\\n  fill/stamp).\"\nCues: '- Outputs reuse the guide object''s colour for new pixels or shapes.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: draw a line between two pixels in a grid, updating the grid accordingly\nPuzzle ID: 0d87d2a6\nConcept: draw line\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid\nParameters: \"- name: start_pixel\\n  typing: object\\n  description: the starting pixel\\\n  \\ to draw the line from\\n- name: end_pixel\\n  typing: object\\n  description: the\\\n  \\ ending pixel to draw the line to\\n- name: color\\n  typing: color\\n  description:\\\n  \\ the color of the line to draw\"\nImplementation: \"- draw the line pixel by pixel, picking a starting point and following\\\n  \\ the direction\\n  to the end point\"\nCues: '- output grid contains lines not present in the input grid'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: obstacles are objects that block the path of line drawing typically\nPuzzle ID: 0d87d2a6\nConcept: obstacles\nKind: term definition\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: \"- Any non-background pixels (objects) along a planned line/replication\\\n  \\ path that would\\n  be overwritten.\\n- Can be handled via detours, bypass rules,\\\n  \\ or recolouring, depending on parameters.\"\nCues: '- The step specifies obstacle handling or shows detours around existing objects.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: recolor an object based on a color scheme\nPuzzle ID: 0d87d2a6\nConcept: recolor object\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid | object\nParameters: \"- name: object\\n  typing: object\\n  description: the object to recolor\\n\\\n  - name: color scheme\\n  typing: color scheme := color | Callable[[object], color]\\n\\\n  \\  description: either a single color or logic that determines what object gets\\\n  \\ which\\n    color\"\nImplementation: ''\nCues: \"- if existing structures from the input grid appear in the output grid with\\\n  \\ different\\n  colors\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: From all candidate_objects choose the one whose color is not shared by\n  any other object; this becomes the guide object.\nPuzzle ID: 0d87d2a6\nConcept: select guide object\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: object\nParameters: \"- name: candidate_objects\\n  typing: list[object]\\n  description: all\\\n  \\ components detected in the grid\"\nImplementation: '- Extract all connected components and compute per-object features\n  (colour, size).\n\n  - Select the unique-colour object (or by other specified criterion) as the guide.'\nCues: '- Exactly one object has a unique colour or feature that distinguishes it from\n  others.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: use a guide object's position as a starting point\nPuzzle ID: 0d87d2a6\nConcept: start from guide object\nKind: routine\nRoutine Subtype: parameter selection\nOutput Typing: ''\nParameters: ''\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: use the color of a guide object for the tiling\nPuzzle ID: 0d87d2a6\nConcept: use guide object color\nKind: routine\nRoutine Subtype: parameter selection\nOutput Typing: ''\nParameters: ''\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: find holes on guide object so that the target object can be fully or\n  partially filled in. The filling can be like \"Tetris\" style, as we try to find a\n  optimized way to fill in the holes.\nPuzzle ID: 16b78196\nConcept: fill in holes\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: grid\nParameters: \"- name: guide object\\n  typing: object\\n  description: the object that\\\n  \\ serves as a reference for filling in holes\\n- name: target object\\n  typing: object\\n\\\n  \\  description: the object to fill in holes on\"\nImplementation: \"- Compute interior-hole mask of the guide object (background regions\\\n  \\ not connected\\n  to the border).\\n- Choose target-object pixels/blocks to fit\\\n  \\ the hole geometry; place them without\\n  overlapping existing non-background pixels.\\n\\\n  - Repeat until holes are filled or no legal placement remains.\"\nCues: \"- Output shows previously empty regions inside a shape filled with pixels of\\\n  \\ another\\n  object.\\n- Holes are fully enclosed by a container object.\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: holes are empty spaces in the guide object that can be filled by the\n  target object\nPuzzle ID: 16b78196\nConcept: holes\nKind: term definition\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: \"- Define as background-colour components fully enclosed by the object\\\n  \\ (not connected\\n  to grid border).\\n- Detect via border flood-fill; remaining\\\n  \\ background components inside the object\\n  are holes.\"\nCues: '- Enclosed 0-regions inside a container object.\n\n  - Later steps fill or count these regions.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: From all candidate_objects choose the one whose color is not shared by\n  any other object; this becomes the guide object.\nPuzzle ID: 16b78196\nConcept: move object\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: object\nParameters: \"- name: candidate_objects\\n  typing: list[object]\\n  description: all\\\n  \\ components detected in the grid\"\nImplementation: '- Extract connected components and compute features (colour, size,\n  location).\n\n  - Select the unique-colour object (or other specified criterion) as the guide.'\nCues: '- Exactly one object has a unique colour or feature that distinguishes it from\n  others.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: find holes on guide object so that the target object can be fully or\n  partially filled in. The filling can be like \"Tetris\" style, as we try to find a\n  optimized way to fill in the holes.\nPuzzle ID: 1acc24af\nConcept: fill in holes\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: ''\nParameters: \"- name: guide object\\n  typing: object\\n  description: the object that\\\n  \\ serves as a reference for filling in holes\\n- name: target object\\n  typing: object\\n\\\n  \\  description: the object to fill in holes on\"\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: find holes on guide object so that the target object can be fully or\n  partially filled in. The filling can be like \"Tetris\" style, as we try to find an\n  optimized way to fill in the holes.\nPuzzle ID: 1acc24af\nConcept: get object holes\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: list[object] | mask\nParameters: \"- name: guide_object\\n  typing: object\\n  description: the object that\\\n  \\ serves as a reference for filling in holes\\n- name: target_object\\n  typing: object\\n\\\n  \\  description: the object to fill in holes on\"\nImplementation: \"- Derive a boolean mask of interior background components within\\\n  \\ the guide object\\n  (not connected to border).\\n- Optionally convert each connected\\\n  \\ component of the mask into a hole object (with\\n  pixel coordinates).\"\nCues: '- The next step uses hole regions as placement targets for filling or counting.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: holes are empty spaces in the guide object that can be filled by the\n  target object\nPuzzle ID: 1acc24af\nConcept: holes\nKind: term definition\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: \"- Define as background-colour components fully enclosed by the object\\\n  \\ (not connected\\n  to the grid border).\\n- Detect by border flood-fill; remaining\\\n  \\ background components inside the object are\\n  holes.\"\nCues: '- Enclosed 0-regions inside a container object.\n\n  - Later steps fill or count these regions.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: change the color of an object to match the guide object\nPuzzle ID: 1acc24af\nConcept: recolor object\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: ''\nParameters: \"- name: object\\n  typing: object\\n  description: the object to recolor\\n\\\n  - name: new_color\\n  typing: color\\n  description: the new color to apply to the\\\n  \\ object\"\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: From all candidate_objects choose the one whose color is not shared by\n  any other object; this becomes the guide object.\nPuzzle ID: 1acc24af\nConcept: select guide object\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: \"- name: candidate_objects\\n  typing: ''\\n  description: all components\\\n  \\ detected in the grid\"\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: split the grid into regions based on the divider lines.\nPuzzle ID: 1acc24af\nConcept: split grid\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: list[grid]\nParameters: \"- name: input_grid\\n  typing: grid\\n  description: the grid to split\\\n  \\ into regions\\n- name: divider_lines\\n  typing: list[int] | list[tuple[int, int]]\\n\\\n  \\  description: indices or coordinate pairs of full-row/column separators\"\nImplementation: '- Detect full-length separator rows/columns (e.g., grey bars) and\n  collect their indices.\n\n  - Slice the input grid into contiguous bands between separators.'\nCues: '- Presence of repeated full rows/columns of a single colour separating content\n  bands.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: split the grid into regions based on divider lines, which are horizontal\n  or vertical lines that separate different areas in the grid.\nPuzzle ID: 1acc24af\nConcept: split on divider lines\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: list[grid]\nParameters: \"- name: input_grid\\n  typing: grid\\n  description: the grid to split\\\n  \\ into regions\\n- name: divider_lines\\n  typing: list[int] | list[tuple[int, int]]\\n\\\n  \\  description: indices or coordinate pairs of full-row/column separators\"\nImplementation: '- Scan for uninterrupted rows/columns of a single divider colour;\n  record their indices.\n\n  - Use these indices to slice the grid into bands; return the non-empty sub-grids.'\nCues: '- Alternating content and uniform divider rows/columns are visible in the grid.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: infer a consistent transformation pattern (e.g., movement, size change,\n  or color shift) across multiple steps and apply it to predict the next step.\nPuzzle ID: 351d6448\nConcept: extrapolate pattern\nKind: routine\nRoutine Subtype: pattern recognition\nOutput Typing: pattern\nParameters: \"- name: grids\\n  typing: list[grid]\\n  description: a list of sequential\\\n  \\ grids (e.g., time steps) to analyze for evolving\\n    patterns\\n- name: feature\\n\\\n  \\  typing: enum['position', 'size', 'color']\\n  description: the aspect of the object\\\n  \\ to extrapolate from (e.g., movement, growth,\\n    recoloring)\"\nImplementation: \"- Reduce each relevant row to a 1D feature (e.g., length/position\\\n  \\ of coloured run\\n  separated by grey rows).\\n- Fit the simplest progression consistent\\\n  \\ with the examples (constant section, linear\\n  growth, or repetition length).\\n\\\n  - Emit a compact 1\\xD7W grid encoding the predicted sequence for the next step.\"\nCues: '- look for step-wise changes in object position, size, or color\n\n  - check for linear, arithmetic, or geometric progressions\n\n  - identify the next logical continuation of a visual or spatial trend'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: move an object to a new position in the grid, updating the grid accordingly\nPuzzle ID: 351d6448\nConcept: move object\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid | object\nParameters: \"- name: object\\n  typing: object\\n  description: the object to move\\n\\\n  - name: position\\n  typing: position\\n  description: the position to move the object\\\n  \\ to\"\nImplementation: \"- can draw the object at the new position, but most erase the object\\\n  \\ pixels from the\\n  old position first\"\nCues: \"- if existing structures from the input grid appear in the output grid with\\\n  \\ different\\n  positions\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: recolor an object based on a color scheme\nPuzzle ID: 351d6448\nConcept: recolor object\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid | object\nParameters: \"- name: object\\n  typing: object\\n  description: the object to recolor\\n\\\n  - name: color scheme\\n  typing: color scheme := color | Callable[[object], color]\\n\\\n  \\  description: either a single color or logic that determines what object gets\\\n  \\ which\\n    color\"\nImplementation: ''\nCues: \"- if existing structures from the input grid appear in the output grid with\\\n  \\ different\\n  colors\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: where the grid is split into multiple regions that are treated as distinct\nPuzzle ID: 351d6448\nConcept: split grid\nKind: structure\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: ''\nCues: \"- divider lines that span the grid and partition it\\n- color based regions--\\\n  \\ i.e. pixels of a color only appear in a certain section of\\n  the grid\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: identify lines that divide the grid into regions, extract these regions\nPuzzle ID: 351d6448\nConcept: split on divider lines\nKind: routine\nRoutine Subtype: splitting scheme\nOutput Typing: list[grid]\nParameters: \"- name: grid\\n  typing: grid\\n  description: the grid to split\"\nImplementation: '- determine where divider lines are and use array slicing to extract\n  the regions'\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: translate the target so it touches the reference on *side* and merge\n  the two shapes into one.\nPuzzle ID: 4c177718\nConcept: attach object\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid\nParameters: \"- name: reference\\n  typing: object | grid\\n  description: anchor object/grid\\\n  \\ to attach to (top/bottom row acts as reference band)\\n- name: target\\n  typing:\\\n  \\ object\\n  description: the object to translate toward the reference\\n- name: side\\n\\\n  \\  typing: direction\\n  description: which side of the reference the target must\\\n  \\ touch (up/down/left/right)\"\nImplementation: '- Compute target bbox and reference contact edge for the given side.\n\n  - Translate target so its nearest edge touches the reference edge without overlap.\n\n  - Paint target pixels into the grid; preserve existing reference pixels.'\nCues: \"- Output shows target objects lined up to touch a band (e.g., below a grey\\\n  \\ divider)\\n  or another object with no gap.\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: infer the cardinal direction encoded by a rotated pointer shape.\nPuzzle ID: 4c177718\nConcept: orientation of pointer\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: direction\nParameters: \"- name: pointer\\n  typing: object\\n  description: the pointer-shaped\\\n  \\ object whose orientation encodes a direction\\n- name: mapping\\n  typing: dict[shape,\\\n  \\ direction]\\n  description: optional explicit mapping from canonical rotated shape\\\n  \\ to direction\"\nImplementation: \"- Normalise the pointer by rotation/flip to a canonical template;\\\n  \\ select the matching\\n  direction.\\n- Alternatively, compute facing by comparing\\\n  \\ centroid-to-tip vector to axes and quantising\\n  to NSEW.\"\nCues: '- A consistent pointer/arrowhead shape whose orientation determines where to\n  attach/move.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: identify lines that divide the grid into regions, extract these regions\nPuzzle ID: 4c177718\nConcept: split on divider lines\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: list[grid]\nParameters: \"- name: input_grid\\n  typing: grid\\n  description: the grid to split\\\n  \\ into bands\\n- name: divider_lines\\n  typing: list[int] | list[tuple[int, int]]\\n\\\n  \\  description: indices or coordinate pairs of full-row/column separators\"\nImplementation: \"- Detect uninterrupted full rows/columns of a single colour (e.g.,\\\n  \\ grey) and record\\n  their indices.\\n- Slice the grid into contiguous sub-grids\\\n  \\ between separators; discard empty bands.\"\nCues: '- Visible uniform divider bars separating top/bottom regions.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: simulate gravity in the specified direction to translate blocks until\n  they rest on obstacles or boundaries\nPuzzle ID: 5ffb2104\nConcept: gravity movement\nKind: intermediate operation\nRoutine Subtype: ''\nOutput Typing: grid\nParameters: \"- name: direction\\n  typing: Literal['down','up','left','right']\\n  description:\\\n  \\ direction of the gravity\\n- name: cohesion mode\\n  typing: Literal['cohesive','per-column']\\n\\\n  \\  description: whether the object falls as a whole (cohesive) or columns fall independently\"\nImplementation: \"- For the chosen direction, sweep cells toward that side.\\n- If cohesion\\\n  \\ mode is 'per-column', collapse each column independently stopping at\\n  blockers;\\\n  \\ else treat the object as one rigid shape and translate until contact.\\n- Preserve\\\n  \\ order/shape; stop when further movement would collide or leave grid.\"\nCues: \"- Outputs show blocks shifted flush against walls or other blocks along one\\\n  \\ axis;\\n  empty space appears opposite the fall direction.\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: move an object to a new position in the grid\nPuzzle ID: 5ffb2104\nConcept: move object\nKind: ''\nRoutine Subtype: grid manipulation\nOutput Typing: grid | object\nParameters: \"- name: object\\n  typing: object\\n  description: the object to move\\n\\\n  - name: new position\\n  typing: position := tuple[int, int]\\n  description: the\\\n  \\ new position (row, column) to move the object to\"\nImplementation: \"- can draw the object at the new position, but most erase the object\\\n  \\ pixels from the\\n  old position first\"\nCues: '- if the object''s position changes in the output grid compared to the input\n  grid'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: identify which of the four corners is *not* occupied in a 3-pixel L-shape.\nPuzzle ID: 626c0bcc\nConcept: missing-corner orientation\nKind: routine\nRoutine Subtype: intermediate\nOutput Typing: orientation := Literal[\"tl\",\"tr\",\"bl\",\"br\"]\nParameters: \"- name: mask\\n  typing: grid\\n  description: Boolean 2 \\xD7 2 mask for\\\n  \\ the L-shape\"\nImplementation: \"- Inspect the 2\\xD72 mask and locate the zero cell; map its position\\\n  \\ to one of {tl,tr,bl,br}.\\n- Robustness: allow one-pixel noise by using majority\\\n  \\ over local neighbourhood if\\n    needed.\"\nCues: '- An L-shaped triomino needs to be classified to drive colour assignment.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: \"recolour an object using a fixed map (tl\\u2192red 3, bl\\u2192green 2,\\\n  \\ tr\\u2192yellow 4, br\\u2192blue 1).\"\nPuzzle ID: 626c0bcc\nConcept: orientation-based recolor\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid | object\nParameters: \"- name: object\\n  typing: object\\n  description: the object to recolor\\n\\\n  - name: orientation\\n  typing: orientation\\n  description: one of tl/tr/bl/br computed\\\n  \\ from the object's L-shape mask\"\nImplementation: '- Compute orientation via missing-corner orientation; pick colour\n  by lookup table.\n\n  - Paint all object pixels with the mapped colour.'\nCues: '- Output shows identical shapes recoloured differently depending on their corner\n  orientation.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: \"returns **True** when every cell in the 2 \\xD7 2 window matches the\\\n  \\ target colour (here, cyan).\"\nPuzzle ID: 626c0bcc\nConcept: square pattern criteria\nKind: routine\nRoutine Subtype: selection criteria\nOutput Typing: bool\nParameters: \"- name: window\\n  typing: grid\\n  description: 2 \\xD7 2 slice of the\\\n  \\ grid being tested\\n- name: colour\\n  typing: color\\n  description: ''\"\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: draw a diagonal zig zag by alternating between m pixels in left/right\n  direction and then n pixels in up/down direction\nPuzzle ID: 69889d6e\nConcept: diagonal zigzag shape pattern\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: pattern\nParameters: \"- name: horizontal_step\\n  typing: int\\n  description: number of pixels\\\n  \\ to move horizontally before turning\\n- name: vertical_step\\n  typing: int\\n  description:\\\n  \\ number of pixels to move vertically before turning\"\nImplementation: \"- Starting at the first seed pixel, repeat (horizontal_step, vertical_step)\\\n  \\ moves,\\n  painting along the way.\\n- Stop when reaching boundary or the target\\\n  \\ contact condition.\"\nCues: '- Output shows a staircase diagonal composed of axis-aligned runs with constant\n  stride.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: draw a line between two pixels in a grid, updating the grid accordingly\nPuzzle ID: 69889d6e\nConcept: draw line\nKind: ''\nRoutine Subtype: grid manipulation\nOutput Typing: grid\nParameters: \"- name: start_pixel\\n  typing: object\\n  description: the starting pixel\\\n  \\ to draw the line from\\n- name: end_pixel\\n  typing: object\\n  description: the\\\n  \\ ending pixel to draw the line to\\n- name: color\\n  typing: color\\n  description:\\\n  \\ the color of the line to draw\"\nImplementation: \"- draw the line pixel by pixel, picking a starting point and following\\\n  \\ the direction\\n  to the end point\"\nCues: '- output grid contains lines not present in the input grid'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: navigate around an obstacle by turning in a specified direction to get\n  past\nPuzzle ID: 69889d6e\nConcept: fixed direction for obstacle navigation\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: obstacle handling\nParameters: \"- name: turn\\n  typing: Literal['left','right']\\n  description: which\\\n  \\ way to turn when encountering an obstacle\"\nImplementation: \"- When a drawing step hits an obstacle, change heading by the specified\\\n  \\ turn and continue\\n  until alignment is restored.\"\nCues: '- Output shows consistent detours at obstacles, always turning the same way.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: select object(s) from the grid for a specific role\nPuzzle ID: 69889d6e\nConcept: object selection\nKind: intermediate operation\nRoutine Subtype: ''\nOutput Typing: list[object] | object\nParameters: \"- name: selection criteria\\n  typing: Callable[[object], bool] | str\\n\\\n  \\  description: predicate or named rule to select relevant objects\"\nImplementation: '- Extract connected components and filter them by the selection criteria.'\nCues: '- Only a subset of objects are used as seeds or targets in the output.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: obstacles are objects that block the path of line drawing typically\nPuzzle ID: 69889d6e\nConcept: obstacles\nKind: term definition\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: select objects of a fixed color\nPuzzle ID: 69889d6e\nConcept: specific color based selection\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: \"- name: color\\n  typing: ''\\n  description: the color to select objects\\\n  \\ of\"\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: use a guide object's position as a starting point\nPuzzle ID: 69889d6e\nConcept: start from guide pixel\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: use the color of a guide object for the line\nPuzzle ID: 69889d6e\nConcept: use guide object color\nKind: parameter selection\nRoutine Subtype: ''\nOutput Typing: ''\nParameters: ''\nImplementation: ''\nCues: ''\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: Produce a boolean mask marking the coordinates in `block` where `predicate`\n  evaluates to **True** (e.g. \"cells with colour = X\"). This mask serves as a transferable\n  template.\nPuzzle ID: 79369cc6\nConcept: capture pattern mask\nKind: routine\nRoutine Subtype: parameter selection\nOutput Typing: mask\nParameters: \"- name: block\\n  typing: grid\\n  description: source grid region (e.g.,\\\n  \\ 3\\xD73 window) to analyse\\n- name: predicate\\n  typing: Callable[[cell], bool]\\n\\\n  \\  description: returns **True** for cells that belong to the pattern\"\nImplementation: '- Evaluate `predicate` at every coordinate in `block` and record\n  a True/False mask.\n\n  - Return the mask for reuse when scanning other windows.'\nCues: \"- Repeated 3\\xD73 motifs appear; a reusable mask/template is needed to recognise\\\n  \\ them.\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: \"For every cell in `window_coords` whose current value does **not** satisfy\\\n  \\ `predicate`, assign `fill_value`.  Used to complete each matched 3 \\xD7 3 window\\\n  \\ once the pattern has been recognised.\"\nPuzzle ID: 79369cc6\nConcept: fill window cells\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid\nParameters: \"- name: window_coords\\n  typing: list[coord]\\n  description: coordinates\\\n  \\ of the current 3\\xD73 window\\n- name: grid\\n  typing: grid\\n  description: grid\\\n  \\ to modify in-place or return as copy\\n- name: fill_value\\n  typing: colour | Any\\n\\\n  \\  description: value assigned to cells that fail `predicate`\"\nImplementation: '- Iterate coordinates in the window and check the predicate for each.\n\n  - For those not matching, write `fill_value` to that position.'\nCues: \"- Outputs show completed 3\\xD73 motifs where certain slots are consistently\\\n  \\ filled.\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: \"Scan each 3 \\xD7 3 window and select the one that contains **at least\\\n  \\ one** cell of every colour in `required_colours`.  This window becomes the anchor\\\n  \\ template for later steps.\"\nPuzzle ID: 79369cc6\nConcept: locate heterogeneous anchor\nKind: routine\nRoutine Subtype: selection criteria\nOutput Typing: coords | object\nParameters: \"- name: grid\\n  typing: grid\\n  description: grid to scan with a 3\\xD7\\\n  3 sliding window\\n- name: required_colours\\n  typing: set[colour]\\n  description:\\\n  \\ set of colours that must all appear at least once in the window\"\nImplementation: \"- Slide a 3\\xD73 window over the grid; for each window, compute the\\\n  \\ set of colours present.\\n- Return the window coordinates when the set is a superset\\\n  \\ of `required_colours`.\"\nCues: '- A small mixed-colour patch acts as a seed for subsequent matching/filling.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: Return **True** if the set of cells in `window` satisfying `predicate`\n  occupies exactly the coordinates indicated by `pattern_mask`; rotations and flips\n  are **not** considered matches.\nPuzzle ID: 79369cc6\nConcept: match pattern mask\nKind: routine\nRoutine Subtype: selection criteria\nOutput Typing: bool\nParameters: \"- name: window\\n  typing: grid\\n  description: candidate 3\\xD73 window\\\n  \\ to evaluate\\n- name: pattern_mask\\n  typing: mask\\n  description: boolean mask\\\n  \\ of required True positions\\n- name: predicate\\n  typing: Callable[[cell], bool]\\n\\\n  \\  description: test that identifies target cells (e.g., cell == colour)\"\nImplementation: \"- Build a boolean mask by applying `predicate` to every cell in `window`.\\n\\\n  - Return True if it equals `pattern_mask` element\\u2011wise (no rotations/flips).\"\nCues: \"- Exact coordinate agreement of the motif within a 3\\xD73 window (orientation\\\n  \\ matters).\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: detect maximal contiguous runs of the target colour along rows or columns\nPuzzle ID: 7d419a02\nConcept: contiguous cyan run detection\nKind: intermediate operation\nRoutine Subtype: ''\nOutput Typing: list[cell] | list[list[cell]]\nParameters: \"- name: colour\\n  typing: color\\n  description: target run colour (cyan)\"\nImplementation: '- For each row (or column), scan and collect maximal sequences of\n  the target colour.\n\n  - Return the list of runs as coordinate lists or slices.'\nCues: '- Long straight bands of one colour appear; later steps recolour run ends.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: \"recolour \\u22643 cells from each end of a cyan run to yellow (colour-4);\\\n  \\ amount capped at half the run length.\"\nPuzzle ID: 7d419a02\nConcept: edge-recolour ascending\nKind: routine\nRoutine Subtype: grid manipulation\nOutput Typing: grid | object\nParameters: \"- name: run\\n  typing: list[cell]\\n  description: ordered coordinates\\\n  \\ of a contiguous colour run\"\nImplementation: \"- Compute k = min(3, len(run)//2). Recolour the first k and last\\\n  \\ k cells of the run\\n  to yellow.\\n- Leave interior cells unchanged.\"\nCues: '- Outputs show yellow caps growing on the ends of long cyan bands.'\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n","You are an ARC-AGI puzzle author. ARC-AGI (ARC) problems are small 2D color-grid tasks (values 0..9) where a deterministic transformation maps input to output.\n\nTask: Given ONE internal concept (YAML), write a BARC-style description block. Output a single Markdown Python block that contains exactly:\n\n```python\n# concepts: <comma-separated concept tags suitable for BARC>\n# description: <concise, deterministic I/O transformation in ARC terms>\n```\n\nGuidelines:\n- Keep it puzzle-facing: state the typical input contents and the deterministic output transformation.\n- Use ARC vocabulary (connected components, 4/8-connectivity, colors 0..9, holes/enclosed regions, symmetry, copy/move/scale, blitting, bounding boxes, etc.).\n- Deterministic only; no randomness or ambiguity.\n- Formatting: headers must appear exactly as shown; content may be inline after the colon or on subsequent commented lines.\n\nDifference vs our internal concept description: our YAML’s description is an internal note; your BARC-style description must be a self-contained puzzle spec that can drive codegen (generate_input + main).\n\nTarget concept (full YAML; may include parameters/extras):\n```yaml\nconcept: ''\ndescription: \"return the index of the stripe that contains the pink 2\\xD72.\"\nPuzzle ID: 7d419a02\nConcept: pivot stripe localisation\nKind: routine\nRoutine Subtype: search\nOutput Typing: int\nParameters: \"- name: stripes\\n  typing: list[grid]\\n  description: list of row-wise\\\n  \\ bands separated by black\\n- name: colour\\n  typing: color\\n  description: colour\\\n  \\ of the 2\\xD72 pivot block (magenta)\"\nImplementation: \"- For each stripe, scan for any 2\\xD72 block of the target colour;\\\n  \\ return its stripe\\n  index when found.\"\nCues: \"- Exactly one stripe contains the 2\\xD72 pivot; that stripe dictates where\\\n  \\ recolouring\\n  occurs.\"\n\n```\n\nHere are a few BARC-style examples to emulate (do not copy; follow the style):\nOriginal Concept:\n```yaml\nd931c21c:\n  border recolour (inside):\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: hole_colour\n      typing: color\n      description: colour of interior placeholder (4)\n    - name: border_colour\n      typing: color\n      description: target colour to paint where touching blue (3)\n    Description: Re‑colour every interior‑hole pixel (4) that shares an edge with\n      a blue pixel (1) to green 3, leaving deeper interior 4's as‑is.\n    Implementation:\n    - Build mask of hole_colour cells that are 4‑adjacent to blue; paint those to border_colour; keep non‑adjacent hole cells unchanged.\n    Cues:\n    - Only the hole cells directly touching the blue frame change to green; deeper holes remain 4.\n```\n\nConverted Description:\n```python\n# concepts: adjacency (4-connectivity), holes, border tracing, recolor\n# description: Input is a single object that forms a closed frame (blue=1) surrounding interior \"hole\" cells (4) on a background (0). Treat connectivity as 4-connected. Recolor precisely those 4-cells that share an edge with any blue=1 pixel to border_colour (green=3); leave all other 4-cells unchanged. All non-4 pixels are preserved. The result is that only the interior ring of 4 that touches the frame changes color; deeper 4-regions remain 4.\n```\n\nOriginal Concept:\n```yaml\n963f59bc:\n  colour-transfer stamping:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: reflected shape\n      typing: object\n      description: the transformed copy to stamp\n    - name: stamp colour\n      typing: color\n      description: colour taken from the pivot mark\n    Description: Apply the reflection transform, recolour the resulting shape with\n      the pivot mark's colour, and write it into the grid without altering existing\n      non-background pixels.\n    Implementation:\n    - Recolour all pixels of the transformed shape to the stamp colour.\n    - Paste onto the canvas at the computed location, skipping non-background cells.\n    Cues:\n    - Output adds coloured copies of the reference shape without overwriting existing objects.\n```\n\nConverted Description:\n```python\n# concepts: reflection across pivot axis, recolor from pivot, non-destructive blit (skip nonzero), connected components\n# description: Identify a single seed object and a distinct 1-pixel pivot mark. Reflect the seed across the vertical line through the pivot’s column (mirror columns about pivot col). Translate the reflected seed to its computed location. Recolor every pixel of the reflected copy to the pivot’s color. Stamp onto the grid by writing only into background 0 cells (skip overwrite of any nonzero); leave existing content unchanged elsewhere.\n```\n\nOriginal Concept:\n```yaml\nconnect guide object pairs:\n    Kind: grid manipulation\n    Routine Subtype: N/A\n    Output Typing: grid\n    Parameters:\n    - name: guide_object\n      typing: object | list[object]\n      description: the object(s) whose colour is unique and used as reference\n    - name: connection color\n      typing: color\n      description: colour to paint along connection paths\n    - name: color mode\n      typing: Literal['pixels','objects']\n      description: whether to paint individual pixels or recolour objects along the path\n    Description: For all non-guide objects or pixels, fill them with a connection\n      color if they are along the path(s) (row/column) between a pair of guide objects.\n      There might be multiple guide objects, and the connection path need to ensure\n      that all pairs of guide objects are connected (in a row/column/row+column way).\n    Implementation:\n    - For each unordered guide-object pair, rasterize the Manhattan path (row/column) between their anchors; paint along the path using connection color, respecting color mode.\n    Cues:\n    - Output shows straight orthogonal bands connecting guide objects.\n```\n\nConverted Description:\n```python\n# concepts: guide selection (unique color), anchors, Manhattan path, orthogonal L routing, recolor\n# description: Identify guide objects as those whose color is unique in the grid; let each guide’s anchor be its bbox centroid rounded down. For every unordered pair of guides, draw an L-shaped Manhattan path that moves HORIZONTALLY first to match the target’s column, then VERTICALLY to match its row. Paint every traversed cell with the fixed connection color (overwriting background or objects). If paths overlap, cells are painted once. All non-path cells remain as in the input.\n```\n\n"]