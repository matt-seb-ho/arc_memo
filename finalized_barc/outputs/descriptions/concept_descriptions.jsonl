{"uid": "csv_0000", "concept": {"concept": "hole counting", "description": "count the number of holes in an guide object (i.e. the number of enclosed pixels that are not the guide object's color)", "Puzzle ID": "0a2355a6", "Concept": "hole counting", "Kind": "intermediate operation", "Routine Subtype": "", "Output Typing": "int", "Parameters": "- name: guide object\n  typing: object\n  description: object within which to count enclosed background regions\n- name: color\n  typing: colour | set[colour]\n  description: which colours count as background for holes (e.g., 0)\n- name: hole_connectivity\n  typing: 4 | 8\n  description: connectivity used for counting holes", "Implementation": "- Flood-fill background from the grid border to mark exterior 0-regions.\n- Compute mask of the guide object; treat any 0-region fully enclosed by the object\n  as a hole.\n- Count holes (connected components) according to hole_connectivity if provided.", "Cues": "- Donut/ring shapes where 0-cells are fully enclosed by an object.\n- Outputs or later steps depend on the number of interior holes."}, "concepts": "hole counting, enclosed regions, guide object, connectivity (4/8)", "description": "Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0). Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color. Use specified connectivity (4 or 8) to determine whether regions are enclosed. Output is the integer count of such holes."}
{"uid": "csv_0001", "concept": {"concept": "holes", "description": "holes are empty spaces in the guide object that can be filled by the target object", "Puzzle ID": "0a2355a6", "Concept": "holes", "Kind": "term definition", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "- Define holes as background-colour regions fully enclosed by the guide object (not\n  connected to the grid border).\n- Detect by flood-filling background from the border to mark exterior; any remaining\n  background component inside the object is a hole.", "Cues": "- Donut/ring-like shapes or enclosed 0-regions inside an object.\n- Tasks that count, recolour, or otherwise reference interior empty regions."}, "concepts": "holes, enclosed regions, flood fill, background detection", "description": "Identify holes as background-color regions fully enclosed by a guide object, not connected to the grid border. Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole. Fill these holes with the target object color, ensuring they are completely enclosed by the guide object."}
{"uid": "csv_0002", "concept": {"concept": "parity counting", "description": "count the number of odd or even pixels in a guide object (i.e. the number of pixels with odd or even values)", "Puzzle ID": "0a2355a6", "Concept": "odd/even counting", "Kind": "intermediate operation", "Routine Subtype": "", "Output Typing": "int", "Parameters": "- name: guide object\n  typing: object\n  description: the object whose pixels are checked for parity\n- name: color\n  typing: colour | set[colour]\n  description: restrict counting to specific colours (e.g., only background 0)", "Implementation": "- Build a mask of the guide object; iterate its pixels and apply parity test on colour\n  index.\n- If 'color' provided, restrict to those colours; otherwise consider all colours within\n  the object except its own if specified.\n- Sum pixels satisfying the chosen parity.", "Cues": "- Task logic references odd vs even counts or colour-index parity.\n- Examples show decisions based on whether a count is odd or even."}, "concepts": "parity counting, guide object, color restriction", "description": "Input consists of a grid with various colored pixels and a designated guide object. Count the number of pixels within the guide object that have either odd or even color values. If a specific color or set of colors is provided, restrict the count to those colors only; otherwise, consider all colors present in the guide object. The output is the total count of pixels satisfying the chosen parity condition."}
{"uid": "csv_0003", "concept": {"concept": "output grid shape", "description": "set the shape of the output grid according to the guide object, other concepts, or a fixed size", "Puzzle ID": "0a2355a6", "Concept": "set output grid shape", "Kind": "grid manipulation", "Routine Subtype": "", "Output Typing": "grid", "Parameters": "- name: output grid shape\n  typing: tuple[int, int] | Callable[[object], tuple[int, int]]\n  description: target (rows, cols) or a function deriving shape from a guide object", "Implementation": "- Derive (rows, cols) from the chosen scheme (e.g., guide object's bbox or fixed size).\n- Allocate a new zero-initialised grid with that shape (dtype uint8).", "Cues": "- Output dimensions are independent of specific drawing but match a rule (bbox, fixed\n  N×M).\n- Specification mentions output shape explicitly."}, "concepts": "output grid shape, guide object, bounding box, zero-initialized grid", "description": "Determine the output grid's shape based on a specified rule: either a fixed size or derived from a guide object's bounding box. Allocate a new grid with the calculated dimensions, initialized to zero (background color). The output grid's dimensions are independent of the input's specific content but adhere to the defined shape rule."}
{"uid": "csv_0004", "concept": {"concept": "guide object", "description": "use a guide object's position as a starting point for counting holes", "Puzzle ID": "0a2355a6", "Concept": "start from guide object", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "", "Parameters": "- name: starting point\n  typing: coord | object\n  description: anchor derived from the guide object", "Implementation": "- Detect candidate objects; select the guide by uniqueness criterion (e.g., colour\n  or size).\n- Use the guide's anchor (e.g., centroid or top-left) as the starting point for downstream\n  steps.", "Cues": "- One object has a unique role or colour; subsequent steps originate from that object."}, "concepts": "guide object, unique selection, anchor point, hole counting", "description": "Identify a unique guide object based on a distinct attribute (e.g., color or size). Use the guide's anchor point, such as its centroid or top-left corner, as the starting point. From this anchor, count the number of enclosed regions (holes) in the grid. The output is a count of these holes, originating from the guide's position."}
{"uid": "csv_0005", "concept": {"concept": "guide object", "description": "use the color of a guide object for identifying holes", "Puzzle ID": "0a2355a6", "Concept": "use guide object color", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "", "Parameters": "- name: color scheme\n  typing: colour | Callable[[object], colour]\n  description: use the guide object's colour value", "Implementation": "- Read the guide object's colour index and propagate it to the target operation (e.g.,\n  fill/stamp).", "Cues": "- Outputs reuse the guide object's colour for new pixels or shapes."}, "concepts": "guide object, color propagation, hole filling", "description": "Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid. A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels. The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged."}
{"uid": "csv_0006", "concept": {"concept": "line drawing", "description": "draw a line between two pixels in a grid, updating the grid accordingly", "Puzzle ID": "0d87d2a6", "Concept": "draw line", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid", "Parameters": "- name: start_pixel\n  typing: object\n  description: the starting pixel to draw the line from\n- name: end_pixel\n  typing: object\n  description: the ending pixel to draw the line to\n- name: color\n  typing: color\n  description: the color of the line to draw", "Implementation": "- draw the line pixel by pixel, picking a starting point and following the direction\n  to the end point", "Cues": "- output grid contains lines not present in the input grid"}, "concepts": "line drawing, pixel connectivity, grid update", "description": "Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels using a specified color. The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color. The rest of the grid remains unchanged."}
{"uid": "csv_0007", "concept": {"concept": "obstacles", "description": "obstacles are objects that block the path of line drawing typically", "Puzzle ID": "0d87d2a6", "Concept": "obstacles", "Kind": "term definition", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "- Any non-background pixels (objects) along a planned line/replication path that would\n  be overwritten.\n- Can be handled via detours, bypass rules, or recolouring, depending on parameters.", "Cues": "- The step specifies obstacle handling or shows detours around existing objects."}, "concepts": "obstacles, path blocking, line drawing, detours", "description": "Identify any non-background pixels (obstacles) that lie along a planned line or replication path. These obstacles block the direct path and require handling such as detours, bypassing, or recoloring. The transformation involves navigating around these obstacles to complete the path without overwriting them, ensuring the line or replication reaches its intended destination while preserving existing objects."}
{"uid": "csv_0008", "concept": {"concept": "recolor", "description": "recolor an object based on a color scheme", "Puzzle ID": "0d87d2a6", "Concept": "recolor object", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid | object", "Parameters": "- name: object\n  typing: object\n  description: the object to recolor\n- name: color scheme\n  typing: color scheme := color | Callable[[object], color]\n  description: either a single color or logic that determines what object gets which\n    color", "Implementation": "", "Cues": "- if existing structures from the input grid appear in the output grid with different\n  colors"}, "concepts": "recolor, connected components, color scheme", "description": "Identify a single connected component (object) within the grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color or a function that determines the color based on object properties. All other grid elements remain unchanged."}
{"uid": "csv_0009", "concept": {"concept": "unique color selection", "description": "From all candidate_objects choose the one whose color is not shared by any other object; this becomes the guide object.", "Puzzle ID": "0d87d2a6", "Concept": "select guide object", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "object", "Parameters": "- name: candidate_objects\n  typing: list[object]\n  description: all components detected in the grid", "Implementation": "- Extract all connected components and compute per-object features (colour, size).\n- Select the unique-colour object (or by other specified criterion) as the guide.", "Cues": "- Exactly one object has a unique colour or feature that distinguishes it from others."}, "concepts": "unique color selection, connected components, guide object identification", "description": "Extract all connected components from the grid. Identify the guide object as the one whose color is unique among all components. The guide object is the only one with a color that no other object shares. All other objects are ignored in the output."}
{"uid": "csv_0010", "concept": {"concept": "guide object", "description": "use a guide object's position as a starting point", "Puzzle ID": "0d87d2a6", "Concept": "start from guide object", "Kind": "routine", "Routine Subtype": "parameter selection", "Output Typing": "", "Parameters": "", "Implementation": "", "Cues": ""}, "concepts": "guide object, starting point, position-based transformation", "description": "Identify a guide object within the grid, characterized by a unique color or distinct feature. Use the position of this guide object as a starting point for a transformation or operation. The specific transformation depends on the task context but consistently originates from the guide object's location. The rest of the grid is processed based on this positional reference, ensuring a deterministic output transformation."}
{"uid": "csv_0011", "concept": {"concept": "guide object", "description": "use the color of a guide object for the tiling", "Puzzle ID": "0d87d2a6", "Concept": "use guide object color", "Kind": "routine", "Routine Subtype": "parameter selection", "Output Typing": "", "Parameters": "", "Implementation": "", "Cues": ""}, "concepts": "guide object, color transfer, tiling", "description": "Identify a guide object with a unique color in the grid. Use the color of this guide object to fill a designated tiling area or pattern across the grid. The tiling pattern is predefined and does not alter the structure of the grid, only the color. All other grid elements remain unchanged."}
{"uid": "csv_0012", "concept": {"concept": "hole filling", "description": "find holes on guide object so that the target object can be fully or partially filled in. The filling can be like \"Tetris\" style, as we try to find a optimized way to fill in the holes.", "Puzzle ID": "16b78196", "Concept": "fill in holes", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "grid", "Parameters": "- name: guide object\n  typing: object\n  description: the object that serves as a reference for filling in holes\n- name: target object\n  typing: object\n  description: the object to fill in holes on", "Implementation": "- Compute interior-hole mask of the guide object (background regions not connected\n  to the border).\n- Choose target-object pixels/blocks to fit the hole geometry; place them without\n  overlapping existing non-background pixels.\n- Repeat until holes are filled or no legal placement remains.", "Cues": "- Output shows previously empty regions inside a shape filled with pixels of another\n  object.\n- Holes are fully enclosed by a container object."}, "concepts": "hole filling, guide object, target object, enclosed regions, non-overlapping placement", "description": "Input consists of a guide object with enclosed holes and a separate target object. Identify interior holes within the guide object (regions not connected to the border). Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels. Continue filling until all holes are filled or no more legal placements are possible. The output grid shows previously empty regions inside the guide object filled with the target object's pixels."}
{"uid": "csv_0013", "concept": {"concept": "holes", "description": "holes are empty spaces in the guide object that can be filled by the target object", "Puzzle ID": "16b78196", "Concept": "holes", "Kind": "term definition", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "- Define as background-colour components fully enclosed by the object (not connected\n  to grid border).\n- Detect via border flood-fill; remaining background components inside the object\n  are holes.", "Cues": "- Enclosed 0-regions inside a container object.\n- Later steps fill or count these regions."}, "concepts": "holes, enclosed regions, flood-fill, connected components", "description": "Input consists of a grid with a single object enclosing empty spaces (holes). Identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border. Use flood-fill from the border to exclude non-enclosed regions. Output the grid with holes marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions."}
{"uid": "csv_0014", "concept": {"concept": "unique color selection", "description": "From all candidate_objects choose the one whose color is not shared by any other object; this becomes the guide object.", "Puzzle ID": "16b78196", "Concept": "move object", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "object", "Parameters": "- name: candidate_objects\n  typing: list[object]\n  description: all components detected in the grid", "Implementation": "- Extract connected components and compute features (colour, size, location).\n- Select the unique-colour object (or other specified criterion) as the guide.", "Cues": "- Exactly one object has a unique colour or feature that distinguishes it from others."}, "concepts": "unique color selection, connected components, object identification, guide object", "description": "Identify all connected components in the grid and determine their colors. Select the object whose color is unique (not shared by any other object) as the guide object. The output is the grid with the guide object highlighted or isolated based on its unique color, while all other objects remain unchanged."}
{"uid": "csv_0015", "concept": {"concept": "holes", "description": "find holes on guide object so that the target object can be fully or partially filled in. The filling can be like \"Tetris\" style, as we try to find a optimized way to fill in the holes.", "Puzzle ID": "1acc24af", "Concept": "fill in holes", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "", "Parameters": "- name: guide object\n  typing: object\n  description: the object that serves as a reference for filling in holes\n- name: target object\n  typing: object\n  description: the object to fill in holes on", "Implementation": "", "Cues": ""}, "concepts": "holes, filling, guide object, target object, optimization", "description": "Given a grid with a guide object and a target object, identify holes within the guide object. Fill these holes using the target object, aiming for an optimal fit. The target object may be fully or partially used to fill the holes, similar to a \"Tetris\" style filling. The goal is to maximize the filled area within the guide object without altering the guide's structure. Non-hole areas and the guide object's boundaries remain unchanged."}
{"uid": "csv_0016", "concept": {"concept": "holes", "description": "find holes on guide object so that the target object can be fully or partially filled in. The filling can be like \"Tetris\" style, as we try to find an optimized way to fill in the holes.", "Puzzle ID": "1acc24af", "Concept": "get object holes", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "list[object] | mask", "Parameters": "- name: guide_object\n  typing: object\n  description: the object that serves as a reference for filling in holes\n- name: target_object\n  typing: object\n  description: the object to fill in holes on", "Implementation": "- Derive a boolean mask of interior background components within the guide object\n  (not connected to border).\n- Optionally convert each connected component of the mask into a hole object (with\n  pixel coordinates).", "Cues": "- The next step uses hole regions as placement targets for filling or counting."}, "concepts": "holes, guide object, filling, connected components, interior regions", "description": "Input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged."}
{"uid": "csv_0017", "concept": {"concept": "holes", "description": "holes are empty spaces in the guide object that can be filled by the target object", "Puzzle ID": "1acc24af", "Concept": "holes", "Kind": "term definition", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "- Define as background-colour components fully enclosed by the object (not connected\n  to the grid border).\n- Detect by border flood-fill; remaining background components inside the object are\n  holes.", "Cues": "- Enclosed 0-regions inside a container object.\n- Later steps fill or count these regions."}, "concepts": "holes, enclosed regions, flood-fill, background components", "description": "Input consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border. Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes, typically for further processing or filling."}
{"uid": "csv_0018", "concept": {"concept": "recolor", "description": "change the color of an object to match the guide object", "Puzzle ID": "1acc24af", "Concept": "recolor object", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "", "Parameters": "- name: object\n  typing: object\n  description: the object to recolor\n- name: new_color\n  typing: color\n  description: the new color to apply to the object", "Implementation": "", "Cues": ""}, "concepts": "recolor, guide object, connected components", "description": "Input consists of a grid with at least two distinct objects: a target object and a guide object. Identify the target object and change its color to match the color of the guide object. The guide object is distinct and serves as the reference for the new color. All other grid elements remain unchanged."}
{"uid": "csv_0019", "concept": {"concept": "unique color identification", "description": "From all candidate_objects choose the one whose color is not shared by any other object; this becomes the guide object.", "Puzzle ID": "1acc24af", "Concept": "select guide object", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "", "Parameters": "- name: candidate_objects\n  typing: ''\n  description: all components detected in the grid", "Implementation": "", "Cues": ""}, "concepts": "unique color identification, guide object selection, connected components", "description": "Input consists of multiple distinct objects on a grid, each with a unique color. Identify the guide object as the one whose color is not shared by any other object in the grid. The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged."}
{"uid": "csv_0020", "concept": {"concept": "grid partitioning", "description": "split the grid into regions based on the divider lines.", "Puzzle ID": "1acc24af", "Concept": "split grid", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "list[grid]", "Parameters": "- name: input_grid\n  typing: grid\n  description: the grid to split into regions\n- name: divider_lines\n  typing: list[int] | list[tuple[int, int]]\n  description: indices or coordinate pairs of full-row/column separators", "Implementation": "- Detect full-length separator rows/columns (e.g., grey bars) and collect their indices.\n- Slice the input grid into contiguous bands between separators.", "Cues": "- Presence of repeated full rows/columns of a single colour separating content bands."}, "concepts": "grid partitioning, separator detection, slicing", "description": "Input is a grid containing full-length separator rows or columns of a single color that divide the grid into distinct regions. Identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves. The output is a list of these sub-grids, preserving their original order and content."}
{"uid": "csv_0021", "concept": {"concept": "grid partitioning", "description": "split the grid into regions based on divider lines, which are horizontal or vertical lines that separate different areas in the grid.", "Puzzle ID": "1acc24af", "Concept": "split on divider lines", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "list[grid]", "Parameters": "- name: input_grid\n  typing: grid\n  description: the grid to split into regions\n- name: divider_lines\n  typing: list[int] | list[tuple[int, int]]\n  description: indices or coordinate pairs of full-row/column separators", "Implementation": "- Scan for uninterrupted rows/columns of a single divider colour; record their indices.\n- Use these indices to slice the grid into bands; return the non-empty sub-grids.", "Cues": "- Alternating content and uniform divider rows/columns are visible in the grid."}, "concepts": "grid partitioning, divider lines, horizontal/vertical slicing", "description": "Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions. Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids. Each sub-grid is bounded by the divider lines and contains no dividers within it. Output is a list of these non-empty sub-grids, preserving their original content."}
{"uid": "csv_0022", "concept": {"concept": "pattern extrapolation", "description": "infer a consistent transformation pattern (e.g., movement, size change, or color shift) across multiple steps and apply it to predict the next step.", "Puzzle ID": "351d6448", "Concept": "extrapolate pattern", "Kind": "routine", "Routine Subtype": "pattern recognition", "Output Typing": "pattern", "Parameters": "- name: grids\n  typing: list[grid]\n  description: a list of sequential grids (e.g., time steps) to analyze for evolving\n    patterns\n- name: feature\n  typing: enum['position', 'size', 'color']\n  description: the aspect of the object to extrapolate from (e.g., movement, growth,\n    recoloring)", "Implementation": "- Reduce each relevant row to a 1D feature (e.g., length/position of coloured run\n  separated by grey rows).\n- Fit the simplest progression consistent with the examples (constant section, linear\n  growth, or repetition length).\n- Emit a compact 1×W grid encoding the predicted sequence for the next step.", "Cues": "- look for step-wise changes in object position, size, or color\n- check for linear, arithmetic, or geometric progressions\n- identify the next logical continuation of a visual or spatial trend"}, "concepts": "pattern extrapolation, sequence prediction, feature analysis, progression detection", "description": "Input consists of a sequence of grids representing consecutive time steps, where objects exhibit a consistent transformation pattern in terms of position, size, or color. Analyze the sequence to identify the evolving pattern, such as linear movement, size change, or color shift. Extrapolate the identified pattern to predict and generate the next grid in the sequence. The output is a single grid that continues the detected pattern logically from the last input grid."}
{"uid": "csv_0023", "concept": {"concept": "object movement", "description": "move an object to a new position in the grid, updating the grid accordingly", "Puzzle ID": "351d6448", "Concept": "move object", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid | object", "Parameters": "- name: object\n  typing: object\n  description: the object to move\n- name: position\n  typing: position\n  description: the position to move the object to", "Implementation": "- can draw the object at the new position, but most erase the object pixels from the\n  old position first", "Cues": "- if existing structures from the input grid appear in the output grid with different\n  positions"}, "concepts": "object movement, grid update, erase and redraw", "description": "Identify a single object within the grid and a target position. Remove the object from its original location by erasing its pixels. Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels. The grid is updated to reflect the object's new position, with all other elements unchanged."}
{"uid": "csv_0024", "concept": {"concept": "recolor", "description": "recolor an object based on a color scheme", "Puzzle ID": "351d6448", "Concept": "recolor object", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid | object", "Parameters": "- name: object\n  typing: object\n  description: the object to recolor\n- name: color scheme\n  typing: color scheme := color | Callable[[object], color]\n  description: either a single color or logic that determines what object gets which\n    color", "Implementation": "", "Cues": "- if existing structures from the input grid appear in the output grid with different\n  colors"}, "concepts": "recolor, connected components, color scheme", "description": "Identify a single connected object in the input grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color applied uniformly or a logic that determines the color for each part of the object. All other grid elements remain unchanged."}
{"uid": "csv_0025", "concept": {"concept": "grid partitioning", "description": "where the grid is split into multiple regions that are treated as distinct", "Puzzle ID": "351d6448", "Concept": "split grid", "Kind": "structure", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "", "Cues": "- divider lines that span the grid and partition it\n- color based regions-- i.e. pixels of a color only appear in a certain section of\n  the grid"}, "concepts": "grid partitioning, divider lines, color-based regions", "description": "The input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors that do not appear in other regions. The task is to identify these regions and treat them as separate entities for further processing. The output maintains the structure of these regions without altering the internal arrangement of pixels within each region."}
{"uid": "csv_0026", "concept": {"concept": "divider lines", "description": "identify lines that divide the grid into regions, extract these regions", "Puzzle ID": "351d6448", "Concept": "split on divider lines", "Kind": "routine", "Routine Subtype": "splitting scheme", "Output Typing": "list[grid]", "Parameters": "- name: grid\n  typing: grid\n  description: the grid to split", "Implementation": "- determine where divider lines are and use array slicing to extract the regions", "Cues": ""}, "concepts": "divider lines, region extraction, array slicing", "description": "Input is a grid potentially divided into distinct regions by horizontal or vertical lines of a specific color. Identify these divider lines and use them to segment the grid into separate regions. Each region is extracted as a subgrid, excluding the divider lines themselves. Output is a list of these subgrids, preserving their original content and relative order."}
{"uid": "csv_0027", "concept": {"concept": "translation", "description": "translate the target so it touches the reference on *side* and merge the two shapes into one.", "Puzzle ID": "4c177718", "Concept": "attach object", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid", "Parameters": "- name: reference\n  typing: object | grid\n  description: anchor object/grid to attach to (top/bottom row acts as reference band)\n- name: target\n  typing: object\n  description: the object to translate toward the reference\n- name: side\n  typing: direction\n  description: which side of the reference the target must touch (up/down/left/right)", "Implementation": "- Compute target bbox and reference contact edge for the given side.\n- Translate target so its nearest edge touches the reference edge without overlap.\n- Paint target pixels into the grid; preserve existing reference pixels.", "Cues": "- Output shows target objects lined up to touch a band (e.g., below a grey divider)\n  or another object with no gap."}, "concepts": "translation, alignment, merging, connected components", "description": "Given a grid with a reference object and a target object, translate the target so it touches the reference on a specified side (up/down/left/right). Align the nearest edge of the target to the contact edge of the reference without overlap. Merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels. The output grid shows the target object aligned and merged with the reference object on the specified side."}
{"uid": "csv_0028", "concept": {"concept": "orientation detection", "description": "infer the cardinal direction encoded by a rotated pointer shape.", "Puzzle ID": "4c177718", "Concept": "orientation of pointer", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "direction", "Parameters": "- name: pointer\n  typing: object\n  description: the pointer-shaped object whose orientation encodes a direction\n- name: mapping\n  typing: dict[shape, direction]\n  description: optional explicit mapping from canonical rotated shape to direction", "Implementation": "- Normalise the pointer by rotation/flip to a canonical template; select the matching\n  direction.\n- Alternatively, compute facing by comparing centroid-to-tip vector to axes and quantising\n  to NSEW.", "Cues": "- A consistent pointer/arrowhead shape whose orientation determines where to attach/move."}, "concepts": "orientation detection, shape normalization, centroid-to-tip vector, direction quantization", "description": "Input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation. Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W). Output the determined direction as a label."}
{"uid": "csv_0029", "concept": {"concept": "divider detection", "description": "identify lines that divide the grid into regions, extract these regions", "Puzzle ID": "4c177718", "Concept": "split on divider lines", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "list[grid]", "Parameters": "- name: input_grid\n  typing: grid\n  description: the grid to split into bands\n- name: divider_lines\n  typing: list[int] | list[tuple[int, int]]\n  description: indices or coordinate pairs of full-row/column separators", "Implementation": "- Detect uninterrupted full rows/columns of a single colour (e.g., grey) and record\n  their indices.\n- Slice the grid into contiguous sub-grids between separators; discard empty bands.", "Cues": "- Visible uniform divider bars separating top/bottom regions."}, "concepts": "divider detection, grid slicing, connected components, sub-grid extraction", "description": "Input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey). Identify these divider lines and use them to split the grid into contiguous sub-grids. Each sub-grid is extracted as a separate region between dividers. Discard any empty sub-grids. The output is a list of these non-empty sub-grids, preserving their original order and content."}
{"uid": "csv_0030", "concept": {"concept": "gravity simulation", "description": "simulate gravity in the specified direction to translate blocks until they rest on obstacles or boundaries", "Puzzle ID": "5ffb2104", "Concept": "gravity movement", "Kind": "intermediate operation", "Routine Subtype": "", "Output Typing": "grid", "Parameters": "- name: direction\n  typing: Literal['down','up','left','right']\n  description: direction of the gravity\n- name: cohesion mode\n  typing: Literal['cohesive','per-column']\n  description: whether the object falls as a whole (cohesive) or columns fall independently", "Implementation": "- For the chosen direction, sweep cells toward that side.\n- If cohesion mode is 'per-column', collapse each column independently stopping at\n  blockers; else treat the object as one rigid shape and translate until contact.\n- Preserve order/shape; stop when further movement would collide or leave grid.", "Cues": "- Outputs show blocks shifted flush against walls or other blocks along one axis;\n  empty space appears opposite the fall direction."}, "concepts": "gravity simulation, directional movement, cohesion modes, collision detection", "description": "Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction."}
{"uid": "csv_0031", "concept": {"concept": "object identification", "description": "move an object to a new position in the grid", "Puzzle ID": "5ffb2104", "Concept": "move object", "Kind": "", "Routine Subtype": "grid manipulation", "Output Typing": "grid | object", "Parameters": "- name: object\n  typing: object\n  description: the object to move\n- name: new position\n  typing: position := tuple[int, int]\n  description: the new position (row, column) to move the object to", "Implementation": "- can draw the object at the new position, but most erase the object pixels from the\n  old position first", "Cues": "- if the object's position changes in the output grid compared to the input grid"}, "concepts": "object identification, translation, erasure, grid manipulation", "description": "Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0). Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates. Redraw the object at the new position, preserving its shape and color. The output grid reflects the object moved to the new location with its original position cleared."}
{"uid": "csv_0032", "concept": {"concept": "L-shape detection", "description": "identify which of the four corners is *not* occupied in a 3-pixel L-shape.", "Puzzle ID": "626c0bcc", "Concept": "missing-corner orientation", "Kind": "routine", "Routine Subtype": "intermediate", "Output Typing": "orientation := Literal[\"tl\",\"tr\",\"bl\",\"br\"]", "Parameters": "- name: mask\n  typing: grid\n  description: Boolean 2 × 2 mask for the L-shape", "Implementation": "- Inspect the 2×2 mask and locate the zero cell; map its position to one of {tl,tr,bl,br}.\n- Robustness: allow one-pixel noise by using majority over local neighbourhood if\n    needed.", "Cues": "- An L-shaped triomino needs to be classified to drive colour assignment."}, "concepts": "L-shape detection, corner identification, orientation classification", "description": "Input is a 3-pixel L-shaped triomino on a 2x2 grid. Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape. Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner. The grid may contain noise, but the L-shape is dominant."}
{"uid": "csv_0033", "concept": {"concept": "orientation detection", "description": "recolour an object using a fixed map (tl→red 3, bl→green 2, tr→yellow 4, br→blue 1).", "Puzzle ID": "626c0bcc", "Concept": "orientation-based recolor", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid | object", "Parameters": "- name: object\n  typing: object\n  description: the object to recolor\n- name: orientation\n  typing: orientation\n  description: one of tl/tr/bl/br computed from the object's L-shape mask", "Implementation": "- Compute orientation via missing-corner orientation; pick colour by lookup table.\n- Paint all object pixels with the mapped colour.", "Cues": "- Output shows identical shapes recoloured differently depending on their corner orientation."}, "concepts": "orientation detection, recolor, connected components, bounding box", "description": "Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right). Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1). The background and any other grid content remain unchanged."}
{"uid": "csv_0034", "concept": {"concept": "window scanning", "description": "returns **True** when every cell in the 2 × 2 window matches the target colour (here, cyan).", "Puzzle ID": "626c0bcc", "Concept": "square pattern criteria", "Kind": "routine", "Routine Subtype": "selection criteria", "Output Typing": "bool", "Parameters": "- name: window\n  typing: grid\n  description: 2 × 2 slice of the grid being tested\n- name: colour\n  typing: color\n  description: ''", "Implementation": "", "Cues": ""}, "concepts": "window scanning, color matching, pattern detection", "description": "Input is a grid with various colors. For each 2x2 window in the grid, check if all cells match a specified target color. Return True if every cell in the window matches the target color; otherwise, return False. This operation is applied to each 2x2 window independently."}
{"uid": "csv_0035", "concept": {"concept": "diagonal movement", "description": "draw a diagonal zig zag by alternating between m pixels in left/right direction and then n pixels in up/down direction", "Puzzle ID": "69889d6e", "Concept": "diagonal zigzag shape pattern", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "pattern", "Parameters": "- name: horizontal_step\n  typing: int\n  description: number of pixels to move horizontally before turning\n- name: vertical_step\n  typing: int\n  description: number of pixels to move vertically before turning", "Implementation": "- Starting at the first seed pixel, repeat (horizontal_step, vertical_step) moves,\n  painting along the way.\n- Stop when reaching boundary or the target contact condition.", "Cues": "- Output shows a staircase diagonal composed of axis-aligned runs with constant stride."}, "concepts": "diagonal movement, zigzag pattern, axis-aligned runs, boundary detection", "description": "Starting from a seed pixel, create a diagonal zigzag pattern by alternating between horizontal and vertical movements. Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step), painting each traversed pixel. Continue this alternating pattern until reaching the grid boundary. The result is a staircase-like diagonal composed of axis-aligned segments."}
{"uid": "csv_0036", "concept": {"concept": "line drawing", "description": "draw a line between two pixels in a grid, updating the grid accordingly", "Puzzle ID": "69889d6e", "Concept": "draw line", "Kind": "", "Routine Subtype": "grid manipulation", "Output Typing": "grid", "Parameters": "- name: start_pixel\n  typing: object\n  description: the starting pixel to draw the line from\n- name: end_pixel\n  typing: object\n  description: the ending pixel to draw the line to\n- name: color\n  typing: color\n  description: the color of the line to draw", "Implementation": "- draw the line pixel by pixel, picking a starting point and following the direction\n  to the end point", "Cues": "- output grid contains lines not present in the input grid"}, "concepts": "line drawing, pixel connectivity, grid update", "description": "Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels. Use Bresenham's line algorithm to determine the path of the line. Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged."}
{"uid": "csv_0037", "concept": {"concept": "obstacle navigation", "description": "navigate around an obstacle by turning in a specified direction to get past", "Puzzle ID": "69889d6e", "Concept": "fixed direction for obstacle navigation", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "obstacle handling", "Parameters": "- name: turn\n  typing: Literal['left','right']\n  description: which way to turn when encountering an obstacle", "Implementation": "- When a drawing step hits an obstacle, change heading by the specified turn and continue\n  until alignment is restored.", "Cues": "- Output shows consistent detours at obstacles, always turning the same way."}, "concepts": "obstacle navigation, fixed direction turn, pathfinding", "description": "Input is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered. When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear. Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, always turning the same way as specified."}
{"uid": "csv_0038", "concept": {"concept": "object selection", "description": "select object(s) from the grid for a specific role", "Puzzle ID": "69889d6e", "Concept": "object selection", "Kind": "intermediate operation", "Routine Subtype": "", "Output Typing": "list[object] | object", "Parameters": "- name: selection criteria\n  typing: Callable[[object], bool] | str\n  description: predicate or named rule to select relevant objects", "Implementation": "- Extract connected components and filter them by the selection criteria.", "Cues": "- Only a subset of objects are used as seeds or targets in the output."}, "concepts": "object selection, connected components, filtering", "description": "Extract all connected components (objects) from the input grid. Apply a selection criterion to filter these objects, retaining only those that meet the specified condition. The output is a list of the selected objects, each represented by its bounding box and constituent pixels. Non-selected objects are excluded from the output."}
{"uid": "csv_0039", "concept": {"concept": "obstacles", "description": "obstacles are objects that block the path of line drawing typically", "Puzzle ID": "69889d6e", "Concept": "obstacles", "Kind": "term definition", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "", "Cues": ""}, "concepts": "obstacles, path blocking, line drawing", "description": "Identify obstacles as distinct objects in the grid that block the path of line drawing. When drawing a line between two points, the line must navigate around these obstacles, ensuring no part of the line overlaps with any obstacle. The output grid shows the line drawn from start to end, avoiding obstacles, while all other grid content remains unchanged."}
{"uid": "csv_0040", "concept": {"concept": "specific color selection", "description": "select objects of a fixed color", "Puzzle ID": "69889d6e", "Concept": "specific color based selection", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "", "Parameters": "- name: color\n  typing: ''\n  description: the color to select objects of", "Implementation": "", "Cues": ""}, "concepts": "specific color selection, connected components, filtering", "description": "Input consists of multiple objects of various colors on a grid. Identify and select all objects that are composed entirely of a specified target color. Output a grid where only these selected objects are preserved in their original positions and colors, while all other grid cells are set to background color (0)."}
{"uid": "csv_0041", "concept": {"concept": "guide object", "description": "use a guide object's position as a starting point", "Puzzle ID": "69889d6e", "Concept": "start from guide pixel", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "", "Cues": ""}, "concepts": "guide object, starting point, position-based transformation", "description": "Identify a distinct guide object within the grid. Use the position of this guide object as a starting point for a transformation or operation. The specific transformation depends on the task context, but it consistently initiates from the guide's position. The guide's position is determined by its unique color or shape, and the transformation is deterministic based on this starting point."}
{"uid": "csv_0042", "concept": {"concept": "guide object", "description": "use the color of a guide object for the line", "Puzzle ID": "69889d6e", "Concept": "use guide object color", "Kind": "parameter selection", "Routine Subtype": "", "Output Typing": "", "Parameters": "", "Implementation": "", "Cues": ""}, "concepts": "guide object, color transfer, line drawing", "description": "Identify a guide object with a unique color in the grid. Use this color to draw a line between two specified points or along a specified path. The line is drawn by overwriting the background cells with the guide object's color. All other non-background cells remain unchanged."}
{"uid": "csv_0043", "concept": {"concept": "boolean mask", "description": "Produce a boolean mask marking the coordinates in `block` where `predicate` evaluates to **True** (e.g. \"cells with colour = X\"). This mask serves as a transferable template.", "Puzzle ID": "79369cc6", "Concept": "capture pattern mask", "Kind": "routine", "Routine Subtype": "parameter selection", "Output Typing": "mask", "Parameters": "- name: block\n  typing: grid\n  description: source grid region (e.g., 3×3 window) to analyse\n- name: predicate\n  typing: Callable[[cell], bool]\n  description: returns **True** for cells that belong to the pattern", "Implementation": "- Evaluate `predicate` at every coordinate in `block` and record a True/False mask.\n- Return the mask for reuse when scanning other windows.", "Cues": "- Repeated 3×3 motifs appear; a reusable mask/template is needed to recognise them."}, "concepts": "boolean mask, predicate evaluation, pattern recognition, template creation", "description": "Input is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for identifying the pattern in other grid regions."}
{"uid": "csv_0044", "concept": {"concept": "window processing", "description": "For every cell in `window_coords` whose current value does **not** satisfy `predicate`, assign `fill_value`.  Used to complete each matched 3 × 3 window once the pattern has been recognised.", "Puzzle ID": "79369cc6", "Concept": "fill window cells", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid", "Parameters": "- name: window_coords\n  typing: list[coord]\n  description: coordinates of the current 3×3 window\n- name: grid\n  typing: grid\n  description: grid to modify in-place or return as copy\n- name: fill_value\n  typing: colour | Any\n  description: value assigned to cells that fail `predicate`", "Implementation": "- Iterate coordinates in the window and check the predicate for each.\n- For those not matching, write `fill_value` to that position.", "Cues": "- Outputs show completed 3×3 motifs where certain slots are consistently filled."}, "concepts": "window processing, predicate check, conditional fill, grid manipulation", "description": "Input is a grid with specific 3x3 window coordinates and a predicate function. For each cell within the specified 3x3 window, check if it satisfies the predicate. If a cell does not satisfy the predicate, replace its value with a specified fill_value. Cells that satisfy the predicate remain unchanged. This operation completes the pattern within the window by filling only the non-matching cells."}
{"uid": "csv_0045", "concept": {"concept": "sliding window", "description": "Scan each 3 × 3 window and select the one that contains **at least one** cell of every colour in `required_colours`.  This window becomes the anchor template for later steps.", "Puzzle ID": "79369cc6", "Concept": "locate heterogeneous anchor", "Kind": "routine", "Routine Subtype": "selection criteria", "Output Typing": "coords | object", "Parameters": "- name: grid\n  typing: grid\n  description: grid to scan with a 3×3 sliding window\n- name: required_colours\n  typing: set[colour]\n  description: set of colours that must all appear at least once in the window", "Implementation": "- Slide a 3×3 window over the grid; for each window, compute the set of colours present.\n- Return the window coordinates when the set is a superset of `required_colours`.", "Cues": "- A small mixed-colour patch acts as a seed for subsequent matching/filling."}, "concepts": "sliding window, color presence, pattern matching, window selection", "description": "Input is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria."}
{"uid": "csv_0046", "concept": {"concept": "pattern matching", "description": "Return **True** if the set of cells in `window` satisfying `predicate` occupies exactly the coordinates indicated by `pattern_mask`; rotations and flips are **not** considered matches.", "Puzzle ID": "79369cc6", "Concept": "match pattern mask", "Kind": "routine", "Routine Subtype": "selection criteria", "Output Typing": "bool", "Parameters": "- name: window\n  typing: grid\n  description: candidate 3×3 window to evaluate\n- name: pattern_mask\n  typing: mask\n  description: boolean mask of required True positions\n- name: predicate\n  typing: Callable[[cell], bool]\n  description: test that identifies target cells (e.g., cell == colour)", "Implementation": "- Build a boolean mask by applying `predicate` to every cell in `window`.\n- Return True if it equals `pattern_mask` element‑wise (no rotations/flips).", "Cues": "- Exact coordinate agreement of the motif within a 3×3 window (orientation matters)."}, "concepts": "pattern matching, boolean mask, predicate evaluation, exact match", "description": "Input is a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size. A predicate function is applied to each cell in the window to create a boolean mask. Return True if this generated mask exactly matches the given pattern_mask element-wise, with no rotations or flips allowed. Otherwise, return False."}
{"uid": "csv_0047", "concept": {"concept": "contiguous run detection", "description": "detect maximal contiguous runs of the target colour along rows or columns", "Puzzle ID": "7d419a02", "Concept": "contiguous cyan run detection", "Kind": "intermediate operation", "Routine Subtype": "", "Output Typing": "list[cell] | list[list[cell]]", "Parameters": "- name: colour\n  typing: color\n  description: target run colour (cyan)", "Implementation": "- For each row (or column), scan and collect maximal sequences of the target colour.\n- Return the list of runs as coordinate lists or slices.", "Cues": "- Long straight bands of one colour appear; later steps recolour run ends."}, "concepts": "contiguous run detection, row/column scanning, maximal sequences, color filtering", "description": "Input is a grid containing various colors, including a target color (cyan). For each row and column, detect and extract maximal contiguous runs of the target color. Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color. Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal cyan runs in the grid."}
{"uid": "csv_0048", "concept": {"concept": "color runs", "description": "recolour ≤3 cells from each end of a cyan run to yellow (colour-4); amount capped at half the run length.", "Puzzle ID": "7d419a02", "Concept": "edge-recolour ascending", "Kind": "routine", "Routine Subtype": "grid manipulation", "Output Typing": "grid | object", "Parameters": "- name: run\n  typing: list[cell]\n  description: ordered coordinates of a contiguous colour run", "Implementation": "- Compute k = min(3, len(run)//2). Recolour the first k and last k cells of the run\n  to yellow.\n- Leave interior cells unchanged.", "Cues": "- Outputs show yellow caps growing on the ends of long cyan bands."}, "concepts": "color runs, recolor, bounding box, symmetry", "description": "Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down). Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion."}
{"uid": "csv_0049", "concept": {"concept": "stripe detection", "description": "return the index of the stripe that contains the pink 2×2.", "Puzzle ID": "7d419a02", "Concept": "pivot stripe localisation", "Kind": "routine", "Routine Subtype": "search", "Output Typing": "int", "Parameters": "- name: stripes\n  typing: list[grid]\n  description: list of row-wise bands separated by black\n- name: colour\n  typing: color\n  description: colour of the 2×2 pivot block (magenta)", "Implementation": "- For each stripe, scan for any 2×2 block of the target colour; return its stripe\n  index when found.", "Cues": "- Exactly one stripe contains the 2×2 pivot; that stripe dictates where recolouring\n  occurs."}, "concepts": "stripe detection, 2x2 block search, color matching, index retrieval", "description": "Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks. Identify the stripe containing a 2x2 block of a specific target color (magenta). Return the index of this stripe (0-based) that contains the target 2x2 block. Only one stripe will contain the target block, ensuring a unique index is returned."}
