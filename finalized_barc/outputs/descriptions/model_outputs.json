[["```python\n# concepts: hole counting, enclosed regions, guide object, connectivity (4/8)\n# description: Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0). Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color. Use specified connectivity (4 or 8) to determine whether regions are enclosed. Output is the integer count of such holes.\n```"],["```python\n# concepts: holes, enclosed regions, flood fill, background detection\n# description: Identify holes as background-color regions fully enclosed by a guide object, not connected to the grid border. Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole. Fill these holes with the target object color, ensuring they are completely enclosed by the guide object.\n```"],["```python\n# concepts: parity counting, guide object, color restriction\n# description: Input consists of a grid with various colored pixels and a designated guide object. Count the number of pixels within the guide object that have either odd or even color values. If a specific color or set of colors is provided, restrict the count to those colors only; otherwise, consider all colors present in the guide object. The output is the total count of pixels satisfying the chosen parity condition.\n```"],["```python\n# concepts: output grid shape, guide object, bounding box, zero-initialized grid\n# description: Determine the output grid's shape based on a specified rule: either a fixed size or derived from a guide object's bounding box. Allocate a new grid with the calculated dimensions, initialized to zero (background color). The output grid's dimensions are independent of the input's specific content but adhere to the defined shape rule.\n```"],["```python\n# concepts: guide object, unique selection, anchor point, hole counting\n# description: Identify a unique guide object based on a distinct attribute (e.g., color or size). Use the guide's anchor point, such as its centroid or top-left corner, as the starting point. From this anchor, count the number of enclosed regions (holes) in the grid. The output is a count of these holes, originating from the guide's position.\n```"],["```python\n# concepts: guide object, color propagation, hole filling\n# description: Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid. A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels. The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged.\n```"],["```python\n# concepts: line drawing, pixel connectivity, grid update\n# description: Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels using a specified color. The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color. The rest of the grid remains unchanged.\n```"],["```python\n# concepts: obstacles, path blocking, line drawing, detours\n# description: Identify any non-background pixels (obstacles) that lie along a planned line or replication path. These obstacles block the direct path and require handling such as detours, bypassing, or recoloring. The transformation involves navigating around these obstacles to complete the path without overwriting them, ensuring the line or replication reaches its intended destination while preserving existing objects.\n```"],["```python\n# concepts: recolor, connected components, color scheme\n# description: Identify a single connected component (object) within the grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color or a function that determines the color based on object properties. All other grid elements remain unchanged.\n```"],["```python\n# concepts: unique color selection, connected components, guide object identification\n# description: Extract all connected components from the grid. Identify the guide object as the one whose color is unique among all components. The guide object is the only one with a color that no other object shares. All other objects are ignored in the output.\n```"],["```python\n# concepts: guide object, starting point, position-based transformation\n# description: Identify a guide object within the grid, characterized by a unique color or distinct feature. Use the position of this guide object as a starting point for a transformation or operation. The specific transformation depends on the task context but consistently originates from the guide object's location. The rest of the grid is processed based on this positional reference, ensuring a deterministic output transformation.\n```"],["```python\n# concepts: guide object, color transfer, tiling\n# description: Identify a guide object with a unique color in the grid. Use the color of this guide object to fill a designated tiling area or pattern across the grid. The tiling pattern is predefined and does not alter the structure of the grid, only the color. All other grid elements remain unchanged.\n```"],["```python\n# concepts: hole filling, guide object, target object, enclosed regions, non-overlapping placement\n# description: Input consists of a guide object with enclosed holes and a separate target object. Identify interior holes within the guide object (regions not connected to the border). Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels. Continue filling until all holes are filled or no more legal placements are possible. The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n```"],["```python\n# concepts: holes, enclosed regions, flood-fill, connected components\n# description: Input consists of a grid with a single object enclosing empty spaces (holes). Identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border. Use flood-fill from the border to exclude non-enclosed regions. Output the grid with holes marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions.\n```"],["```python\n# concepts: unique color selection, connected components, object identification, guide object\n# description: Identify all connected components in the grid and determine their colors. Select the object whose color is unique (not shared by any other object) as the guide object. The output is the grid with the guide object highlighted or isolated based on its unique color, while all other objects remain unchanged.\n```"],["```python\n# concepts: holes, filling, guide object, target object, optimization\n# description: Given a grid with a guide object and a target object, identify holes within the guide object. Fill these holes using the target object, aiming for an optimal fit. The target object may be fully or partially used to fill the holes, similar to a \"Tetris\" style filling. The goal is to maximize the filled area within the guide object without altering the guide's structure. Non-hole areas and the guide object's boundaries remain unchanged.\n```"],["```python\n# concepts: holes, guide object, filling, connected components, interior regions\n# description: Input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged.\n```"],["```python\n# concepts: holes, enclosed regions, flood-fill, background components\n# description: Input consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border. Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes, typically for further processing or filling.\n```"],["```python\n# concepts: recolor, guide object, connected components\n# description: Input consists of a grid with at least two distinct objects: a target object and a guide object. Identify the target object and change its color to match the color of the guide object. The guide object is distinct and serves as the reference for the new color. All other grid elements remain unchanged.\n```"],["```python\n# concepts: unique color identification, guide object selection, connected components\n# description: Input consists of multiple distinct objects on a grid, each with a unique color. Identify the guide object as the one whose color is not shared by any other object in the grid. The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged.\n```"],["```python\n# concepts: grid partitioning, separator detection, slicing\n# description: Input is a grid containing full-length separator rows or columns of a single color that divide the grid into distinct regions. Identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves. The output is a list of these sub-grids, preserving their original order and content.\n```"],["```python\n# concepts: grid partitioning, divider lines, horizontal/vertical slicing\n# description: Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions. Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids. Each sub-grid is bounded by the divider lines and contains no dividers within it. Output is a list of these non-empty sub-grids, preserving their original content.\n```"],["```python\n# concepts: pattern extrapolation, sequence prediction, feature analysis, progression detection\n# description: Input consists of a sequence of grids representing consecutive time steps, where objects exhibit a consistent transformation pattern in terms of position, size, or color. Analyze the sequence to identify the evolving pattern, such as linear movement, size change, or color shift. Extrapolate the identified pattern to predict and generate the next grid in the sequence. The output is a single grid that continues the detected pattern logically from the last input grid.\n```"],["```python\n# concepts: object movement, grid update, erase and redraw\n# description: Identify a single object within the grid and a target position. Remove the object from its original location by erasing its pixels. Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels. The grid is updated to reflect the object's new position, with all other elements unchanged.\n```"],["```python\n# concepts: recolor, connected components, color scheme\n# description: Identify a single connected object in the input grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color applied uniformly or a logic that determines the color for each part of the object. All other grid elements remain unchanged.\n```"],["```python\n# concepts: grid partitioning, divider lines, color-based regions\n# description: The input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors that do not appear in other regions. The task is to identify these regions and treat them as separate entities for further processing. The output maintains the structure of these regions without altering the internal arrangement of pixels within each region.\n```"],["```python\n# concepts: divider lines, region extraction, array slicing\n# description: Input is a grid potentially divided into distinct regions by horizontal or vertical lines of a specific color. Identify these divider lines and use them to segment the grid into separate regions. Each region is extracted as a subgrid, excluding the divider lines themselves. Output is a list of these subgrids, preserving their original content and relative order.\n```"],["```python\n# concepts: translation, alignment, merging, connected components\n# description: Given a grid with a reference object and a target object, translate the target so it touches the reference on a specified side (up/down/left/right). Align the nearest edge of the target to the contact edge of the reference without overlap. Merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels. The output grid shows the target object aligned and merged with the reference object on the specified side.\n```"],["```python\n# concepts: orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n# description: Input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation. Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W). Output the determined direction as a label.\n```"],["```python\n# concepts: divider detection, grid slicing, connected components, sub-grid extraction\n# description: Input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey). Identify these divider lines and use them to split the grid into contiguous sub-grids. Each sub-grid is extracted as a separate region between dividers. Discard any empty sub-grids. The output is a list of these non-empty sub-grids, preserving their original order and content.\n```"],["```python\n# concepts: gravity simulation, directional movement, cohesion modes, collision detection\n# description: Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n```"],["```python\n# concepts: object identification, translation, erasure, grid manipulation\n# description: Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0). Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates. Redraw the object at the new position, preserving its shape and color. The output grid reflects the object moved to the new location with its original position cleared.\n```"],["```python\n# concepts: L-shape detection, corner identification, orientation classification\n# description: Input is a 3-pixel L-shaped triomino on a 2x2 grid. Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape. Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner. The grid may contain noise, but the L-shape is dominant.\n```"],["```python\n# concepts: orientation detection, recolor, connected components, bounding box\n# description: Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right). Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1). The background and any other grid content remain unchanged.\n```"],["```python\n# concepts: window scanning, color matching, pattern detection\n# description: Input is a grid with various colors. For each 2x2 window in the grid, check if all cells match a specified target color. Return True if every cell in the window matches the target color; otherwise, return False. This operation is applied to each 2x2 window independently.\n```"],["```python\n# concepts: diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n# description: Starting from a seed pixel, create a diagonal zigzag pattern by alternating between horizontal and vertical movements. Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step), painting each traversed pixel. Continue this alternating pattern until reaching the grid boundary. The result is a staircase-like diagonal composed of axis-aligned segments.\n```"],["```python\n# concepts: line drawing, pixel connectivity, grid update\n# description: Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels. Use Bresenham's line algorithm to determine the path of the line. Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged.\n```"],["```python\n# concepts: obstacle navigation, fixed direction turn, pathfinding\n# description: Input is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered. When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear. Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, always turning the same way as specified.\n```"],["```python\n# concepts: object selection, connected components, filtering\n# description: Extract all connected components (objects) from the input grid. Apply a selection criterion to filter these objects, retaining only those that meet the specified condition. The output is a list of the selected objects, each represented by its bounding box and constituent pixels. Non-selected objects are excluded from the output.\n```"],["```python\n# concepts: obstacles, path blocking, line drawing\n# description: Identify obstacles as distinct objects in the grid that block the path of line drawing. When drawing a line between two points, the line must navigate around these obstacles, ensuring no part of the line overlaps with any obstacle. The output grid shows the line drawn from start to end, avoiding obstacles, while all other grid content remains unchanged.\n```"],["```python\n# concepts: specific color selection, connected components, filtering\n# description: Input consists of multiple objects of various colors on a grid. Identify and select all objects that are composed entirely of a specified target color. Output a grid where only these selected objects are preserved in their original positions and colors, while all other grid cells are set to background color (0).\n```"],["```python\n# concepts: guide object, starting point, position-based transformation\n# description: Identify a distinct guide object within the grid. Use the position of this guide object as a starting point for a transformation or operation. The specific transformation depends on the task context, but it consistently initiates from the guide's position. The guide's position is determined by its unique color or shape, and the transformation is deterministic based on this starting point.\n```"],["```python\n# concepts: guide object, color transfer, line drawing\n# description: Identify a guide object with a unique color in the grid. Use this color to draw a line between two specified points or along a specified path. The line is drawn by overwriting the background cells with the guide object's color. All other non-background cells remain unchanged.\n```"],["```python\n# concepts: boolean mask, predicate evaluation, pattern recognition, template creation\n# description: Input is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for identifying the pattern in other grid regions.\n```"],["```python\n# concepts: window processing, predicate check, conditional fill, grid manipulation\n# description: Input is a grid with specific 3x3 window coordinates and a predicate function. For each cell within the specified 3x3 window, check if it satisfies the predicate. If a cell does not satisfy the predicate, replace its value with a specified fill_value. Cells that satisfy the predicate remain unchanged. This operation completes the pattern within the window by filling only the non-matching cells.\n```"],["```python\n# concepts: sliding window, color presence, pattern matching, window selection\n# description: Input is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n```"],["```python\n# concepts: pattern matching, boolean mask, predicate evaluation, exact match\n# description: Input is a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size. A predicate function is applied to each cell in the window to create a boolean mask. Return True if this generated mask exactly matches the given pattern_mask element-wise, with no rotations or flips allowed. Otherwise, return False.\n```"],["```python\n# concepts: contiguous run detection, row/column scanning, maximal sequences, color filtering\n# description: Input is a grid containing various colors, including a target color (cyan). For each row and column, detect and extract maximal contiguous runs of the target color. Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color. Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal cyan runs in the grid.\n```"],["```python\n# concepts: color runs, recolor, bounding box, symmetry\n# description: Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down). Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion.\n```"],["```python\n# concepts: stripe detection, 2x2 block search, color matching, index retrieval\n# description: Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks. Identify the stripe containing a 2x2 block of a specific target color (magenta). Return the index of this stripe (0-based) that contains the target 2x2 block. Only one stripe will contain the target block, ensuring a unique index is returned.\n```"]]