{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity (4/8)\n\n# description:\n# Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# Use specified connectivity (4 or 8) to determine whether regions are enclosed. Output is the integer count of such holes.\n\ndef main(input_grid):\n    # Find the guide object, assuming there is only one\n    guide_object = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)[0]\n\n    # Create interior and boundary masks\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    boundary_mask = object_boundary(guide_object, background=Color.BLACK)\n\n    # Find enclosed regions that are not part of the guide object's color\n    enclosed_mask = interior_mask & ~boundary_mask\n    enclosed_regions = find_connected_components((enclosed_mask & (guide_object == Color.BLACK)).astype(int), background=0, connectivity=4)\n    \n    # Count the number of enclosed regions (holes)\n    num_holes = len(enclosed_regions)\n\n    return num_holes\n\n\ndef generate_input():\n    # Create a random grid size\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a guide object with a random color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_object_size = np.random.randint(4, min(grid_size, 10))\n    guide_object = np.full((guide_object_size, guide_object_size), guide_color)\n\n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, guide_object_size // 2)\n        hole_x, hole_y = np.random.randint(1, guide_object_size - hole_size), np.random.randint(1, guide_object_size - hole_size)\n        guide_object[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Place the guide object randomly on the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n        blit_sprite(grid, guide_object, x, y)\n    except ValueError:\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity (4/8)\n\n# description:\n# Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# Use specified connectivity (4 or 8) to determine whether regions are enclosed. Output is the integer count of such holes.\n\ndef main(input_grid, guide_color=Color.RED, connectivity=4):\n    # Find the guide object in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=connectivity, monochromatic=True)\n    \n    # Assume there is only one guide object, which is the largest connected component of the guide color\n    guide_object = max(objects, key=lambda obj: np.sum(obj == guide_color))\n    \n    # Determine the interior of the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    \n    # Count the number of enclosed regions (holes) within the interior of the guide object\n    hole_count = 0\n    for x, y in np.argwhere(interior_mask):\n        if input_grid[x, y] == Color.BLACK:\n            # Check if this black region is a hole using the specified connectivity\n            components = find_connected_components(input_grid[x-1:x+2, y-1:y+2], background=Color.BLACK, connectivity=connectivity, monochromatic=True)\n            if len(components) == 1:\n                hole_count += 1\n\n    return hole_count\n\n\ndef generate_input():\n    # Create a random-sized grid with black background\n    grid_size = np.random.randint(12, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Create a random guide object with a specific color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_size = np.random.randint(5, min(grid_size - 2, 10))\n    guide_object = np.full((guide_size, guide_size), guide_color)\n    \n    # Hollow out regions within the guide object to create potential holes\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, guide_size - 1)\n        hole_x, hole_y = np.random.randint(1, guide_size - hole_size), np.random.randint(1, guide_size - hole_size)\n        guide_object[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n    \n    # Place the guide object randomly on the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK, border_size=1)\n        blit_sprite(grid, guide_object, x, y)\n    except ValueError:\n        return generate_input()  # Retry if failed to place the object\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity (4/8)\n\n# description:\n# The input grid consists of a black grid with a single guide object of a specific color, which may enclose regions of the background color (black).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# Use specified connectivity (4 or 8) to determine whether regions are enclosed.\n# The output is the integer count of such holes.\n\ndef main(input_grid, guide_color, connectivity=4):\n    # Get the guide object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=connectivity, monochromatic=True)\n    guide_object = None\n    for obj in objects:\n        if np.any(obj == guide_color):\n            guide_object = obj\n            break\n    \n    if guide_object is None:\n        return 0  # No guide object found\n\n    # Create a mask for the interior of the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n\n    # Identify and count holes in the interior\n    hole_count = 0\n    visited = np.zeros(input_grid.shape, dtype=bool)\n    for x, y in np.argwhere(interior_mask):\n        if not visited[x, y] and guide_object[x, y] == Color.BLACK:\n            # Find the connected component of this black region\n            hole = find_connected_components(input_grid[x-1:x+2, y-1:y+2], background=Color.BLACK, connectivity=connectivity, monochromatic=True)\n            hole_count += 1\n            # Mark these as visited\n            for hx, hy in np.argwhere(hole[0]):\n                visited[hx + x - 1, hy + y - 1] = True\n\n    return hole_count\n\n\ndef generate_input():\n    # Create a 15x15 black grid\n    grid_size = 15\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Create a guide object with a hole\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_object_size = np.random.randint(5, 10)\n    guide_object = np.full((guide_object_size, guide_object_size), guide_color)\n    \n    # Hollow out some interior to create holes\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, guide_object_size // 2)\n        hole_x, hole_y = np.random.randint(1, guide_object_size - hole_size), np.random.randint(1, guide_object_size - hole_size)\n        guide_object[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n    \n    # Place the guide object into the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, x, y)\n\n    return grid, guide_color, np.random.choice([4, 8])  # Include connectivity choice for variability", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity (4/8)\n\n# description:\n# Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# Use specified connectivity (4 or 8) to determine whether regions are enclosed. Output is the integer count of such holes.\n\ndef main(input_grid, guide_color=Color.RED, connectivity=4):\n    # Find the guide object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=connectivity, monochromatic=True)\n    guide_object = None\n    for obj in objects:\n        if np.any(obj == guide_color):\n            guide_object = obj\n            break\n\n    if guide_object is None:\n        return 0  # No guide object found\n\n    # Get the interior of the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n\n    # Identify enclosed regions (holes) within the guide object\n    holes_count = 0\n    for x, y in np.argwhere(interior_mask):\n        if input_grid[x, y] != guide_color:\n            # Check if this region is a hole using connectivity\n            region = find_connected_components(interior_mask & (input_grid != guide_color), background=False, connectivity=connectivity)\n            if any(np.any(region_obj) for region_obj in region):\n                holes_count += 1\n\n    return holes_count\n\ndef generate_input():\n    grid_size = np.random.randint(8, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Define guide color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random guide object\n    obj_size = np.random.randint(4, grid_size)\n    guide_object = random_sprite(obj_size, obj_size, color_palette=[guide_color], connectivity=8)\n\n    # Ensure there are enclosed regions\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    boundary_mask = object_boundary(guide_object, background=Color.BLACK)\n    hole_area = interior_mask & ~boundary_mask\n    guide_object[hole_area] = Color.BLACK\n\n    # Place the guide object randomly within the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n        blit_sprite(grid, guide_object, x, y)\n    except ValueError:\n        return generate_input()  # Retry if unable to place the guide object\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity (4/8)\n\n# description:\n# Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# Use specified connectivity (4 or 8) to determine whether regions are enclosed.\n# Output is the integer count of such holes.\n\ndef main(input_grid):\n    # Assume the guide object is the largest non-black connected component\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Get the interior of the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    \n    # Find the holes: regions within the guide object that are not of the guide object's color\n    guide_color = guide_object[guide_object != Color.BLACK][0]\n    hole_mask = (guide_object == Color.BLACK) & interior_mask\n    \n    # Find connected components in the hole mask to count the holes using the specified connectivity\n    hole_objects = find_connected_components(hole_mask, background=False, connectivity=8, monochromatic=False)\n    \n    # Count the number of distinct holes\n    num_holes = len(hole_objects)\n    \n    return num_holes\n\ndef generate_input():\n    # Create a grid with a single large guide object and random holes within it\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n    \n    # Create a guide object\n    guide_size = np.random.randint(5, n-2)\n    guide_object = np.full((guide_size, guide_size), Color.BLUE)\n    \n    # Carve out holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, guide_size // 2)\n        hole = random_sprite(hole_size, hole_size, color_palette=[Color.BLACK], background=Color.BLUE)\n        try:\n            x, y = random_free_location_for_sprite(guide_object, hole, padding=1, border_size=1, background=Color.BLUE)\n            blit_sprite(guide_object, hole, x, y)\n        except ValueError:\n            pass\n    \n    # Place the guide object into the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1, background=Color.BLACK)\n    blit_sprite(grid, guide_object, x, y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity (4/8)\n\n# description:\n# Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# Use specified connectivity (4 or 8) to determine whether regions are enclosed. \n# Output is the integer count of such holes.\n\ndef main(input_grid, guide_color=Color.BLUE, connectivity=4):\n    # Find the guide object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=connectivity)\n    \n    # Assuming there's only one guide object of the specified color\n    guide_object = None\n    for obj in objects:\n        if np.any(obj == guide_color):\n            guide_object = obj\n            break\n    \n    if guide_object is None:\n        return 0\n    \n    # Get the interior mask of the guide object\n    interior_mask = object_interior(guide_object)\n    \n    # Find regions within the guide object that are of background color\n    enclosed_regions = find_connected_components(guide_object, background=Color.BLACK, connectivity=connectivity, monochromatic=True)\n    \n    # Count the number of enclosed regions that are within the interior\n    hole_count = 0\n    for region in enclosed_regions:\n        if np.any(interior_mask & (region != Color.BLACK)):\n            hole_count += 1\n    \n    return hole_count\n\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n    \n    # Create a guide object\n    guide_size = np.random.randint(4, 8)\n    guide_object = np.full((guide_size, guide_size), Color.BLUE)\n    # Hollow out the interior of the guide object\n    guide_object[1:-1, 1:-1] = Color.BLACK\n    \n    try:\n        # Place the guide object in the grid\n        x, y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1)\n        blit_sprite(grid, guide_object, x, y)\n    except ValueError:\n        return generate_input()\n    \n    # Add random enclosed regions inside the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, guide_size - 2)\n        hole_sprite = random_sprite(hole_size, hole_size, color_palette=[Color.BLACK], background=Color.BLUE)\n        try:\n            # Ensure the hole is inside the guide object's interior\n            hole_x, hole_y = random_free_location_for_sprite(guide_object[1:-1, 1:-1], hole_sprite, padding=0)\n            blit_sprite(guide_object[1:-1, 1:-1], hole_sprite, hole_x, hole_y)\n        except ValueError:\n            continue\n    \n    # Update the grid with the modified guide object\n    blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity (4/8)\n\n# description:\n# Input consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# Use specified connectivity (4 or 8) to determine whether regions are enclosed.\n# Output is the integer count of such holes.\n\ndef main(input_grid):\n    # Identify the guide object color (assuming only one non-background color)\n    unique_colors = [color for color in np.unique(input_grid) if color != Color.BLACK]\n    assert len(unique_colors) == 1, \"Input should have exactly one guide object color.\"\n    guide_color = unique_colors[0]\n\n    # Find the guide object\n    guide_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    assert len(guide_objects) == 1, \"There should be exactly one guide object.\"\n    guide_object = guide_objects[0]\n\n    # Determine the interior of the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n\n    # Find all connected components within the guide object that are not the guide color\n    holes = find_connected_components(input_grid, background=guide_color, connectivity=4, monochromatic=True)\n    \n    # Count the number of holes fully enclosed within the guide object\n    hole_count = 0\n    for hole in holes:\n        if np.all(interior_mask[hole]):\n            hole_count += 1\n\n    return hole_count\n\n\ndef generate_input():\n    # Create a grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Select a random guide color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a guide object\n    guide_height, guide_width = np.random.randint(5, 8), np.random.randint(5, 8)\n    guide_object = np.full((guide_height, guide_width), guide_color)\n\n    # Create random holes inside the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, min(guide_height, guide_width) // 2)\n        hole = random_sprite(hole_size, hole_size, color_palette=[Color.BLACK], background=guide_color)\n        try:\n            hole_x, hole_y = random_free_location_for_sprite(guide_object, hole, border_size=1)\n            blit_sprite(guide_object, hole, hole_x, hole_y)\n        except ValueError:\n            continue\n\n    # Place the guide object on the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_object, border_size=1)\n        blit_sprite(grid, guide_object, x, y)\n    except ValueError:\n        return generate_input()  # Retry in case of placement failure\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole counting, enclosed regions, guide object, connectivity\n\n# description:\n# The input grid contains a single guide object of a specific color, which may enclose regions of the background color (e.g., 0).\n# Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color.\n# The connectivity (4 or 8) determines whether regions are enclosed. The output is the integer count of such holes.\n\ndef main(input_grid):\n    # Define the guide object's color.\n    guide_color = Color.BLUE\n\n    # Find the guide object.\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    guide_object = None\n    for obj in objects:\n        if np.any(obj == guide_color):\n            guide_object = obj\n            break\n\n    if guide_object is None:\n        return 0  # No guide object found, return 0 holes.\n\n    # Find interior of the guide object.\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n\n    # Identify background regions within the interior.\n    interior_background = (guide_object == Color.BLACK) & interior_mask\n\n    # Find connected components within the interior.\n    holes = find_connected_components(interior_background, background=0, connectivity=4, monochromatic=True)\n\n    # Return the count of enclosed background regions.\n    return len(holes)\n\n\ndef generate_input():\n    # Create a grid with a random size.\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Define the guide object's color.\n    guide_color = Color.BLUE\n\n    # Create a guide object (e.g., a rectangle) with a possible hole inside.\n    n, m = np.random.randint(5, grid_size - 2), np.random.randint(5, grid_size - 2)\n    guide_object = np.full((n, m), guide_color)\n\n    # Randomly decide how many holes to create inside the guide object.\n    num_holes = np.random.randint(1, 4)\n\n    for _ in range(num_holes):\n        # Create a small hole within the guide object.\n        hole_size = np.random.randint(1, min(n, m) // 2)\n        hole_x, hole_y = np.random.randint(1, n - hole_size), np.random.randint(1, m - hole_size)\n        guide_object[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Find a random location for the guide object in the grid.\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n        blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n    except ValueError:\n        return generate_input()  # Retry if no location found.\n\n    return grid"], "seeds": ["44d8ac46.py", "6e82a1ae.py", "00d62c1b.py", "810b9b61.py", "Concepts: \nhole counting, enclosed regions, guide object, connectivity (4/8)\n\nDescription: \nInput consists of a grid with a single guide object of a specific color, potentially enclosing regions of background color (e.g., 0). Count the number of enclosed regions (holes) within the guide object that are not of the guide object's color. Use specified connectivity (4 or 8) to determine whether regions are enclosed. Output is the integer count of such holes."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# Identify holes as background-color regions fully enclosed by a guide object, not connected to the grid border. Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole. Fill these holes with the target object color, ensuring they are completely enclosed by the guide object.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n\n    # Assume the background color is black\n    background_color = Color.BLACK\n\n    # Find all connected components of the background\n    background_components = find_connected_components(input_grid, background=background_color, connectivity=8)\n\n    # Mark exterior background by performing flood-fill from the grid border\n    exterior_background = set()\n    for x in range(input_grid.shape[0]):\n        for y in [0, input_grid.shape[1] - 1]:\n            if input_grid[x, y] == background_color:\n                exterior_background.add((x, y))\n    for y in range(input_grid.shape[1]):\n        for x in [0, input_grid.shape[0] - 1]:\n            if input_grid[x, y] == background_color:\n                exterior_background.add((x, y))\n\n    # Flood-fill on the exterior to mark all connected exterior background pixels\n    exterior_filled = set()\n    for start in exterior_background:\n        if start not in exterior_filled:\n            component = set()\n            stack = [start]\n            while stack:\n                x, y = stack.pop()\n                if (x, y) not in exterior_filled and input_grid[x, y] == background_color:\n                    exterior_filled.add((x, y))\n                    component.add((x, y))\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:\n                            stack.append((nx, ny))\n\n    # Fill the holes (background regions not connected to the exterior)\n    for component in background_components:\n        if not any((x, y) in exterior_filled for x, y in zip(*np.where(component))):\n            # If this background component is not connected to the exterior, it's a hole\n            target_color = determine_target_color(input_grid, component)\n            for x, y in zip(*np.where(component)):\n                output_grid[x, y] = target_color\n\n    return output_grid\n\ndef determine_target_color(grid, component):\n    \"\"\"\n    Determine the color to fill the hole with. Assume the color of the enclosing object.\n    \"\"\"\n    x, y = np.argwhere(component)[0]\n    neighbors = get_neighbors(grid, x, y)\n    for nx, ny in neighbors:\n        if grid[nx, ny] != Color.BLACK:\n            return grid[nx, ny]\n    return Color.BLACK\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:\n            neighbors.append((nx, ny))\n    return neighbors\n\ndef generate_input():\n    n = np.random.randint(10, 28)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    for _ in range(np.random.randint(3, 6)):\n        # Create a random colored object with a possible enclosed region\n        obj = random_sprite(np.random.randint(3, 7), np.random.randint(3, 7), color_palette=Color.NOT_BLACK)\n        interior_mask = object_interior(obj, background=Color.BLACK)\n        boundary_mask = object_boundary(obj, background=Color.BLACK)\n\n        # Make some of the interior black to create holes\n        for x, y in zip(*np.where(interior_mask)):\n            if np.random.rand() < 0.5:\n                obj[x, y] = Color.BLACK\n\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            continue\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# Identify holes as background-color regions fully enclosed by a guide object, not connected to the grid border. Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole. Fill these holes with the target object color, ensuring they are completely enclosed by the guide object.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = input_grid.copy()\n    \n    # Detect the background color (most common color connected to the border)\n    border_mask = np.zeros(input_grid.shape, dtype=bool)\n    border_mask[0, :] = border_mask[-1, :] = border_mask[:, 0] = border_mask[:, -1] = True\n    border_colors = input_grid[border_mask]\n    background_color = np.argmax(np.bincount(border_colors))\n    \n    # Perform flood fill from the border to mark exterior background\n    exterior_background = np.full(input_grid.shape, False)\n    flood_fill_from_border(input_grid, exterior_background, background_color)\n    \n    # Find all connected components of the background color\n    components = find_connected_components(input_grid, background=background_color, connectivity=4, monochromatic=True)\n    \n    # Identify components that are completely enclosed (not marked as exterior)\n    for component in components:\n        if not np.any(exterior_background[component]):\n            # This is a completely enclosed hole, fill it with the target object color\n            target_color = find_target_color_around(component, input_grid)\n            component[component == background_color] = target_color\n            blit_object(output_grid, component, background=background_color)\n\n    return output_grid\n\ndef flood_fill_from_border(grid, fill_mask, background_color):\n    from queue import Queue\n    q = Queue()\n    for x in range(grid.shape[0]):\n        for y in [0, grid.shape[1] - 1]:\n            if grid[x, y] == background_color and not fill_mask[x, y]:\n                q.put((x, y))\n                fill_mask[x, y] = True\n    for y in range(grid.shape[1]):\n        for x in [0, grid.shape[0] - 1]:\n            if grid[x, y] == background_color and not fill_mask[x, y]:\n                q.put((x, y))\n                fill_mask[x, y] = True\n    \n    while not q.empty():\n        x, y = q.get()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:\n                if grid[nx, ny] == background_color and not fill_mask[nx, ny]:\n                    fill_mask[nx, ny] = True\n                    q.put((nx, ny))\n\ndef find_target_color_around(component, grid):\n    # Check the colors surrounding the component and choose the most common non-background color\n    x, y = np.where(component)\n    candidate_colors = []\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        for xi, yi in zip(x, y):\n            nx, ny = xi + dx, yi + dy\n            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:\n                color = grid[nx, ny]\n                if color != Color.BLACK:\n                    candidate_colors.append(color)\n    return max(set(candidate_colors), key=candidate_colors.count)\n\n\ndef generate_input():\n    # Generate a grid of arbitrary size between 12x12 to 20x20\n    n = np.random.randint(12, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Define the background color\n    background_color = Color.BLACK\n\n    # Create guide objects with possible holes inside them\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        obj_w, obj_h = np.random.randint(4, n // 2), np.random.randint(4, n // 2)\n        obj = np.full((obj_w, obj_h), np.random.choice(list(Color.NOT_BLACK)))\n        interior = object_interior(obj, background=background_color)\n        boundary = object_boundary(obj, background=background_color)\n        interior[boundary] = False\n        obj[~interior] = background_color\n\n        # Randomly choose a location for the object within the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, background=background_color, border_size=1, padding=1)\n            blit_sprite(grid, obj, x, y, background=background_color)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# The input grid will have various objects on a background color. Some objects might enclose regions of the background color, which are not connected to the grid border.\n# The task is to identify these enclosed regions (holes) and fill them with the object's color, ensuring they are completely enclosed by the object's boundary.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify and return as the output grid\n    output_grid = input_grid.copy()\n\n    # Identify the background color as the most common color in the border of the grid\n    border_pixels = np.concatenate((input_grid[0], input_grid[-1], input_grid[:,0], input_grid[:,-1]))\n    background_color = np.argmax(np.bincount(border_pixels.flatten()))\n\n    # Find all connected components in the grid, considering only the background color\n    components = find_connected_components(input_grid, background=background_color, connectivity=4)\n\n    # Mark exterior background areas by flood-filling from the border\n    exterior_background = np.zeros_like(input_grid, dtype=bool)\n    flood_fill(exterior_background, input_grid, background_color)\n\n    # For each component, check if it is a hole (completely enclosed)\n    for component in components:\n        # Check if the component is not connected to the border\n        if not np.any(exterior_background[component != Color.BLACK]):\n            # Fill the hole with the color of the object enclosing it\n            enclosing_object_color = find_enclosing_object_color(input_grid, component)\n            component[component != Color.BLACK] = enclosing_object_color\n            blit_object(output_grid, component, background=Color.BLACK)\n\n    return output_grid\n\ndef flood_fill(filled_grid, input_grid, target_color):\n    # Flood fill from the grid's border, marking the exterior background\n    for x in range(input_grid.shape[0]):\n        if input_grid[x, 0] == target_color:\n            fill(filled_grid, input_grid, x, 0, target_color)\n        if input_grid[x, -1] == target_color:\n            fill(filled_grid, input_grid, x, input_grid.shape[1] - 1, target_color)\n    for y in range(input_grid.shape[1]):\n        if input_grid[0, y] == target_color:\n            fill(filled_grid, input_grid, 0, y, target_color)\n        if input_grid[-1, y] == target_color:\n            fill(filled_grid, input_grid, input_grid.shape[0] - 1, y, target_color)\n\ndef fill(filled_grid, input_grid, x, y, target_color):\n    stack = [(x, y)]\n    while stack:\n        cx, cy = stack.pop()\n        if 0 <= cx < input_grid.shape[0] and 0 <= cy < input_grid.shape[1] and input_grid[cx, cy] == target_color and not filled_grid[cx, cy]:\n            filled_grid[cx, cy] = True\n            stack.extend([(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)])\n\ndef find_enclosing_object_color(grid, component):\n    # Find the color of the object enclosing the hole (component)\n    x, y = np.argwhere(component != Color.BLACK)[0]\n    return grid[x, y]\n\ndef generate_input():\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n    \n    # Create random objects with enclosed holes\n    num_objects = np.random.randint(2, 5)\n    for _ in range(num_objects):\n        obj = create_random_object_with_holes()\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y)\n        except ValueError:\n            continue\n\n    return grid\n\ndef create_random_object_with_holes():\n    n, m = np.random.randint(5, 8), np.random.randint(5, 8)\n    obj_color = np.random.choice(list(Color.NOT_BLACK))\n    obj = np.full((n, m), obj_color)\n    obj[1:n-1, 1:m-1] = Color.BLACK  # Create a hole\n\n    # Randomly add internal holes\n    num_holes = np.random.randint(1, 3)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, min(n, m) // 2)\n        hole_x, hole_y = np.random.randint(1, n - hole_size), np.random.randint(1, m - hole_size)\n        obj[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    return obj", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# The input grid contains a guide object formed by a closed shape (e.g., a rectangle or circle) and a background color. \n# The task is to identify holes, which are regions of the background color that are completely enclosed by the guide object and do not touch any grid borders.\n# Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole.\n# The output should be the input grid, but with these holes filled with the color of the guide object.\n\ndef main(input_grid):\n    # Make a copy of the grid to avoid modifying the input directly\n    output_grid = input_grid.copy()\n\n    # Identify the background color as the most frequent color in the grid\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    \n    # Identify the guide object's color by finding the most frequent non-background color\n    guide_color = max(Color.NOT_BLACK, key=lambda x: np.count_nonzero(input_grid == x))\n\n    # Flood-fill from the border to mark the exterior background\n    border_mask = np.full(input_grid.shape, False)\n    border_mask[0, :] = border_mask[-1, :] = border_mask[:, 0] = border_mask[:, -1] = True\n    flood_fill(input_grid, border_mask, background_color)\n\n    # Find the regions that are still background color; these are potential holes\n    potential_holes = (input_grid == background_color)\n\n    # Fill these holes with the guide object's color\n    output_grid[potential_holes] = guide_color\n\n    return output_grid\n\ndef flood_fill(grid, mask, target_color):\n    \"\"\"\n    Perform flood-fill from the border using a queue-based implementation.\n    This will mark all connected components of the target_color that are connected to the border.\n    \"\"\"\n    q = list(zip(*np.where(mask & (grid == target_color))))\n    while q:\n        x, y = q.pop(0)\n        grid[x, y] = -1  # Mark as visited with a temporary color\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1] and grid[nx, ny] == target_color:\n                q.append((nx, ny))\n\ndef generate_input():\n    # Create a grid of random size between 15x15 and 25x25 with a black background\n    n = np.random.randint(15, 26)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate a random guide object (e.g., a rectangle) with a random non-black color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    rect_height = np.random.randint(5, n-4)\n    rect_width = np.random.randint(5, n-4)\n    rect_x = np.random.randint(1, n-rect_height-1)\n    rect_y = np.random.randint(1, n-rect_width-1)\n    \n    grid[rect_x:rect_x+rect_height, rect_y:rect_y+rect_width] = guide_color\n    grid[rect_x+1:rect_x+rect_height-1, rect_y+1:rect_y+rect_width-1] = Color.BLACK\n\n    # Introduce random holes within the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_height = np.random.randint(1, rect_height-2)\n        hole_width = np.random.randint(1, rect_width-2)\n        hole_x = np.random.randint(rect_x+1, rect_x+rect_height-hole_height-1)\n        hole_y = np.random.randint(rect_y+1, rect_y+rect_width-hole_width-1)\n        grid[hole_x:hole_x+hole_height, hole_y:hole_y+hole_width] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# In the input grid, you will see various objects of different colors. These objects may enclose regions of the background color.\n# The task is to identify regions of background color that are fully enclosed by a single object and not connected to the grid border.\n# Fill these \"hole\" regions with the object's color to produce the output.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    background_color = Color.BLACK  # Assuming BLACK is the background\n\n    # Use flood fill from the edges to mark exterior background\n    flooded_grid = input_grid.copy()\n    for x in range(flooded_grid.shape[0]):\n        if flooded_grid[x, 0] == background_color:\n            flood_fill(flooded_grid, x, 0, background_color, -1)\n        if flooded_grid[x, flooded_grid.shape[1] - 1] == background_color:\n            flood_fill(flooded_grid, x, flooded_grid.shape[1] - 1, background_color, -1)\n    for y in range(flooded_grid.shape[1]):\n        if flooded_grid[0, y] == background_color:\n            flood_fill(flooded_grid, 0, y, background_color, -1)\n        if flooded_grid[flooded_grid.shape[0] - 1, y] == background_color:\n            flood_fill(flooded_grid, flooded_grid.shape[0] - 1, y, background_color, -1)\n\n    # Find connected components in the original grid\n    objects = find_connected_components(input_grid, background=background_color, connectivity=8)\n\n    for obj in objects:\n        # Check for interior background regions (holes)\n        interior_mask = object_interior(obj)\n        hole_mask = (flooded_grid == background_color) & interior_mask\n\n        # Fill holes with object's color\n        if np.any(hole_mask):\n            obj_color = obj[np.where(obj != background_color)][0]\n            output_grid[hole_mask] = obj_color\n\n    return output_grid\n\n\ndef flood_fill(grid, x, y, target_color, replacement_color):\n    \"\"\"Simple flood fill algorithm to mark the exterior background.\"\"\"\n    if grid[x, y] != target_color:\n        return\n    grid[x, y] = replacement_color\n    if x > 0:\n        flood_fill(grid, x - 1, y, target_color, replacement_color)\n    if x < grid.shape[0] - 1:\n        flood_fill(grid, x + 1, y, target_color, replacement_color)\n    if y > 0:\n        flood_fill(grid, x, y - 1, target_color, replacement_color)\n    if y < grid.shape[1] - 1:\n        flood_fill(grid, x, y + 1, target_color, replacement_color)\n\n\ndef generate_input():\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    num_objects = np.random.randint(2, 5)\n\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        n, m = np.random.randint(4, 6), np.random.randint(4, 6)\n        obj = np.full((n, m), obj_color)\n\n        # Create a hollow object by making a hole inside\n        hole_size = np.random.randint(1, min(n, m) - 2)\n        hole_x, hole_y = np.random.randint(1, n - hole_size), np.random.randint(1, m - hole_size)\n        obj[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            continue\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# In the input grid, there are objects drawn with a guide color, enclosing some regions that might be holes. \n# The task is to identify holes as regions of the background color that are completely enclosed by the guide color and not connected to the grid border.\n# Fill these holes with the color of the enclosing guide object.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = input_grid.copy()\n    \n    # Find all the connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n    \n    # Go through each object and check for holes\n    for obj in objects:\n        interior_mask = object_interior(obj)\n        guide_mask = obj != Color.BLACK\n        \n        # Find the color of the guide object\n        guide_color = np.unique(obj[guide_mask])[0]\n        \n        # Determine the holes by finding regions inside the object that are background and enclosed\n        hole_mask = interior_mask & ~guide_mask\n        if np.any(hole_mask):\n            # Fill these holes with the guide color\n            obj[hole_mask] = guide_color\n        \n        # Blit the processed object back to the output grid\n        blit_object(output_grid, obj, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with random size between 10x10 and 20x20\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n    \n    # Define a guide color different from the background\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create random enclosed regions with potential holes\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        # Define size and shape of the object\n        rows, cols = np.random.randint(3, 7), np.random.randint(3, 7)\n        obj = np.full((rows, cols), guide_color)\n        \n        # Carve out a hole by setting some interior pixels to background\n        if np.random.rand() > 0.5:\n            hole_size = np.random.randint(1, min(rows, cols) - 1)\n            hole_x, hole_y = np.random.randint(1, rows - hole_size), np.random.randint(1, cols - hole_size)\n            obj[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n        \n        # Find a random location to place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x, y)\n        except ValueError:\n            continue\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# The input grid contains various colored objects on a black background. Some objects are hollow, containing fully enclosed black regions not connected to the grid border.\n# To produce the output, identify these enclosed black regions and fill them with the color of their enclosing object.\n\ndef main(input_grid):\n    # Create initial output grid copy\n    output_grid = input_grid.copy()\n\n    # Identify the exterior region of the grid using flood fill from the border\n    exterior_mask = np.zeros_like(input_grid, dtype=bool)\n    exterior_color = Color.BLACK\n    for i in range(input_grid.shape[0]):\n        if input_grid[i, 0] == exterior_color:\n            flood_fill(exterior_mask, input_grid, i, 0, exterior_color)\n        if input_grid[i, -1] == exterior_color:\n            flood_fill(exterior_mask, input_grid, i, input_grid.shape[1] - 1, exterior_color)\n    for j in range(input_grid.shape[1]):\n        if input_grid[0, j] == exterior_color:\n            flood_fill(exterior_mask, input_grid, 0, j, exterior_color)\n        if input_grid[-1, j] == exterior_color:\n            flood_fill(exterior_mask, input_grid, input_grid.shape[0] - 1, j, exterior_color)\n\n    # Find connected components of objects\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n\n    # Fill holes for each object\n    for obj in objects:\n        # Determine the color of the object\n        object_color = max(set(np.unique(obj)) - {Color.BLACK}, key=lambda x: np.sum(obj == x))\n\n        # Find the interior of the object, excluding the boundary\n        interior_mask = object_interior(obj, background=Color.BLACK)\n        boundary_mask = object_boundary(obj, background=Color.BLACK)\n        interior_excluding_boundary = interior_mask & ~boundary_mask\n\n        # Identify enclosed regions (holes) within the object\n        holes = interior_excluding_boundary & ~exterior_mask\n\n        # Fill the holes with the color of the object\n        output_grid[holes] = object_color\n\n    return output_grid\n\ndef flood_fill(mask, grid, x, y, color):\n    \"\"\"Flood fill algorithm to mark the exterior region.\"\"\"\n    if x < 0 or x >= grid.shape[0] or y < 0 or y >= grid.shape[1] or mask[x, y] or grid[x, y] != color:\n        return\n    mask[x, y] = True\n    flood_fill(mask, grid, x + 1, y, color)\n    flood_fill(mask, grid, x - 1, y, color)\n    flood_fill(mask, grid, x, y + 1, color)\n    flood_fill(mask, grid, x, y - 1, color)\n\ndef generate_input():\n    # Create a grid with random size\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate random objects with potential enclosed regions\n    num_objects = np.random.randint(2, 5)\n    for _ in range(num_objects):\n        obj_size = np.random.randint(3, 6)\n        obj = np.full((obj_size, obj_size), np.random.choice(list(Color.NOT_BLACK)))\n        # Create a hole in the object\n        hole_size = np.random.randint(1, obj_size - 1)\n        hole_start = np.random.randint(1, obj_size - hole_size)\n        obj[hole_start:hole_start + hole_size, hole_start:hole_start + hole_size] = Color.BLACK\n\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# Identify holes as background-color regions fully enclosed by a guide object, not connected to the grid border.\n# Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole.\n# Fill these holes with the target object color, ensuring they are completely enclosed by the guide object.\n\ndef main(input_grid):\n    # Determine the background color (most common color)\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    \n    # Create a copy of the input grid for output\n    output_grid = input_grid.copy()\n    \n    # Flood-fill the background from the border to mark exterior background\n    exterior_background = np.zeros_like(input_grid, dtype=bool)\n    h, w = input_grid.shape\n    \n    # Check borders and flood-fill\n    for x in range(w):\n        if input_grid[0, x] == background_color:\n            fill_exterior_background(input_grid, exterior_background, 0, x, background_color)\n        if input_grid[h-1, x] == background_color:\n            fill_exterior_background(input_grid, exterior_background, h-1, x, background_color)\n    \n    for y in range(h):\n        if input_grid[y, 0] == background_color:\n            fill_exterior_background(input_grid, exterior_background, y, 0, background_color)\n        if input_grid[y, w-1] == background_color:\n            fill_exterior_background(input_grid, exterior_background, y, w-1, background_color)\n    \n    # Find holes (background regions not marked as exterior)\n    holes = (input_grid == background_color) & ~exterior_background\n    \n    # Fill holes with the target color\n    target_color = Color.RED  # For instance, filling holes with red\n    output_grid[holes] = target_color\n    \n    return output_grid\n\ndef fill_exterior_background(grid, exterior_background, start_y, start_x, background_color):\n    \"\"\"Flood-fill to mark exterior background\"\"\"\n    h, w = grid.shape\n    stack = [(start_y, start_x)]\n    \n    while stack:\n        y, x = stack.pop()\n        \n        if exterior_background[y, x]:\n            continue\n        \n        exterior_background[y, x] = True\n        \n        # Explore neighbors (4-connectivity)\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ny, nx = y + dy, x + dx\n            if 0 <= ny < h and 0 <= nx < w and not exterior_background[ny, nx] and grid[ny, nx] == background_color:\n                stack.append((ny, nx))\n\ndef generate_input():\n    # Create a grid of random size\n    n = np.random.randint(15, 20)\n    grid = np.full((n, n), Color.BLACK)\n    \n    # Choose background and object colors\n    background_color = np.random.choice(list(Color.NOT_BLACK))\n    object_color = np.random.choice([c for c in Color.NOT_BLACK if c != background_color])\n    \n    # Set the entire grid to the background color\n    grid.fill(background_color)\n    \n    # Create a guide object with at least one hole\n    obj_size = np.random.randint(5, 10)\n    obj = np.full((obj_size, obj_size), object_color)\n    \n    # Create a hole by setting a central region to background color\n    hole_size = np.random.randint(1, obj_size - 2)\n    hole_x = np.random.randint(1, obj_size - hole_size - 1)\n    hole_y = np.random.randint(1, obj_size - hole_size - 1)\n    obj[hole_y:hole_y+hole_size, hole_x:hole_x+hole_size] = background_color\n    \n    # Place the object in the grid\n    x, y = random_free_location_for_sprite(grid, obj, background=background_color)\n    blit_sprite(grid, obj, x, y, background=background_color)\n    \n    # Randomly add a few more objects with or without holes\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        obj = np.full((obj_size, obj_size), object_color)\n        if np.random.rand() > 0.5:\n            hole_size = np.random.randint(1, obj_size - 2)\n            hole_x = np.random.randint(1, obj_size - hole_size - 1)\n            hole_y = np.random.randint(1, obj_size - hole_size - 1)\n            obj[hole_y:hole_y+hole_size, hole_x:hole_x+hole_size] = background_color\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, obj, background=background_color)\n            blit_sprite(grid, obj, x, y, background=background_color)\n        except ValueError:\n            # If there is no space for the object, skip\n            continue\n    \n    return grid"], "seeds": ["810b9b61.py", "44d8ac46.py", "00d62c1b.py", "264363fd_Kevin.py", "Concepts: \nholes, enclosed regions, flood fill, background detection\n\nDescription: \nIdentify holes as background-color regions fully enclosed by a guide object, not connected to the grid border. Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole. Fill these holes with the target object color, ensuring they are completely enclosed by the guide object."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# Input consists of a grid with various colored pixels and a designated guide object. Count the number of pixels within the guide object that have either odd or even color values.\n# If a specific color or set of colors is provided, restrict the count to those colors only; otherwise, consider all colors present in the guide object.\n# The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_grid: np.ndarray, guide_object: np.ndarray, parity: str, specific_colors: Optional[Set[str]] = None) -> int:\n    # Ensure parity is valid\n    if parity not in [\"odd\", \"even\"]:\n        raise ValueError(\"Parity must be 'odd' or 'even'.\")\n\n    # Extract the dimensions of the guide object\n    guide_x, guide_y, guide_w, guide_h = bounding_box(guide_object)\n\n    # Initialize count\n    count = 0\n\n    # Iterate over each pixel within the guide object\n    for i in range(guide_x, guide_x + guide_w):\n        for j in range(guide_y, guide_y + guide_h):\n            pixel_color = input_grid[i, j]\n            \n            # Check if the pixel is within the specified colors, if provided\n            if specific_colors is None or pixel_color in specific_colors:\n                color_index = list(Color.ALL_COLORS).index(pixel_color)\n                \n                # Check parity condition\n                if (parity == \"odd\" and color_index % 2 != 0) or (parity == \"even\" and color_index % 2 == 0):\n                    count += 1\n\n    return count\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray, str, Optional[Set[str]]]:\n    # Create a grid with random colored pixels\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter points of different colors\n    for color in Color.NOT_BLACK:\n        randomly_scatter_points(grid, color=color, density=0.1)\n\n    # Create a guide object as a random sprite\n    guide_sprite = random_sprite(n=3, m=3, color_palette=Color.NOT_BLACK)\n    \n    # Find a location for the guide object\n    x, y = random_free_location_for_sprite(grid, guide_sprite)\n    blit_sprite(grid, guide_sprite, x, y)\n    \n    # Choose a random parity condition\n    parity = np.random.choice([\"odd\", \"even\"])\n\n    # Randomly decide to restrict count to a specific set of colors or not\n    restrict_colors = np.random.choice([True, False])\n    specific_colors = set(np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(1, 4), replace=False)) if restrict_colors else None\n\n    return grid, guide_sprite, parity, specific_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# Input consists of a grid with various colored pixels and a designated guide object.\n# Count the number of pixels within the guide object that have either odd or even color values.\n# If a specific color or set of colors is provided, restrict the count to those colors only;\n# otherwise, consider all colors present in the guide object.\n# The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_grid: np.ndarray, guide_color: str, parity: str, restricted_colors: Optional[Set[str]] = None) -> int:\n    # Find the guide object in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    guide_object = next(obj for obj in objects if np.any(obj == guide_color))\n\n    # Get the bounding box of the guide object\n    x, y, width, height = bounding_box(guide_object)\n\n    # Count pixels with the specified parity within the guide object\n    count = 0\n    for i in range(x, x + width):\n        for j in range(y, y + height):\n            if guide_object[i, j] != Color.BLACK:\n                if restricted_colors is None or guide_object[i, j] in restricted_colors:\n                    if parity == 'odd' and int(guide_object[i, j]) % 2 == 1:\n                        count += 1\n                    elif parity == 'even' and int(guide_object[i, j]) % 2 == 0:\n                        count += 1\n\n    return count\n\ndef generate_input() -> Tuple[np.ndarray, str, str, Optional[Set[str]]]:\n    # Create a grid with random colored pixels\n    n, m = 10, 10\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n\n    # Generate a random guide object\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_sprite = random_sprite(n=3, m=3, density=0.7, color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Choose parity condition: odd or even\n    parity = np.random.choice(['odd', 'even'])\n\n    # Randomly choose whether to restrict colors or not\n    if np.random.rand() > 0.5:\n        restricted_colors = set(np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(1, 4), replace=False))\n    else:\n        restricted_colors = None\n\n    return grid, guide_color, parity, restricted_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# In the input you will see a grid with colored pixels and a designated guide object.\n# The guide object is a randomly generated sprite in a specific color.\n# Count the number of pixels inside the guide object that have either odd or even color values.\n# If a specific color or set of colors is provided, restrict the count to those colors only; otherwise, consider all colors present in the guide object.\n# The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_data):\n    input_grid, guide_object_color, parity, restricted_colors = input_data\n    \n    # Identify the guide object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    guide_object = next(obj for obj in objects if np.any(obj == guide_object_color))\n    \n    # Get the bounding box of the guide object\n    x, y, width, height = bounding_box(guide_object, background=Color.BLACK)\n    \n    # Count the pixels within the guide object according to the rules\n    restricted_colors = restricted_colors or Color.NOT_BLACK  # if no restriction, consider all colors\n    pixel_count = 0\n    \n    for i in range(x, x + width):\n        for j in range(y, y + height):\n            if input_grid[i, j] in restricted_colors:\n                color_index = list(Color.NOT_BLACK).index(input_grid[i, j])\n                if (color_index % 2 == 0 and parity == 'even') or (color_index % 2 != 0 and parity == 'odd'):\n                    pixel_count += 1\n\n    # Output is a 1x1 grid with the count as its single pixel\n    output_grid = np.full((1, 1), pixel_count)\n    \n    return output_grid\n\ndef generate_input():\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter random colors on the grid\n    randomly_scatter_points(grid, color=random.choice(list(Color.NOT_BLACK)), density=0.4, background=Color.BLACK)\n    \n    # Generate a guide object sprite in a specific color\n    guide_object_color = random.choice(list(Color.NOT_BLACK))\n    sprite = random_sprite(n=3, m=3, color_palette=[guide_object_color], density=0.6)\n    \n    # Place the guide object on the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, sprite, x, y)\n    \n    # Decide on parity and optional restricted color set\n    parity = random.choice(['odd', 'even'])\n    restricted_colors = random.sample(list(Color.NOT_BLACK), k=random.randint(0, 5))  # Up to 5 colors can be restricted\n    \n    return grid, guide_object_color, parity, restricted_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# The input consists of a grid with various colored pixels and a designated guide object.\n# Count the number of pixels within the guide object that have either odd or even color values.\n# If a specific color or set of colors is provided, restrict the count to those colors only;\n# otherwise, consider all colors present in the guide object.\n# The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_grid: np.ndarray, guide_object: np.ndarray, parity: str, color_restriction: Set[str] = None) -> np.ndarray:\n    # Initialize the count of pixels matching the parity condition\n    count = 0\n    \n    # Determine which colors to consider based on the color restriction\n    if color_restriction is None:\n        relevant_colors = np.unique(input_grid[guide_object])\n    else:\n        relevant_colors = color_restriction\n\n    # Iterate over each pixel in the guide object\n    for x in range(guide_object.shape[0]):\n        for y in range(guide_object.shape[1]):\n            if guide_object[x, y]:\n                color = input_grid[x, y]\n                if color in relevant_colors:\n                    # Check the parity condition\n                    color_value = ord(color[-1])  # Assume color is a string like \"Color.RED\"\n                    if (parity == 'odd' and color_value % 2 == 1) or (parity == 'even' and color_value % 2 == 0):\n                        count += 1\n    \n    # Output the result as a 1x1 grid with the count\n    output_grid = np.array([[count]])\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray, str, Set[str]]:\n    # Create a random grid with colored pixels\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly scatter some points with colors\n    for color in Color.NOT_BLACK:\n        randomly_scatter_points(grid, color=color, density=np.random.uniform(0.1, 0.3))\n\n    # Create a guide object as a random connected component\n    guide_object = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=[Color.GREY], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, guide_object)\n    blit_sprite(grid, guide_object, x, y)\n    \n    # Define parity condition and color restriction\n    parity = np.random.choice(['odd', 'even'])\n    color_restriction = set(np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(1, 3), replace=False))\n\n    return grid, guide_object, parity, color_restriction", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# In the input, you will see a grid with various colored pixels and a designated guide object (a specific color).\n# Count the number of pixels within the guide object that have either odd or even color values.\n# If a specific color or set of colors is provided, restrict the count to those colors only; otherwise, consider all colors present in the guide object.\n# The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_grid: np.ndarray, guide_color: Color, parity: str = \"even\", restricted_colors: Set[Color] = None) -> int:\n    # Identify the guide object by finding the connected component of the guide color\n    guide_objects = find_connected_components(input_grid, background=~guide_color, monochromatic=True)\n    guide_object = guide_objects[0]  # Assuming a single guide object for simplicity\n\n    # Determine which colors to consider\n    if restricted_colors is None:\n        colors_to_consider = set(np.unique(guide_object)) - {Color.BLACK, guide_color}\n    else:\n        colors_to_consider = restricted_colors\n\n    # Count pixels within the guide object that satisfy the parity condition\n    count = 0\n    for color in colors_to_consider:\n        color_pixels = np.sum(guide_object == color)\n        if (parity == \"even\" and color_pixels % 2 == 0) or (parity == \"odd\" and color_pixels % 2 != 0):\n            count += color_pixels\n\n    return count\n\ndef generate_input() -> Tuple[np.ndarray, Color, str, Set[Color]]:\n    # Create a grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter random colors on the grid\n    for color in Color.NOT_BLACK:\n        randomly_scatter_points(grid, color=color, density=0.1)\n\n    # Generate a guide object\n    guide_object_color = random.choice(list(Color.NOT_BLACK))\n    guide_object = random_sprite(n=3, m=3, color_palette=[guide_object_color], background=Color.BLACK)\n    \n    # Place the guide object randomly on the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_object, padding=1, padding_connectivity=8)\n        blit_sprite(grid, guide_object, x=x, y=y)\n    except ValueError:\n        pass\n\n    # Randomly choose the parity condition\n    parity = random.choice([\"even\", \"odd\"])\n\n    # Randomly choose if the count should be restricted to certain colors\n    if np.random.rand() < 0.5:\n        restricted_colors = set(random.sample(list(Color.NOT_BLACK), k=np.random.randint(1, 4)))\n    else:\n        restricted_colors = None\n\n    return grid, guide_object_color, parity, restricted_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# Input consists of a grid with various colored pixels and a designated guide object. Count the number of pixels within the guide object\n# that have either odd or even color values. If a specific color or set of colors is provided, restrict the count to those colors only;\n# otherwise, consider all colors present in the guide object. The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_grid: np.ndarray, guide_object_color: str, parity_condition: str, restricted_colors: Optional[Set[str]] = None) -> int:\n    # Find the guide object within the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n    guide_object = next((obj for obj in objects if np.any(obj == guide_object_color)), None)\n\n    # Determine which colors to consider for counting\n    if restricted_colors:\n        colors_to_consider = restricted_colors\n    else:\n        colors_to_consider = set(np.unique(guide_object)) - {Color.BLACK, guide_object_color}\n\n    # Count the number of pixels within the guide object that match the parity condition\n    count = 0\n    for color in colors_to_consider:\n        if parity_condition == 'odd':\n            if int(color) % 2 != 0:\n                count += np.sum(guide_object == color)\n        elif parity_condition == 'even':\n            if int(color) % 2 == 0:\n                count += np.sum(guide_object == color)\n\n    return count\n\ndef generate_input() -> Tuple[np.ndarray, str, str, Optional[Set[str]]]:\n    # Create a black grid with random dimensions between 10 and 15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a guide object color from the available colors\n    guide_object_color = random.choice(Color.NOT_BLACK)\n\n    # Generate a guide object sprite and place it on the grid\n    sprite = random_sprite(n=[2, 3, 4], m=[2, 3, 4], color_palette=[guide_object_color])\n    x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n    blit_sprite(grid, sprite, x=x, y=y)\n\n    # Scatter random colors around the grid\n    for color in Color.NOT_BLACK:\n        if color != guide_object_color:\n            randomly_scatter_points(grid, color, density=0.2)\n\n    # Randomly choose a parity condition\n    parity_condition = random.choice(['odd', 'even'])\n\n    # Decide whether to use restricted colors or not\n    use_restricted_colors = random.choice([True, False])\n    restricted_colors = set(random.sample(Color.NOT_BLACK, k=random.randint(1, 3))) if use_restricted_colors else None\n\n    return grid, guide_object_color, parity_condition, restricted_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# The input consists of a grid with various colored pixels and a designated guide object.\n# The task is to count the number of pixels within the guide object that have either odd or even color values.\n# If a specific color or set of colors is provided, restrict the count to those colors only; otherwise, consider all colors present in the guide object.\n# The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_grid: np.ndarray, guide_object: np.ndarray, parity: str = \"even\", restricted_colors: List[str] = None) -> int:\n    assert parity in [\"even\", \"odd\"], \"Parity must be 'even' or 'odd'.\"\n    \n    # Flatten the guide object to obtain all relevant positions within the grid\n    guide_positions = np.argwhere(guide_object != Color.BLACK)\n    \n    # Count the pixels based on the defined parity and restricted colors\n    count = 0\n    for x, y in guide_positions:\n        pixel_color = input_grid[x, y]\n        \n        # Check if the color is within the restricted set, if provided\n        if restricted_colors is None or pixel_color in restricted_colors:\n            # Convert the color to an integer value (for parity check)\n            color_value = list(Color.NOT_BLACK).index(pixel_color)\n            \n            # Check parity condition\n            if parity == \"even\" and color_value % 2 == 0:\n                count += 1\n            elif parity == \"odd\" and color_value % 2 != 0:\n                count += 1\n    \n    return count\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray, str, List[str]]:\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.random.choice(list(Color.NOT_BLACK), (n, m))\n    \n    guide_object_size = np.random.randint(2, 4)\n    guide_object = random_sprite(n=guide_object_size, m=guide_object_size, \n                                 color_palette=[Color.BLACK, Color.GREY], density=0.5)\n    \n    # Place guide object randomly within the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK)\n    blit_sprite(grid, guide_object, x, y)\n    \n    # Randomly choose parity and restricted colors\n    parity = np.random.choice([\"even\", \"odd\"])\n    if np.random.rand() > 0.5:\n        restricted_colors = list(np.random.choice(list(Color.NOT_BLACK), np.random.randint(1, 4), replace=False))\n    else:\n        restricted_colors = None\n    \n    return grid, guide_object, parity, restricted_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# parity counting, guide object, color restriction\n\n# description:\n# Input consists of a grid with various colored pixels and a designated guide object. \n# Count the number of pixels within the guide object that have either odd or even color values.\n# If a specific color or set of colors is provided, restrict the count to those colors only; \n# otherwise, consider all colors present in the guide object. \n# The output is the total count of pixels satisfying the chosen parity condition.\n\ndef main(input_grid, guide_object, parity='odd', restricted_colors=None):\n    # Extract the bounding box of the guide object\n    x, y, width, height = bounding_box(guide_object)\n    \n    # Initialize the count of pixels satisfying the parity condition\n    count = 0\n    \n    # Traverse through the guide object's bounding box\n    for i in range(x, x + width):\n        for j in range(y, y + height):\n            pixel_color = input_grid[i, j]\n            if pixel_color == Color.BLACK:\n                continue\n            \n            # Check if the color is restricted or not\n            if restricted_colors is None or pixel_color in restricted_colors:\n                color_value = list(Color.NOT_BLACK).index(pixel_color)\n                if (parity == 'odd' and color_value % 2 == 1) or (parity == 'even' and color_value % 2 == 0):\n                    count += 1\n    \n    return count\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Scatter various colored pixels randomly\n    for color in Color.NOT_BLACK:\n        randomly_scatter_points(grid, color=color, density=0.1)\n    \n    # Generate a random guide object (sprite)\n    guide_object = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), color_palette=[Color.GREY])\n    \n    # Place the guide object randomly on the grid\n    x, y = random_free_location_for_sprite(grid, guide_object)\n    blit_sprite(grid, guide_object, x, y)\n\n    # Randomly decide if a restricted color set is used\n    restricted_colors = None\n    if np.random.rand() > 0.5:\n        restricted_colors = random.sample(Color.NOT_BLACK, k=np.random.randint(1, 5))\n    \n    # Randomly select a parity condition\n    parity = np.random.choice(['odd', 'even'])\n    \n    return grid, guide_object, parity, restricted_colors"], "seeds": ["6e82a1ae.py", "31aa019c.py", "44f52bb0.py", "6cdd2623.py", "Concepts: \nparity counting, guide object, color restriction\n\nDescription: \nInput consists of a grid with various colored pixels and a designated guide object. Count the number of pixels within the guide object that have either odd or even color values. If a specific color or set of colors is provided, restrict the count to those colors only; otherwise, consider all colors present in the guide object. The output is the total count of pixels satisfying the chosen parity condition."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# In the input, you will see a grid with various colored objects scattered on a black background. \n# One of these objects is designated as the \"guide object\" and is distinguished by having a unique color not shared by any other objects.\n# To generate the output, first determine the guide object's bounding box. \n# Then create a new grid where the dimensions are based on the bounding box of the guide object, initialized to black (background color).\n# The output grid should be independent of the input's specific content but adhere to the defined shape derived from the guide object's bounding box.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the guide object by detecting the object with the unique color.\n    # 2. Calculate the bounding box of the guide object.\n    # 3. Create an output grid with the dimensions of this bounding box, initialized to black.\n\n    # Step 1: Identify the guide object\n    # Find all colors in the grid except black\n    unique_colors = set(np.unique(input_grid)) - {Color.BLACK}\n    # Assume the guide object is the one with the unique color\n    color_counts = {color: np.sum(input_grid == color) for color in unique_colors}\n    guide_color = min(color_counts, key=color_counts.get)\n\n    # Step 2: Detect the guide object and calculate its bounding box\n    guide_object = detect_objects(input_grid, colors=[guide_color], monochromatic=True)[0]\n    guide_bounding_box = crop(guide_object, background=Color.BLACK)\n\n    # Step 3: Create an output grid with the dimensions of the bounding box, initialized to black\n    output_grid = np.full(guide_bounding_box.shape, Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random objects\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create several random objects\n    num_objects = np.random.randint(3, 6)\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n\n    for i in range(num_objects):\n        # Randomly determine the size of the object\n        obj_height, obj_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        sprite = random_sprite(obj_height, obj_width, color_palette=[colors.pop()])\n\n        # Place the object at a random location in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y)\n\n    # Designate one of the objects as the \"guide object\" with a unique color\n    guide_color = colors.pop() if colors else np.random.choice(list(Color.NOT_BLACK - set(colors)))\n    guide_sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# In the input grid, you will see a single guide object of a random color, floating on a black grid. \n# The guide object can be any random shape, but its bounding box will be used to determine the output grid's dimensions.\n# To make the output, create a grid with dimensions matching the bounding box of the guide object and initialize it with zero (Color.BLACK).\n\ndef main(input_grid):\n    # Extract the guide object from the grid\n    guide_object = detect_objects(input_grid, background=Color.BLACK, monochromatic=True, connectivity=8)\n    \n    # Ensure there's only one guide object\n    assert len(guide_object) == 1, \"There should be exactly one guide object in the input grid.\"\n    \n    # Crop the guide object to get its bounding box\n    cropped_object = crop(guide_object[0], background=Color.BLACK)\n    \n    # Get the dimensions of the bounding box\n    bbox_height, bbox_width = cropped_object.shape\n    \n    # Create a new grid with the dimensions of the bounding box, initialized to zero\n    output_grid = np.full((bbox_height, bbox_width), Color.BLACK, dtype=int)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size between 15x15 and 25x25\n    n = np.random.randint(15, 26)\n    m = np.random.randint(15, 26)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Generate a random guide object with dimensions between 3x3 and 8x8, and a random color\n    guide_height = np.random.randint(3, 9)\n    guide_width = np.random.randint(3, 9)\n    color = np.random.choice(Color.NOT_BLACK)\n    guide_object = random_sprite(guide_height, guide_width, color_palette=[color], connectivity=8)\n    \n    # Place the guide object at a random location on the grid\n    x, y = random_free_location_for_sprite(grid, guide_object)\n    blit_sprite(grid, guide_object, x, y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# The input grid contains a colorful pattern with some guide object(s). Each guide object is a distinct color and has a bounding box.\n# The transformation involves determining the output grid's shape based on a specified rule: either a fixed size or derived from a guide object's bounding box.\n# Allocate a new grid with the calculated dimensions, initialized to zero (background color).\n# The output grid's dimensions are independent of the input's specific content but adhere to the defined shape rule.\n\ndef main(input_grid):\n    # 1. Detect guide objects (assumed monochromatic and not black)\n    guide_objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=True)\n    \n    # 2. Calculate the bounding box for the largest guide object\n    largest_object = max(guide_objects, key=lambda obj: np.prod(obj.shape))\n    bounding_box = crop(largest_object, background=Color.BLACK).shape\n    \n    # 3. Determine the output grid's shape based on the largest bounding box\n    output_shape = (bounding_box[0] + 2, bounding_box[1] + 2)  # Add padding around the bounding box\n    \n    # 4. Create a zero-initialized output grid with the calculated dimensions\n    output_grid = np.full(output_shape, Color.BLACK, dtype=int)\n    \n    return output_grid\n\ndef generate_input():\n    # 1. Create a random grid size\n    n, m = np.random.randint(15, 25, size=2)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # 2. Create random guide objects with distinct colors\n    num_objects = np.random.randint(2, 5)\n    for _ in range(num_objects):\n        w, h = np.random.randint(3, 7, size=2)\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(w, h, color_palette=[color], monochromatic=True, connectivity=4)\n        \n        # 3. Place the guide object on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no location is found, skip the object\n            continue\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# The input is a grid containing one or more colored objects. The output grid's dimensions are determined by a specified rule: \n# either a fixed size or derived from the bounding box of a specified guide object. In this case, the guide object is the largest colored object in the grid.\n# The output is initialized to zero (background color), and the dimensions adhere to the defined shape rule.\n\ndef main(input_grid):\n    # Step 1: Identify the largest object in the grid to use as the guide object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Sort objects by size and choose the largest one as the guide\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Step 2: Determine the bounding box of the guide object\n    guide_bounding_box = crop(largest_object, background=Color.BLACK)\n    \n    # Step 3: Calculate the dimensions of the output grid based on the guide object\n    output_shape = guide_bounding_box.shape\n    \n    # Step 4: Create a new grid with the calculated dimensions, initialized to zero (background color)\n    output_grid = np.full(output_shape, Color.BLACK, dtype=int)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid with multiple objects\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate a random number of objects (2-5)\n    num_objects = np.random.randint(2, 6)\n\n    for _ in range(num_objects):\n        # Create random sprites with dimensions between 2-5\n        w = np.random.randint(2, 6)\n        h = np.random.randint(2, 6)\n        sprite = random_sprite(w, h, color_palette=[np.random.choice(Color.NOT_BLACK)])\n        \n        # Blit each sprite onto a random location on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, sprite, x, y)\n        except:\n            continue  # If no space is found, skip this sprite\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# In the input, you may see a grid with several colored shapes scattered throughout. The task is to output a new grid\n# that is either of a fixed size or derived from the bounding box of the largest object detected in the input grid.\n# The output grid is initialized with the background color (black), and contains no content from the input grid.\n\ndef main(input_grid):\n    # Determine if we are using a fixed size or derived from an object\n    use_fixed_size = np.random.choice([True, False])\n\n    if use_fixed_size:\n        # Fixed size output grid\n        output_shape = (10, 10)  # Example fixed size\n    else:\n        # Determine bounding box from the largest object\n        objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=False)\n        if objects:\n            # Find the largest object by area\n            largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n            # Determine the bounding box of this object\n            sprite = crop(largest_object, background=Color.BLACK)\n            output_shape = sprite.shape\n        else:\n            # Default to a fixed size if no objects are found\n            output_shape = (5, 5)\n\n    # Create the output grid\n    output_grid = np.full(output_shape, Color.BLACK, dtype=int)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid with several colored shapes\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a few random sprites and place them in the grid\n    num_sprites = np.random.randint(1, 5)\n    for _ in range(num_sprites):\n        w = np.random.randint(2, 6)\n        h = np.random.randint(2, 6)\n        sprite = random_sprite(w, h, color_palette=[np.random.choice(Color.NOT_BLACK)])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If placement fails, skip this sprite\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# In the input, you will see a grid with a single colored object surrounded by a black background. \n# The output grid's dimensions are determined by either a fixed size of 10x10 or derived from the smallest bounding box that can contain the guide object, \n# whichever is larger. Initialize the output grid with a zero (black) background color. The output grid's dimensions are independent of the input content but adhere to the defined shape rule.\n\ndef main(input_grid):\n    # Step 1: Detect objects in the input grid\n    objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=True, connectivity=4)\n    \n    # Assuming there's only one object, use the first one as the guide object\n    guide_object = objects[0]\n    \n    # Step 2: Determine the bounding box dimensions of the guide object\n    guide_bounding_box = crop(guide_object, background=Color.BLACK)\n    bounding_box_dimensions = guide_bounding_box.shape\n    \n    # Step 3: Determine the output grid's shape based on the fixed size or the bounding box size\n    fixed_size = (10, 10)\n    output_shape = (\n        max(fixed_size[0], bounding_box_dimensions[0]),\n        max(fixed_size[1], bounding_box_dimensions[1])\n    )\n    \n    # Step 4: Initialize the output grid with zero (black) background color\n    output_grid = np.full(output_shape, Color.BLACK, dtype=int)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid size between 15x15 and 20x20\n    n = np.random.randint(15, 21)\n    m = np.random.randint(15, 21)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Create a random colored sprite with a size between 4x4 and 8x8\n    sprite_size = np.random.randint(4, 9, size=2)\n    sprite = random_sprite(sprite_size[0], sprite_size[1], color_palette=[np.random.choice(Color.NOT_BLACK)])\n    \n    # Blit the sprite onto a random location in the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# In the input grid, you will see multiple colored objects on a black background. One object is marked with a unique color that no other object has. This is the guide object.\n# To make the output, determine the bounding box of this guide object. The output grid should match the dimensions of this bounding box and be initialized with a black background.\n# Copy the guide object into this output grid at its corresponding position.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the guide object based on its unique color.\n    # 2. Determine the bounding box of the guide object.\n    # 3. Create an output grid with dimensions equal to the bounding box, initialized with black.\n    # 4. Place the guide object into this output grid.\n\n    # Step 1: Identify the guide object\n    unique_colors = set(np.unique(input_grid)) - {Color.BLACK}\n    color_counts = {color: np.sum(input_grid == color) for color in unique_colors}\n    guide_color = min(color_counts, key=color_counts.get)\n    \n    # Step 2: Determine the bounding box of the guide object\n    guide_object = np.where(input_grid == guide_color, guide_color, Color.BLACK)\n    bounding_box = crop(guide_object, background=Color.BLACK)\n    bounding_box_shape = bounding_box.shape\n    \n    # Step 3: Create an output grid with dimensions equal to the bounding box\n    output_grid = np.full(bounding_box_shape, Color.BLACK, dtype=int)\n    \n    # Step 4: Copy the guide object into this output grid\n    output_grid = bounding_box\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with several colored objects\n    n, m = np.random.randint(15, 20, size=2)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate random objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(Color.NOT_BLACK)\n        obj_width, obj_height = np.random.randint(2, 5, size=2)\n        sprite = random_sprite(obj_width, obj_height, color_palette=[obj_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If there's no space, skip this object\n            continue\n\n    # Generate the guide object with a unique color\n    guide_color = np.random.choice(list(set(Color.NOT_BLACK) - set(np.unique(grid))))\n    guide_width, guide_height = np.random.randint(3, 6, size=2)\n    guide_sprite = random_sprite(guide_width, guide_height, color_palette=[guide_color])\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_sprite, padding=1)\n        blit_sprite(grid, guide_sprite, x, y)\n    except ValueError:\n        pass # If there's no space, the function will retry\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# output grid shape, guide object, bounding box, zero-initialized grid\n\n# description:\n# In the input, you will see a grid with several randomly placed colored objects (sprites).\n# The task is to create an output grid, the size of which is determined by either:\n# a) A fixed size, for example, 10x10, or \n# b) The bounding box of a \"guide\" object from the input.\n# The output grid is initialized to zeros (background color), and its dimensions are independent of the specific content of the input grid.\n\ndef main(input_grid):\n    # Step 1: Decide the rule for determining the output grid's size\n    # Rule a: Fixed size\n    fixed_size = (10, 10)\n\n    # Rule b: Size based on a guide object's bounding box\n    # For this example, let's assume the guide object is the largest object in terms of area in the input grid.\n    objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=True)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))  # Largest object by area\n    \n    # Determine the bounding box of the guide object\n    guide_bounding_box = crop(guide_object, background=Color.BLACK)\n    guide_size = guide_bounding_box.shape\n\n    # Choose which rule to apply for the output size\n    rule = np.random.choice(['fixed', 'guide'])\n\n    if rule == 'fixed':\n        output_size = fixed_size\n    else:\n        output_size = guide_size\n\n    # Step 2: Create the output grid with the determined size, initialized to zero (background color)\n    output_grid = np.full(output_size, Color.BLACK, dtype=int)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with several objects\n    n = np.random.randint(12, 20)\n    m = np.random.randint(12, 20)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate a few random sprites\n    num_sprites = np.random.randint(3, 6)\n    for _ in range(num_sprites):\n        w = np.random.randint(2, 6)\n        h = np.random.randint(2, 6)\n        sprite = random_sprite(w, h, color_palette=[np.random.choice(Color.NOT_BLACK)])\n        \n        # Place the sprite on the grid at a random location\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no location can be found, continue to the next sprite\n            continue\n\n    return grid"], "seeds": ["1cf80156.py", "a8c38be5.py", "5c2c9af4.py", "137eaa0f.py", "Concepts: \noutput grid shape, guide object, bounding box, zero-initialized grid\n\nDescription: \nDetermine the output grid's shape based on a specified rule: either a fixed size or derived from a guide object's bounding box. Allocate a new grid with the calculated dimensions, initialized to zero (background color). The output grid's dimensions are independent of the input's specific content but adhere to the defined shape rule."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# The input grid contains multiple colored objects. One object is a unique guide object, identified by being the only object with a specific color.\n# Use the top-left corner of the guide object as the anchor point. From this point onward, count the number of fully enclosed black regions (holes).\n# The output is the count of these holes originating from the guide's position.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Determine which color is the unique color\n    color_counts = {}\n    for obj in objects:\n        unique_colors = np.unique(obj[obj != Color.BLACK])\n        for color in unique_colors:\n            color_counts[color] = color_counts.get(color, 0) + 1\n\n    guide_color = next(color for color, count in color_counts.items() if count == 1)\n\n    # Identify the guide object\n    guide_object = next(obj for obj in objects if np.any(obj == guide_color))\n\n    # Use the top-left corner of the guide object as the anchor point\n    anchor_x, anchor_y = object_position(guide_object, background=Color.BLACK, anchor='upper left')\n\n    # Count the number of fully enclosed black regions (holes) starting from the anchor point\n    # We consider holes as enclosed black regions surrounded by non-black pixels\n    grid_from_anchor = input_grid[anchor_x:, anchor_y:]\n    holes = find_connected_components(grid_from_anchor, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    hole_count = 0\n    for hole in holes:\n        # A hole is valid if it's enclosed; hence, its interior should be empty\n        if is_hole(hole):\n            hole_count += 1\n\n    return hole_count\n\ndef is_hole(obj):\n    # Check if the object is a hole by verifying if its interior is empty\n    interior_mask = object_interior(obj)\n    return np.any(interior_mask & (obj == Color.BLACK))\n\ndef generate_input():\n    # Create a grid of size between 12x12 and 20x20\n    n = np.random.randint(12, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Randomly select a unique guide color\n    guide_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create several objects with random colors\n    num_objects = np.random.randint(5, 10)\n    colors = np.random.choice([color for color in Color.NOT_BLACK if color != guide_color], num_objects - 1, replace=False)\n\n    # Insert the guide object\n    guide_obj = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_obj, padding=1)\n    blit_sprite(grid, guide_obj, x, y)\n\n    # Insert other objects\n    for color in colors:\n        obj = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y)\n        except ValueError:\n            pass\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# In the input grid, identify a unique guide object based on a distinct attribute (e.g., color or size).\n# Use the guide's anchor point, such as its centroid or top-left corner, as the starting point.\n# From this anchor, count the number of enclosed regions (holes) in the grid.\n# The output is a count of these holes, originating from the guide's position.\n\ndef main(input_grid):\n    # find the guide object based on a unique color\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # assume the guide is the object with a unique color\n    guide_object = None\n    for obj in objects:\n        unique_colors = np.unique(obj[obj != Color.BLACK])\n        if len(unique_colors) == 1:\n            guide_object = obj\n            break\n\n    if guide_object is None:\n        return 0  # no guide object found\n\n    # determine the anchor point of the guide object\n    anchor_x, anchor_y = object_position(guide_object, background=Color.BLACK, anchor=\"upper left\")\n\n    # count the number of enclosed regions (holes) from the anchor point\n    # find all connected components excluding the guide object\n    holes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # count enclosed regions\n    hole_count = 0\n    for hole in holes:\n        if is_enclosed(hole, guide_object):\n            hole_count += 1\n\n    return hole_count\n\ndef is_enclosed(hole, guide_object):\n    # simple check to see if the hole is fully enclosed by the guide object\n    guide_mask = guide_object != Color.BLACK\n    hole_mask = hole != Color.BLACK\n    return np.all(guide_mask[hole_mask])\n\ndef generate_input():\n    n = m = 20\n    grid = np.full((n, m), Color.BLACK)\n\n    # create a guide object with a unique color\n    guide_color = Color.RED\n    guide_sprite = random_sprite(3, 3, color_palette=[guide_color], background=Color.BLACK)\n    x, y = random_free_location_for_sprite(grid, guide_sprite, padding=1)\n    blit_sprite(grid, guide_sprite, x, y)\n    \n    # create random enclosed regions (holes)\n    num_holes = np.random.randint(1, 5)\n    for _ in range(num_holes):\n        hole_sprite = random_sprite(np.random.randint(1, 3), np.random.randint(1, 3), color_palette=[Color.BLACK], background=Color.BLACK)\n        hole_x, hole_y = random_free_location_for_sprite(grid, hole_sprite, border_size=1)\n        blit_sprite(grid, hole_sprite, hole_x, hole_y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# The input grid consists of various colored objects on a black background. Identify the unique guide object based on a distinct attribute (e.g., color or size).\n# Use the guide's anchor point (e.g., centroid or top-left corner) as the starting point. From this anchor, count the number of enclosed regions (holes) in the grid.\n# The output is a count of these holes originating from the guide's position.\n\ndef main(input_grid):\n    # Identify all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Determine the unique guide object based on a distinct attribute\n    # For simplicity, let's assume the guide object is the largest object by size\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Find the anchor point of the guide object\n    anchor_x, anchor_y = object_position(guide_object, background=Color.BLACK, anchor='center')\n\n    # Count the holes originating from the guide's position\n    # A hole is defined as a fully enclosed black region\n    enclosed_holes = 0\n    guide_interior = object_interior(guide_object, background=Color.BLACK)\n\n    # Iterate over the grid to count enclosed black regions starting from the guide's anchor point\n    def is_hole(x, y):\n        # Use flood fill algorithm to determine if a region is a hole\n        if guide_interior[x, y] or input_grid[x, y] != Color.BLACK:\n            return False\n        flood_fill = np.zeros_like(input_grid, dtype=bool)\n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            if flood_fill[cx, cy] or guide_interior[cx, cy] or input_grid[cx, cy] != Color.BLACK:\n                continue\n            flood_fill[cx, cy] = True\n            for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]:\n                if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:\n                    stack.append((nx, ny))\n        # If flood fill reached any point outside the guide object, it's not a hole\n        return not np.any(flood_fill & ~guide_interior)\n\n    # Check for holes around the anchor point\n    for dx in [-1, 1]:\n        for dy in [-1, 1]:\n            if is_hole(anchor_x + dx, anchor_y + dy):\n                enclosed_holes += 1\n\n    return enclosed_holes\n\ndef generate_input():\n    # Create a grid with a random number of objects\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        color = np.random.choice(list(Color.NOT_BLACK))\n        width, height = np.random.randint(2, 5, size=2)\n        sprite = random_sprite(width, height, color_palette=[color], background=Color.BLACK, symmetry=\"not_symmetric\")\n\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# The input grid contains multiple colored objects on a black background. One of these objects is uniquely colored (guide object).\n# Use this guide object's centroid as an anchor point. From this anchor, count the number of fully enclosed black regions (holes) within the grid.\n# The output is a grid with the count of holes displayed at the location of the guide object's centroid.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Identify the unique guide object based on color\n    guide_object = None\n    guide_color = None\n    color_count = {}\n    \n    for obj in objects:\n        colors = np.unique(obj[obj != Color.BLACK])\n        if len(colors) == 1:\n            color = colors[0]\n            if color in color_count:\n                color_count[color] += 1\n            else:\n                color_count[color] = 1\n    \n    # Find the unique color\n    for color, count in color_count.items():\n        if count == 1:\n            guide_color = color\n            break\n    \n    # Find the guide object with the unique color\n    for obj in objects:\n        if np.any(obj == guide_color):\n            guide_object = obj\n            break\n    \n    # Get the centroid of the guide object\n    centroid_x, centroid_y = object_position(guide_object, anchor='center')\n    \n    # Count the number of enclosed regions (holes) in the grid\n    hole_count = 0\n    interiors = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    \n    for interior in interiors:\n        if np.any(interior == Color.BLACK) and not np.any(interior == guide_color):\n            hole_count += 1\n    \n    # Prepare the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Mark the hole count at the centroid of the guide object\n    output_grid[centroid_x, centroid_y] = hole_count\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a random-sized grid between 10x10 and 20x20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose colors for objects\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n\n    # Place one unique colored guide object\n    guide_color = colors.pop()\n    guide_object = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1)\n    blit_sprite(grid, guide_object, x, y)\n    \n    # Place other objects with different colors\n    for color in colors:\n        num_objects = np.random.randint(1, 3)\n        for _ in range(num_objects):\n            object_sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[color])\n            try:\n                x, y = random_free_location_for_sprite(grid, object_sprite, padding=1, border_size=1)\n                blit_sprite(grid, object_sprite, x, y)\n            except ValueError:\n                pass\n    \n    # Add random holes in the grid\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 4)\n        hole_sprite = np.full((hole_size, hole_size), Color.BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, hole_sprite, padding=1, border_size=1)\n            blit_sprite(grid, hole_sprite, x, y)\n        except ValueError:\n            pass\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# The input is a grid with various colored objects. One object is distinctly larger than the others and serves as the guide.\n# The task is to identify this guide object, use its top-left corner as the anchor point, and count the number of fully enclosed black regions (holes) in the grid.\n# The output is a grid where the guide object is highlighted in red and the number of holes is displayed in the top-left corner of the grid.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Identify the guide object based on size\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Get the position of the guide object's top-left corner\n    guide_x, guide_y = object_position(guide_object, background=Color.BLACK, anchor='upper left')\n    \n    # Count the number of fully enclosed regions (holes) in the grid\n    # An enclosed region is a connected component of black pixels surrounded by non-black pixels\n    hole_count = 0\n    for obj in objects:\n        # Check if the object is a hole (fully enclosed black region)\n        if np.all(obj[obj != Color.BLACK] != Color.BLACK):\n            hole_count += 1\n    \n    # Create the output grid\n    output_grid = input_grid.copy()\n    \n    # Highlight the guide object in red\n    guide_mask = guide_object != Color.BLACK\n    output_grid[guide_mask] = Color.RED\n    \n    # Display the number of holes in the top-left corner\n    output_grid[0, 0] = hole_count\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate guide object with a unique size (larger than other objects)\n    guide_object_size = np.random.randint(4, 6)\n    guide_object = random_sprite(guide_object_size, guide_object_size, color_palette=[Color.TEAL], background=Color.BLACK)\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1)\n    blit_sprite(grid, guide_object, x, y)\n    \n    # Generate other smaller objects (distractors)\n    num_distractors = np.random.randint(3, 6)\n    for _ in range(num_distractors):\n        distractor_size = np.random.randint(2, 3)\n        distractor = random_sprite(distractor_size, distractor_size, color_palette=[Color.BLUE])\n        try:\n            x, y = random_free_location_for_sprite(grid, distractor, padding=1, border_size=1)\n            blit_sprite(grid, distractor, x, y)\n        except ValueError:\n            pass\n    \n    # Add enclosed black regions (holes)\n    num_holes = np.random.randint(1, 3)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, 3)\n        hole = random_sprite(hole_size, hole_size, color_palette=[Color.BLACK], background=Color.BLACK)\n        x, y = random_free_location_for_sprite(grid, hole, padding=1, border_size=1)\n        blit_sprite(grid, hole, x, y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# In the input, you will see various colored objects on a black background. \n# One of these objects is a \"guide object\", identifiable by its distinct color or size.\n# Use the guide's anchor point (e.g., center) as the starting point.\n# From this anchor, count how many enclosed regions (holes) exist in the grid.\n# The output will be a grid with a single number representing this count.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n\n    # Identify the guide object based on a distinct attribute (we'll use color here for uniqueness)\n    colors = [np.unique(obj[obj != Color.BLACK]) for obj in objects]\n    unique_colors = [color for color in Color.ALL_COLORS if colors.count(color) == 1]\n    \n    # Assume the guide object is the one with a unique color\n    guide_object = None\n    for obj in objects:\n        obj_color = np.unique(obj[obj != Color.BLACK])\n        if obj_color in unique_colors:\n            guide_object = obj\n            break\n\n    if guide_object is None:\n        raise ValueError(\"No guide object found\")\n\n    # Use the guide's anchor point (center) as the starting position\n    anchor_x, anchor_y = object_position(guide_object, background=Color.BLACK, anchor='center')\n\n    # Count the number of enclosed regions (holes) in the grid starting from the anchor point\n    # We will consider holes as black regions fully enclosed by colored regions\n    interior = object_interior(input_grid, background=Color.BLACK)\n    hole_count = 0\n\n    # Check for holes\n    for y in range(interior.shape[0]):\n        for x in range(interior.shape[1]):\n            if interior[y, x] and input_grid[y, x] == Color.BLACK:\n                # If the pixel is part of an enclosed black region, count it as a hole\n                hole_count += 1\n\n    # Create an output grid to display the hole count\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid[anchor_y, anchor_x] = hole_count\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid with objects of various colors\n    n, m = np.random.randint(12, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create some objects, one of which has a unique color\n    num_objects = np.random.randint(3, 6)\n    used_colors = set()\n\n    for _ in range(num_objects):\n        # Generate a random color not used before\n        color = np.random.choice([c for c in Color.NOT_BLACK if c not in used_colors])\n        used_colors.add(color)\n\n        # Create a random object with the chosen color\n        obj_height, obj_width = np.random.randint(3, 5, size=2)\n        obj = random_sprite(obj_height, obj_width, color_palette=[color], background=Color.BLACK)\n        \n        # Place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# In the input grid, there is a uniquely colored guide object. The task is to identify this guide object, find its anchor point, \n# and then count the number of enclosed regions (holes) in the grid from this anchor point. The output should display the count of these holes.\n\ndef main(input_grid):\n    # Step 1: Identify the guide object\n    # Assume the guide object is uniquely colored. Find the color that appears in only one object.\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    # Determine the unique color for the guide object\n    color_count = {}\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n    \n    guide_color = next(color for color, count in color_count.items() if count == 1)\n    guide_object = next(obj for obj in objects if np.any(obj == guide_color))\n\n    # Step 2: Determine the anchor point of the guide object\n    anchor_x, anchor_y = object_position(guide_object, background=Color.BLACK, anchor=\"center\")\n\n    # Step 3: Count the number of enclosed regions (holes) in the grid\n    # We will consider enclosed black regions that are not part of the background\n    hole_count = 0\n    for obj in objects:\n        if np.all(obj == Color.BLACK):\n            interior_mask = object_interior(obj, background=Color.BLACK)\n            if np.any(interior_mask):\n                hole_count += 1\n\n    # Step 4: Output the count of holes\n    # Create an output grid and place the count in a specific location, e.g., at the top-left corner\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid[0, 0] = hole_count  # Place the count in the top-left corner\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with various objects and exactly one uniquely colored guide object\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Add random objects to the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=list(Color.NOT_BLACK))\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n        blit_sprite(grid, sprite, x, y)\n\n    # Add a uniquely colored guide object\n    unique_color = np.random.choice([c for c in Color.NOT_BLACK if not np.any(grid == c)])\n    guide_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[unique_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, padding=1, border_size=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, unique selection, anchor point, hole counting\n\n# description:\n# In the input grid, you will see various colored objects. Identify a unique guide object based on a distinct attribute, such as a specific color or size.\n# Use the guide's anchor point (e.g., its centroid or top-left corner) as the starting point. From this anchor, count the number of enclosed regions (holes) in the grid.\n# The output is a count of these holes, originating from the guide's position.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Select a guide object based on a unique attribute (e.g., the largest object)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Determine the anchor point of the guide object (e.g., the centroid)\n    x, y = object_position(guide_object, background=Color.BLACK, anchor=\"center\")\n\n    # Identify and count enclosed regions (holes) in the grid\n    hole_count = 0\n    for obj in objects:\n        if is_hollow(obj):\n            hole_count += 1\n\n    return hole_count\n\n\ndef is_hollow(object):\n    # Check if the object contains a fully enclosed region\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    hollow_mask = interior_mask & ~object_mask\n    return np.any(hollow_mask)\n\n\ndef generate_input():\n    n, m = 12, 12\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create random objects with distinct attributes\n    num_objects = np.random.randint(3, 6)\n    unique_color = np.random.choice(list(Color.NOT_BLACK - {Color.GREY}))\n\n    for _ in range(num_objects):\n        obj_size = np.random.randint(3, 5)\n        obj_color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(obj_size, obj_size, color_palette=[obj_color], background=Color.BLACK)\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            pass\n\n    # Add a unique guide object with a distinct attribute\n    guide_size = np.random.randint(4, 6)\n    guide_sprite = random_sprite(guide_size, guide_size, color_palette=[unique_color], background=Color.BLACK)\n    \n    try:\n        x, y = random_free_location_for_sprite(grid, guide_sprite, padding=1)\n        blit_sprite(grid, guide_sprite, x, y, background=Color.BLACK)\n    except ValueError:\n        pass\n\n    return grid"], "seeds": ["6e82a1ae.py", "810b9b61.py", "228f6490.py", "44d8ac46.py", "Concepts: \nguide object, unique selection, anchor point, hole counting\n\nDescription: \nIdentify a unique guide object based on a distinct attribute (e.g., color or size). Use the guide's anchor point, such as its centroid or top-left corner, as the starting point. From this anchor, count the number of enclosed regions (holes) in the grid. The output is a count of these holes, originating from the guide's position."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid.\n# A hole is a region of background (0) pixels completely surrounded by non-background pixels. The guide object's color is propagated\n# to fill these holes, ensuring all other non-hole areas remain unchanged.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Create output grid starting as a copy of the input\n    output_grid = input_grid.copy()\n    \n    # Identify the guide object by its unique color\n    guide_color = None\n    for obj in objects:\n        colors = object_colors(obj, background=Color.BLACK)\n        if len(colors) == 1:\n            guide_color = colors[0]\n            break\n    \n    # If no guide color is found, return the grid unchanged\n    if guide_color is None:\n        return output_grid\n    \n    # Find all holes in the grid\n    interior_mask = object_interior(input_grid, background=Color.BLACK)\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n    holes_mask = interior_mask & ~boundary_mask & (input_grid == Color.BLACK)\n\n    # Fill the holes with the guide color\n    output_grid[holes_mask] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Generate a random guide color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create a guide object with a unique color\n    guide_width, guide_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    guide_object = np.full((guide_width, guide_height), guide_color)\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y)\n    \n    # Create random enclosed shapes to form potential holes\n    num_shapes = np.random.randint(1, 4)\n    for _ in range(num_shapes):\n        shape_width, shape_height = np.random.randint(3, 8), np.random.randint(3, 8)\n        shape = random_sprite(shape_width, shape_height, color_palette=[Color.BLACK, np.random.choice(list(Color.NOT_BLACK))], background=Color.BLACK)\n        shape_x, shape_y = random_free_location_for_sprite(grid, shape, padding=1, border_size=1)\n        blit_sprite(grid, shape, shape_x, shape_y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# The input grid contains a unique guide object marked by a specific color. This object serves as a reference for filling all enclosed regions (holes) within the grid.\n# A hole is defined as a region of background (BLACK) pixels completely surrounded by non-background pixels.\n# The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged.\n\ndef main(input_grid):\n    # Step 1: Identify the guide object by its unique color\n    objects = detect_objects(input_grid, monochromatic=True, connectivity=4)\n    guide_color = None\n    for obj in objects:\n        colors = object_colors(obj, background=Color.BLACK)\n        if len(colors) == 1:\n            guide_color = colors[0]\n            break\n\n    if guide_color is None:\n        raise ValueError(\"No unique guide object found.\")\n\n    # Step 2: Create an output grid to store the result\n    output_grid = input_grid.copy()\n\n    # Step 3: Find all holes in the grid\n    interior_mask = object_interior(input_grid, background=Color.BLACK)\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n    hole_mask = interior_mask & ~boundary_mask\n\n    # Step 4: Fill the holes using the guide object's color\n    for x, y in np.argwhere(hole_mask):\n        if output_grid[x, y] == Color.BLACK:\n            output_grid[x, y] = guide_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a randomly sized grid with black background\n    size = np.random.randint(10, 20)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Add random shapes with random colors to create enclosed regions\n    num_shapes = np.random.randint(3, 5)\n    for _ in range(num_shapes):\n        shape = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=Color.NOT_BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, padding=1)\n            blit_sprite(grid, shape, x, y)\n        except ValueError:\n            continue\n\n    # Add a guide object with a unique color\n    guide_color = np.random.choice([color for color in Color.NOT_BLACK])\n    guide_object = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[guide_color])\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n        blit_sprite(grid, guide_object, x, y)\n    except ValueError:\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid.\n# A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels. The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged.\n\ndef main(input_grid):\n    # Identify the guide object by its unique color\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    guide_color = object_colors(guide_object, background=Color.BLACK)[0]\n\n    # Create an output grid to store the result\n    output_grid = input_grid.copy()\n\n    # Find all holes in the grid\n    interior_mask = object_interior(input_grid, background=Color.BLACK)\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n    holes_mask = interior_mask & ~boundary_mask\n\n    # Fill the holes with the guide object's color\n    for x, y in np.argwhere(holes_mask):\n        if input_grid[x, y] == Color.BLACK:\n            output_grid[x, y] = guide_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size\n    size = np.random.randint(10, 20)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Add random objects of different colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n        color = np.random.choice([color for color in Color.NOT_BLACK])\n\n        sprite = random_sprite(width, height, color_palette=[color], connectivity=8, background=Color.BLACK)\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Select one object to be the guide object and ensure it fully encloses a hole\n    guide_object = random_sprite(4, 4, color_palette=[Color.TEAL], connectivity=8, background=Color.BLACK)\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1, background=Color.BLACK)\n    blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    # Create a hole inside the guide object\n    hole_x, hole_y = x + 1, y + 1\n    grid[hole_x:hole_x+2, hole_y:hole_y+2] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid. \n# A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels. \n# The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged.\n\ndef main(input_grid):\n    # Find the guide object by searching for a unique color in the grid\n    colors_in_grid = [color for color in Color.NOT_BLACK if np.any(input_grid == color)]\n    guide_color = None\n    for color in colors_in_grid:\n        if np.sum(input_grid == color) == 1:\n            guide_color = color\n            break\n\n    assert guide_color is not None, \"No unique guide color found in the grid\"\n\n    # Create an output grid initialized as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Find all holes in the grid\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=True)\n\n    for obj in objects:\n        # Check if object is a hole (completely surrounded by non-background pixels)\n        if is_hole(obj, input_grid):\n            # Fill the hole with the guide color\n            hole_mask = (obj == Color.BLACK)\n            obj[hole_mask] = guide_color\n            blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef is_hole(obj, grid):\n    # Ensure the object is completely surrounded by non-background pixels\n    # Get the bounding box of the object\n    x, y, width, height = bounding_box(obj)\n    # Check the surrounding pixels\n    surrounding_mask = grid[x-1:x+width+1, y-1:y+height+1] != Color.BLACK\n    return np.all(surrounding_mask)\n\ndef generate_input():\n    # Define grid size\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Randomly generate some objects in the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj_width = np.random.randint(2, 5)\n        obj_height = np.random.randint(2, 5)\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = np.full((obj_width, obj_height), obj_color)\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    # Add a unique colored guide object\n    guide_color = np.random.choice([color for color in Color.NOT_BLACK if color not in grid])\n    guide_x, guide_y = np.random.randint(0, n), np.random.randint(0, n)\n    grid[guide_x, guide_y] = guide_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid. \n# A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels. \n# The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged.\n\ndef main(input_grid):\n    # Step 1: Detect objects in the grid that are not the background\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Step 2: Identify the guide object (should be the one with a unique color)\n    guide_color = None\n    for obj in objects:\n        colors = object_colors(obj, background=Color.BLACK)\n        if len(colors) == 1:\n            guide_color = colors[0]\n            break\n\n    # Create an output grid to store the result\n    output_grid = input_grid.copy()\n\n    if guide_color is None:\n        return output_grid  # No unique guide object found\n\n    # Step 3: Fill the holes with the guide object's color\n    for obj in objects:\n        if guide_color not in object_colors(obj, background=Color.BLACK):\n            continue\n\n        # Find holes inside the object\n        interior_mask = object_interior(obj, background=Color.BLACK)\n        boundary_mask = object_boundary(obj, background=Color.BLACK)\n        hole_mask = interior_mask & ~boundary_mask & (obj == Color.BLACK)\n\n        # Fill the holes with the guide object's color\n        output_grid[hole_mask] = guide_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with random size\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Add random objects to the grid\n    n_objects = np.random.randint(3, 5)\n\n    # Ensure one object has a unique color (the guide object)\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n\n    for i in range(n_objects):\n        color = guide_color if i == 0 else np.random.choice(list(Color.NOT_BLACK - {guide_color}))\n        obj_width, obj_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        obj = random_sprite(obj_width, obj_height, color_palette=[color], background=Color.BLACK)\n        interior_mask = object_interior(obj, background=Color.BLACK)\n        boundary_mask = object_boundary(obj, background=Color.BLACK)\n        hole_mask = interior_mask & ~boundary_mask\n        obj[hole_mask] = Color.BLACK  # Create a hole inside the object\n\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=1, border_size=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no location found, skip adding this object\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# The input grid contains various colored objects and a unique guide object identifiable by its distinct color. \n# The task is to fill all the completely enclosed regions (holes) within the grid with the guide object's color. \n# A hole is defined as a region of background (black) pixels that is surrounded entirely by non-background pixels.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Determine the guide object by its unique color\n    guide_object = max(objects, key=lambda obj: len(object_colors(obj, background=Color.BLACK)))\n    guide_color = object_colors(guide_object, background=Color.BLACK)[0]\n\n    # Create output grid copy\n    output_grid = input_grid.copy()\n\n    # Identify holes and fill them with the guide color\n    for obj in objects:\n        # Skip the guide object itself\n        if guide_color in object_colors(obj, background=Color.BLACK):\n            continue\n        \n        # Find the interior of the object\n        interior_mask = object_interior(obj)\n\n        # Fill the hole if it is entirely enclosed\n        if np.any(interior_mask & (input_grid == Color.BLACK)):\n            output_grid[interior_mask & (input_grid == Color.BLACK)] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate random objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=list(Color.NOT_BLACK), connectivity=8)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    # Add the guide object with a unique color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_obj = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[guide_color], connectivity=8)\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_obj, background=Color.BLACK, padding=1)\n        blit_sprite(grid, guide_obj, x, y, background=Color.BLACK)\n    except ValueError:\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid.\n# A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels. The guide object's color \n# is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Determine the guide object by finding the one with a unique color\n    guide_object = None\n    guide_color = None\n    for obj in objects:\n        colors = object_colors(obj, background=Color.BLACK)\n        if len(colors) == 1:\n            guide_object = obj\n            guide_color = colors[0]\n            break\n\n    # Create an output grid to store the result\n    output_grid = input_grid.copy()\n\n    # Find enclosed regions (holes) in the grid\n    interior_mask = object_interior(input_grid)\n    boundary_mask = object_boundary(input_grid)\n    hole_mask = interior_mask & ~boundary_mask & (input_grid == Color.BLACK)\n\n    # Fill holes with the guide object's color\n    output_grid[hole_mask] = guide_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid size between 10x10 to 20x20\n    grid_size = np.random.randint(10, 21)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Add random non-background objects to the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj_width = np.random.randint(3, 6)\n        obj_height = np.random.randint(3, 6)\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = np.full((obj_width, obj_height), obj_color)\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Add a guide object with a unique color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    while np.any(grid == guide_color):\n        guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_width = np.random.randint(2, 4)\n    guide_height = np.random.randint(2, 4)\n    guide_sprite = np.full((guide_width, guide_height), guide_color)\n    x, y = random_free_location_for_sprite(grid, guide_sprite, padding=1, border_size=1, background=Color.BLACK)\n    blit_sprite(grid, guide_sprite, x, y, background=Color.BLACK)\n\n    # Create a random number of holes in the grid\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, 3)\n        hole_x = np.random.randint(1, grid_size - hole_size)\n        hole_y = np.random.randint(1, grid_size - hole_size)\n        grid[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color propagation, hole filling\n\n# description:\n# Identify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid.\n# A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels.\n# The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged.\n\ndef main(input_grid):\n    # Identify the unique color in the grid that will serve as the guide color\n    colors = object_colors(input_grid, background=Color.BLACK)\n    assert len(colors) == 1, \"There should be exactly one guide color in the grid\"\n    guide_color = colors[0]\n\n    # Create an output grid to store the result\n    output_grid = input_grid.copy()\n\n    # Find all enclosed regions (holes) in the grid\n    interior_mask = object_interior(input_grid, background=Color.BLACK)\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n    holes_mask = interior_mask & ~boundary_mask & (input_grid == Color.BLACK)\n\n    # Fill holes with the guide color\n    output_grid[holes_mask] = guide_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid size\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate a few random objects\n    num_objects = np.random.randint(2, 5)\n    for _ in range(num_objects):\n        obj_width = np.random.randint(3, 6)\n        obj_height = np.random.randint(3, 6)\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n\n        sprite = np.full((obj_width, obj_height), obj_color)\n        interior_mask = object_interior(sprite, background=obj_color)\n        boundary_mask = object_boundary(sprite, background=obj_color)\n        sprite[interior_mask & ~boundary_mask] = Color.BLACK\n\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    # Add a unique guide object with a unique color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    while guide_color in object_colors(grid, background=Color.BLACK):\n        guide_color = np.random.choice(list(Color.NOT_BLACK))\n\n    guide_width = np.random.randint(3, 5)\n    guide_height = np.random.randint(3, 5)\n    guide_sprite = np.full((guide_width, guide_height), guide_color)\n\n    # Find a location for the guide object\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK, padding=1)\n        blit_sprite(grid, guide_sprite, x, y, background=Color.BLACK)\n    except ValueError:\n        return generate_input()\n\n    return grid"], "seeds": ["44d8ac46.py", "810b9b61.py", "00d62c1b.py", "444801d8.py", "Concepts: \nguide object, color propagation, hole filling\n\nDescription: \nIdentify a guide object by its unique color in the grid. Use this color to fill all enclosed regions (holes) within the grid. A hole is defined as a region of background (0) pixels completely surrounded by non-background pixels. The guide object's color is propagated to fill these holes, ensuring that all other non-hole areas remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels using a specified color.\n# The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Get start and end positions\n    start_pos = np.argwhere((input_grid != Color.BLACK) & (input_grid != Color.RED))\n    start_x, start_y = start_pos[0]\n\n    end_pos = np.argwhere(input_grid == Color.RED)\n    end_x, end_y = end_pos[0]\n\n    # Determine the color for the line\n    line_color = input_grid[start_x, start_y]\n\n    # Draw a line from start to end using Bresenham's line algorithm\n    def bresenham(x0, y0, x1, y1):\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n        err = dx - dy\n\n        while True:\n            output_grid[x0, y0] = line_color\n            if x0 == x1 and y0 == y1:\n                break\n            e2 = 2 * err\n            if e2 > -dy:\n                err -= dy\n                x0 += sx\n            if e2 < dx:\n                err += dx\n                y0 += sy\n\n    # Draw the line\n    bresenham(start_x, start_y, end_x, end_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random color for the line\n    line_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly place the start pixel\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[start_x, start_y] = line_color\n\n    # Randomly place the end pixel (red) ensuring it's not the same as the start\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    while end_x == start_x and end_y == start_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input, you will see a grid with a single start pixel and a single end pixel.\n# To make the output, draw a straight line connecting the start and end pixels using a specified color.\n# The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given line color.\n\ndef main(input_grid):\n    # Copy the input to the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Identify the start and end pixels\n    start_color = Color.GREEN  # Assume start pixel is green\n    end_color = Color.RED      # Assume end pixel is red\n    line_color = Color.BLUE    # Line will be drawn in blue\n\n    # Locate the start and end positions\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    end_pos = np.argwhere(input_grid == end_color)[0]\n\n    # Use Bresenham's line algorithm to find the line path\n    def bresenham(x0, y0, x1, y1):\n        \"\"\" Bresenham's Line Algorithm to generate points between two coordinates \"\"\"\n        points = []\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n        err = dx - dy\n\n        while True:\n            points.append((x0, y0))\n            if x0 == x1 and y0 == y1:\n                break\n            e2 = err * 2\n            if e2 > -dy:\n                err -= dy\n                x0 += sx\n            if e2 < dx:\n                err += dx\n                y0 += sy\n        return points\n\n    # Get the line points\n    line_points = bresenham(start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n\n    # Color the line on the output grid\n    for x, y in line_points:\n        output_grid[x, y] = line_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random size between 10x10 and 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two distinct random positions for start and end pixels\n    start_pos = (np.random.randint(0, n), np.random.randint(0, m))\n    end_pos = (np.random.randint(0, n), np.random.randint(0, m))\n    \n    # Ensure start and end are not the same\n    while start_pos == end_pos:\n        end_pos = (np.random.randint(0, n), np.random.randint(0, m))\n\n    # Place the start and end pixels\n    grid[start_pos] = Color.GREEN  # Start pixel\n    grid[end_pos] = Color.RED      # End pixel\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input you will see a grid with a single start pixel and a single end pixel of different colors.\n# To make the output grid, draw a straight line connecting these two pixels using a specified color.\n# The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color.\n# The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Copy the input to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the start and end pixels\n    start_color = Color.RED  # Assume start pixel color\n    end_color = Color.BLUE  # Assume end pixel color\n    line_color = Color.GREEN  # Use green color for the line\n\n    # Get the position of start and end pixels\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    end_pos = np.argwhere(input_grid == end_color)[0]\n\n    # Extract coordinates\n    start_x, start_y = start_pos\n    end_x, end_y = end_pos\n\n    # Calculate the differences\n    dx = end_x - start_x\n    dy = end_y - start_y\n\n    # Determine the number of steps\n    steps = max(abs(dx), abs(dy))\n\n    # Calculate the increments\n    x_increment = dx / steps\n    y_increment = dy / steps\n\n    # Draw the line by updating the grid\n    for step in range(steps + 1):\n        x = int(start_x + step * x_increment)\n        y = int(start_y + step * y_increment)\n        output_grid[x, y] = line_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n = m = np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two distinct colors for start and end pixels\n    start_color = Color.RED\n    end_color = Color.BLUE\n\n    # Place start pixel\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[start_x, start_y] = start_color\n\n    # Place end pixel, ensuring it is different from start\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    while end_x == start_x and end_y == start_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[end_x, end_y] = end_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input, you will see a grid with two distinct pixels marked as start and end.\n# To make the output, draw a straight line connecting these two pixels using a specified color.\n# The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Locate the start and end points based on unique colors\n    start_color = None\n    end_color = None\n    for color in np.unique(input_grid):\n        if np.sum(input_grid == color) == 1:\n            if start_color is None:\n                start_color = color\n            else:\n                end_color = color\n                break\n\n    # Get the positions of the start and end points\n    start_x, start_y = np.where(input_grid == start_color)\n    end_x, end_y = np.where(input_grid == end_color)\n\n    # Draw a line connecting the start and end points\n    draw_line(output_grid, start_x[0], start_y[0], end_x=end_x[0], end_y=end_y[0], color=start_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two distinct random colors for start and end points\n    start_color, end_color = np.random.choice(list(Color.NOT_BLACK), 2, replace=False)\n\n    # Place the start point randomly on the grid\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[start_x, start_y] = start_color\n\n    # Place the end point randomly on the grid, ensuring it's not the same as the start point\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    while end_x == start_x and end_y == start_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[end_x, end_y] = end_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input you will see a grid with two distinct colored pixels: one for the start and another for the end.\n# The task is to draw a straight line connecting these two pixels using a specified color.\n# The line should be drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color.\n# The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify start and end positions\n    start_position = np.argwhere(input_grid == Color.GREEN)[0]\n    end_position = np.argwhere(input_grid == Color.RED)[0]\n\n    # Draw a line between the start and end positions using a specified color\n    draw_line(output_grid, x=start_position[0], y=start_position[1],\n              end_x=end_position[0], end_y=end_position[1], color=Color.BLUE)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n, m = np.random.randint(10, 21, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place a start pixel (GREEN) and an end pixel (RED) on the grid\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Ensure start and end positions are not the same\n    while start_x == end_x and start_y == end_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Assign colors to start and end positions\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\nimport random\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels using a specified color.\n# The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color.\n# The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # find the start and end positions\n    start_x, start_y = np.where(input_grid == Color.RED)\n    end_x, end_y = np.where(input_grid == Color.BLUE)\n\n    # get the coordinates of the start and end pixels\n    start_x, start_y = start_x[0], start_y[0]\n    end_x, end_y = end_x[0], end_y[0]\n\n    # Determine the color to use for the line\n    line_color = Color.GREEN\n\n    # Use Bresenham's line algorithm to draw a line between start and end points\n    def bresenham(x1, y1, x2, y2):\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        sx = 1 if x1 < x2 else -1\n        sy = 1 if y1 < y2 else -1\n        err = dx - dy\n\n        while True:\n            output_grid[x1, y1] = line_color\n            if x1 == x2 and y1 == y2:\n                break\n            e2 = err * 2\n            if e2 > -dy:\n                err -= dy\n                x1 += sx\n            if e2 < dx:\n                err += dx\n                y1 += sy\n\n    # Draw the line\n    bresenham(start_x, start_y, end_x, end_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose start and end colors\n    start_color, end_color = Color.RED, Color.BLUE\n\n    # Randomly place start and end pixels on the grid\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Ensure start and end positions are not the same\n    while start_x == end_x and start_y == end_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Place the start and end colors on the grid\n    grid[start_x, start_y] = start_color\n    grid[end_x, end_y] = end_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels\n# using a specified color. The line is drawn using pixel connectivity, updating the grid by coloring each\n# pixel along the path with the given color. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the start and end points\n    start_x, start_y = np.argwhere(input_grid == Color.GREEN)[0]\n    end_x, end_y = np.argwhere(input_grid == Color.RED)[0]\n\n    # Determine the line color, which is BLUE in this case\n    line_color = Color.BLUE\n\n    # Use Bresenham's line algorithm to draw a straight line between start and end\n    dx = abs(end_x - start_x)\n    dy = abs(end_y - start_y)\n    sx = 1 if start_x < end_x else -1\n    sy = 1 if start_y < end_y else -1\n    err = dx - dy\n\n    x, y = start_x, start_y\n    while True:\n        output_grid[x, y] = line_color\n        if x == end_x and y == end_y:\n            break\n        e2 = 2 * err\n        if e2 > -dy:\n            err -= dy\n            x += sx\n        if e2 < dx:\n            err += dx\n            y += sy\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid_size = 10\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly place start and end points\n    start_x, start_y = np.random.randint(0, grid_size, 2)\n    end_x, end_y = np.random.randint(0, grid_size, 2)\n\n    # Ensure start and end points are not the same\n    while (start_x == end_x) and (start_y == end_y):\n        end_x, end_y = np.random.randint(0, grid_size, 2)\n\n    # Place start and end points on the grid\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input, you will see a grid with two distinct pixels marked as start (green) and end (red).\n# To make the output, draw a straight line connecting these two pixels using a specified color (blue).\n# The line should be drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color.\n# The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Copy input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the start and end positions\n    start_pos = np.argwhere(input_grid == Color.GREEN)[0]\n    end_pos = np.argwhere(input_grid == Color.RED)[0]\n    \n    # Extract x and y coordinates for start and end\n    x1, y1 = start_pos\n    x2, y2 = end_pos\n\n    # Determine the color to draw the line\n    line_color = Color.BLUE\n\n    # Use Bresenham's line algorithm to draw a line between start and end\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    sx = 1 if x1 < x2 else -1\n    sy = 1 if y1 < y2 else -1\n    err = dx - dy\n\n    while True:\n        output_grid[x1, y1] = line_color\n        if x1 == x2 and y1 == y2:\n            break\n        e2 = 2 * err\n        if e2 > -dy:\n            err -= dy\n            x1 += sx\n        if e2 < dx:\n            err += dx\n            y1 += sy\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place start and end pixels ensuring they are not the same\n    x_start, y_start = np.random.randint(0, n), np.random.randint(0, m)\n    x_end, y_end = np.random.randint(0, n), np.random.randint(0, m)\n    \n    while x_start == x_end and y_start == y_end:\n        x_end, y_end = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Set the start and end positions on the grid\n    grid[x_start, y_start] = Color.GREEN\n    grid[x_end, y_end] = Color.RED\n\n    return grid"], "seeds": ["23581191.py", "6cdd2623.py", "834ec97d.py", "2dd70a9a.py", "Concepts: \nline drawing, pixel connectivity, grid update\n\nDescription: \nGiven a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels using a specified color. The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color. The rest of the grid remains unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line finding, detours\n\n# description:\n# In the input, you will see a grid with a start point marked in green, an endpoint marked in red, and several obstacles marked in blue.\n# The task is to connect the start point to the endpoint with a continuous line that avoids the obstacles.\n# The line should be drawn in yellow. If an obstacle is encountered, the path should take a detour around it.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Parse the input to find the start point, endpoint, and obstacles\n    # 2. Use a pathfinding algorithm like A* to navigate from start to end, avoiding obstacles\n    # 3. Draw the path on the grid using yellow color\n\n    # 1. Parse the input\n    background = Color.BLACK\n    start_position = np.argwhere(input_grid == Color.GREEN)[0]\n    end_position = np.argwhere(input_grid == Color.RED)[0]\n    obstacles = (input_grid == Color.BLUE)\n\n    # 2. Implement A* pathfinding algorithm\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def astar(start, goal, obstacles):\n        from heapq import heappop, heappush\n        open_set = []\n        heappush(open_set, (0, start))\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: heuristic(start, goal)}\n\n        while open_set:\n            _, current = heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                path.reverse()\n                return path\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # 4 directions\n                neighbor = (current[0] + dx, current[1] + dy)\n                if 0 <= neighbor[0] < input_grid.shape[0] and 0 <= neighbor[1] < input_grid.shape[1]:\n                    if obstacles[neighbor]:\n                        continue\n                    tentative_g_score = g_score[current] + 1\n                    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                        came_from[neighbor] = current\n                        g_score[neighbor] = tentative_g_score\n                        f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                        heappush(open_set, (f_score[neighbor], neighbor))\n        return []\n\n    # 3. Draw the path\n    path = astar(tuple(start_position), tuple(end_position), obstacles)\n    output_grid = input_grid.copy()\n    for x, y in path:\n        if output_grid[x, y] not in [Color.GREEN, Color.RED]:\n            output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a start point, endpoint, and several obstacles\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Place start point\n    start_x, start_y = np.random.randint(0, n, size=2)\n    grid[start_x, start_y] = Color.GREEN\n\n    # Place endpoint at a different location\n    end_x, end_y = start_x, start_y\n    while end_x == start_x and end_y == start_y:\n        end_x, end_y = np.random.randint(0, n, size=2)\n    grid[end_x, end_y] = Color.RED\n\n    # Place obstacles\n    num_obstacles = np.random.randint(n // 2, n)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(0, n, size=2)\n        if grid[obs_x, obs_y] == Color.BLACK:\n            grid[obs_x, obs_y] = Color.BLUE\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, detours\n\n# description:\n# In the input you will see a grid with a background color and various colored pixels representing obstacles.\n# A planned path is indicated by a line of a specific color, starting from the top left, intended to reach the bottom right.\n# The transformation involves navigating this path while avoiding obstacles, drawing the path around them without overwriting any obstacles.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background and obstacle colors.\n    # 2. Start from the top left and attempt to draw a line to the bottom right.\n    # 3. Whenever an obstacle is encountered, navigate around it without overwriting it.\n    # 4. Produce the output grid with the path.\n\n    # 1. Identify background and obstacle colors\n    background = Color.BLACK\n    path_color = Color.RED  # The color of the planned path\n    obstacle_colors = set(np.unique(input_grid)) - {background, path_color}\n\n    # Initialize the output grid\n    output_grid = input_grid.copy()\n\n    # Start from the top left\n    current_x, current_y = 0, 0\n    target_x, target_y = output_grid.shape[0] - 1, output_grid.shape[1] - 1\n\n    # 2. Function to move towards target, bypassing obstacles\n    def move_towards_target(x, y, target_x, target_y):\n        while (x, y) != (target_x, target_y):\n            # Check possible movements\n            if x < target_x and output_grid[x + 1, y] not in obstacle_colors:\n                x += 1\n            elif y < target_y and output_grid[x, y + 1] not in obstacle_colors:\n                y += 1\n            else:\n                # Detour: try alternate pathways\n                if y < target_y and output_grid[x, y + 1] not in obstacle_colors:\n                    y += 1\n                elif x < target_x and output_grid[x + 1, y] not in obstacle_colors:\n                    x += 1\n                else:\n                    # If stuck, attempt to navigate around the obstacle\n                    if x < target_x - 1 and output_grid[x + 2, y] not in obstacle_colors:\n                        x += 2\n                    elif y < target_y - 1 and output_grid[x, y + 2] not in obstacle_colors:\n                        y += 2\n                    else:\n                        # No path forward; need more sophisticated pathfinding\n                        break\n            output_grid[x, y] = path_color\n        return x, y\n\n    # 3. Draw the path while avoiding obstacles\n    end_x, end_y = move_towards_target(current_x, current_y, target_x, target_y)\n\n    # 4. Return the output grid with the path\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random obstacles and a planned path\n    n = random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Randomly choose colors for obstacles\n    obstacle_colors = list(Color.NOT_BLACK)\n    random.shuffle(obstacle_colors)\n    obstacles = random.choice(obstacle_colors, size=random.randint(2, 5), replace=False)\n\n    # Place obstacles randomly\n    for _ in range(random.randint(n // 2, n)):\n        x, y = random.randint(0, n - 1), random.randint(0, n - 1)\n        grid[x, y] = random.choice(obstacles)\n\n    # Define the path color\n    path_color = Color.RED\n\n    # Start the path from the top left\n    grid[0, 0] = path_color\n\n    # Place path indicator at bottom right\n    grid[n - 1, n - 1] = path_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, detours\n\n# description:\n# In the input, you will see a grid with a starting point marked in blue and an intended endpoint marked in red. There are also obstacles of a different color scattered across the grid.\n# The task is to draw a green line from the start to the end while avoiding obstacles. If the line encounters an obstacle, a detour around the obstacle should be made, ensuring the path connects the start and end without overwriting obstacles.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the starting and ending points.\n    # 2. Identify the obstacles.\n    # 3. Use a simple pathfinding algorithm to draw a continuous line from the start to the end, avoiding obstacles.\n\n    # Set background and identify colors\n    background = Color.BLACK\n    start_color = Color.BLUE\n    end_color = Color.RED\n    obstacle_color = Color.GREY\n    path_color = Color.GREEN\n\n    # Locate start and end points\n    start_points = np.argwhere(input_grid == start_color)\n    end_points = np.argwhere(input_grid == end_color)\n    obstacles = np.argwhere(input_grid == obstacle_color)\n\n    if len(start_points) == 0 or len(end_points) == 0:\n        raise ValueError(\"Start or End point missing in the grid\")\n\n    start_x, start_y = start_points[0]\n    end_x, end_y = end_points[0]\n\n    # Function to find path avoiding obstacles\n    def find_path(start, end, obstacles):\n        from queue import Queue\n\n        # Directions: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = set()\n        queue = Queue()\n        queue.put((start, []))\n\n        while not queue.empty():\n            current_pos, path = queue.get()\n            if current_pos == end:\n                return path\n\n            for dx, dy in directions:\n                new_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                if new_pos not in visited and 0 <= new_pos[0] < input_grid.shape[0] and 0 <= new_pos[1] < input_grid.shape[1]:\n                    if input_grid[new_pos] not in {obstacle_color, start_color}:\n                        visited.add(new_pos)\n                        new_path = path + [new_pos]\n                        queue.put((new_pos, new_path))\n\n        return []\n\n    # Find path\n    path = find_path((start_x, start_y), (end_x, end_y), obstacles)\n\n    # Draw the path on the grid\n    output_grid = input_grid.copy()\n    for x, y in path:\n        if output_grid[x, y] != start_color and output_grid[x, y] != end_color:\n            output_grid[x, y] = path_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a start, end, and obstacles\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place start and end points\n    start_x, start_y = np.random.randint(0, width), np.random.randint(0, height)\n    end_x, end_y = np.random.randint(0, width), np.random.randint(0, height)\n\n    grid[start_x, start_y] = Color.BLUE\n    grid[end_x, end_y] = Color.RED\n\n    # Place obstacles randomly\n    num_obstacles = np.random.randint(5, 15)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[obs_x, obs_y] == Color.BLACK:  # Ensure not overwriting start/end\n            grid[obs_x, obs_y] = Color.GREY\n\n    # Ensure there is a possible path by removing any direct path obstacles\n    if abs(start_x - end_x) + abs(start_y - end_y) < num_obstacles:\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, detours\n\n# description:\n# In the input, you will see a grid with randomly placed colored obstacles and a planned line. \n# The planned line is represented by a pair of start and end points. \n# The task is to draw the line while navigating around any obstacles, ensuring that no obstacle is overwritten. \n# The line should reach its intended destination even if it requires detours.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the start and end points of the planned line.\n    # 2. Identify the obstacles on the grid.\n    # 3. Implement a pathfinding algorithm to draw the line from start to end, avoiding obstacles.\n    # 4. Update the grid with the drawn line, preserving obstacles.\n\n    # Find the start and end points of the line\n    line_color = Color.RED  # Assume the line is meant to be red\n    start = None\n    end = None\n    for x, y in np.argwhere(input_grid == line_color):\n        if start is None:\n            start = (x, y)\n        else:\n            end = (x, y)\n\n    # Identify obstacles\n    obstacle_colors = {color for color in Color.ALL_COLORS if color != Color.BLACK and color != line_color}\n    obstacles = np.isin(input_grid, list(obstacle_colors))\n\n    # Pathfinding using BFS or A* to avoid obstacles\n    from queue import Queue\n    queue = Queue()\n    queue.put((start, [start]))  # Position and path\n    visited = set([start])\n\n    while not queue.empty():\n        current_position, path = queue.get()\n        x, y = current_position\n        \n        if current_position == end:\n            # Draw the path on the grid\n            for px, py in path:\n                if input_grid[px, py] not in obstacle_colors:\n                    input_grid[px, py] = line_color\n            return input_grid\n\n        # Explore neighbors\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < input_grid.shape[0] and 0 <= new_y < input_grid.shape[1]:\n                if (new_x, new_y) not in visited and not obstacles[new_x, new_y]:\n                    visited.add((new_x, new_y))\n                    queue.put(((new_x, new_y), path + [(new_x, new_y)]))\n\n    return input_grid  # Return the grid as it is if no path is found\n\ndef generate_input():\n    # Generate a grid with random obstacles and a planned line\n    width, height = 15, 15\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place obstacles\n    num_obstacles = np.random.randint(10, 20)\n    for _ in range(num_obstacles):\n        obstacle_color = np.random.choice(list(Color.ALL_COLORS - {Color.BLACK, Color.RED}))\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = obstacle_color\n\n    # Add start and end points for the line\n    start_x, start_y = np.random.randint(0, width), np.random.randint(0, height)\n    end_x, end_y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[start_x, start_y] = Color.RED\n    grid[end_x, end_y] = Color.RED\n\n    # Ensure start and end are not on obstacles\n    while grid[start_x, start_y] in obstacle_colors or grid[end_x, end_y] in obstacle_colors:\n        start_x, start_y = np.random.randint(0, width), np.random.randint(0, height)\n        end_x, end_y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[start_x, start_y] = Color.RED\n        grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, detours\n\n# description:\n# In the input you will see a grid with a start point (green), an end point (red), and various obstacles (grey).\n# Draw a line from the start to the end, avoiding the obstacles.\n# The line should navigate around the obstacles when necessary and should be colored blue.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start (green) and end (red) points\n    # 2. Identify the obstacles (grey)\n    # 3. Implement a pathfinding algorithm (e.g., BFS or A*) to find a path from start to end while avoiding obstacles\n    # 4. Draw the path in blue\n\n    # Identify colors\n    start_color = Color.GREEN\n    end_color = Color.RED\n    obstacle_color = Color.GREY\n    path_color = Color.BLUE\n    background = Color.BLACK\n\n    # Find the start and end points\n    start_points = np.argwhere(input_grid == start_color)\n    end_points = np.argwhere(input_grid == end_color)\n    assert len(start_points) == 1 and len(end_points) == 1, \"There should be exactly one start and one end point.\"\n\n    start = tuple(start_points[0])\n    end = tuple(end_points[0])\n\n    # Obstacles mask\n    obstacles = (input_grid == obstacle_color)\n\n    # Implement BFS to find the shortest path avoiding obstacles\n    from collections import deque\n\n    def is_valid(x, y):\n        return 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1] and not obstacles[x, y] and input_grid[x, y] != path_color\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n\n    queue = deque([start])\n    parent = {start: None}\n\n    while queue:\n        current = queue.popleft()\n        if current == end:\n            break\n        for dx, dy in directions:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if is_valid(*neighbor) and neighbor not in parent:\n                parent[neighbor] = current\n                queue.append(neighbor)\n\n    # Reconstruct the path and draw it on the grid\n    if end in parent:\n        path = []\n        current = end\n        while current is not None:\n            path.append(current)\n            current = parent[current]\n\n        for x, y in path:\n            input_grid[x, y] = path_color\n\n    return input_grid\n\ndef generate_input():\n    # Generate a grid with a random start and end point, and random obstacles\n\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place start and end points\n    start_x, start_y = np.random.randint(0, width), np.random.randint(0, height)\n    end_x, end_y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    # Ensure start and end points are not the same\n    while (start_x, start_y) == (end_x, end_y):\n        end_x, end_y = np.random.randint(0, width), np.random.randint(0, height)\n\n    # Place random obstacles\n    num_obstacles = np.random.randint(5, width * height // 4)\n    for _ in range(num_obstacles):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[x, y] == Color.BLACK:  # Do not place obstacles on start or end\n            grid[x, y] = Color.GREY\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, detours\n\n# description:\n# In the input, you will find a black grid with a path of colored pixels. Some pixels are obstacles.\n# The path should extend from a start pixel to an end pixel.\n# If the path encounters an obstacle, it must take a detour around it without overwriting the obstacle.\n# The output should be a grid where the path is extended from start to end, avoiding obstacles.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify start, end, and obstacles\n    # 2. Extend the path step by step, navigating around obstacles as necessary\n    # 3. Ensure the path reaches the destination without altering obstacles\n\n    background = Color.BLACK\n    # Identify start, end, and obstacles\n    colors = np.unique(input_grid)\n    colors = colors[colors != background]\n    \n    start_color = np.random.choice(colors)\n    end_color = np.random.choice(colors[colors != start_color])\n    obstacle_colors = set(colors) - {start_color, end_color}\n    \n    start_positions = np.argwhere(input_grid == start_color)\n    end_positions = np.argwhere(input_grid == end_color)\n    obstacle_positions = np.argwhere(np.isin(input_grid, list(obstacle_colors)))\n\n    output_grid = input_grid.copy()\n\n    # Determine path directions\n    for start_pos in start_positions:\n        for end_pos in end_positions:\n            path = find_path(output_grid, start_pos, end_pos, obstacle_positions)\n            if path:\n                for x, y in path:\n                    output_grid[x, y] = start_color\n                break\n\n    return output_grid\n\ndef find_path(grid, start, end, obstacles):\n    # Simple pathfinding with detours around obstacles\n    from collections import deque\n\n    queue = deque([(start, [])])\n    visited = set()\n\n    while queue:\n        (x, y), path = queue.popleft()\n        if (x, y) == tuple(end):\n            return path\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:\n                if (nx, ny) not in visited and grid[nx, ny] == Color.BLACK and (nx, ny) not in obstacles:\n                    queue.append(((nx, ny), path + [(nx, ny)]))\n                    visited.add((nx, ny))\n\n    return None\n\ndef generate_input():\n    # Generate a grid with a start and end point and random obstacles\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    start_color = np.random.choice(Color.NOT_BLACK)\n    end_color = np.random.choice([c for c in Color.NOT_BLACK if c != start_color])\n    obstacle_colors = np.random.choice([c for c in Color.NOT_BLACK if c not in (start_color, end_color)], size=3, replace=False)\n\n    start_x, start_y = np.random.randint(0, width), np.random.randint(0, height)\n    end_x, end_y = np.random.randint(0, width), np.random.randint(0, height)\n\n    grid[start_x, start_y] = start_color\n    grid[end_x, end_y] = end_color\n\n    num_obstacles = np.random.randint(5, 10)\n    for _ in range(num_obstacles):\n        obstacle_color = np.random.choice(obstacle_colors)\n        obstacle_x, obstacle_y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[obstacle_x, obstacle_y] = obstacle_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, detours\n\n# description:\n# In the input, you will see a grid with a start point marked by a green pixel and an end point marked by a red pixel.\n# There are several obstacles marked by blue pixels. The task is to draw a continuous line from the green start point to the red end point.\n# The line should be drawn in yellow and must avoid any blue obstacles by creating detours around them.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start and end points.\n    # 2. Use a pathfinding algorithm to navigate from start to end, avoiding blue obstacles.\n    # 3. Draw the path in yellow.\n\n    # Identify colors\n    background = Color.BLACK\n    start_color = Color.GREEN\n    end_color = Color.RED\n    obstacle_color = Color.BLUE\n    path_color = Color.YELLOW\n\n    # Find the start and end positions\n    start_position = tuple(np.argwhere(input_grid == start_color)[0])\n    end_position = tuple(np.argwhere(input_grid == end_color)[0])\n\n    # 2. Use a pathfinding algorithm to navigate from start to end, avoiding blue obstacles.\n    def get_neighbors(pos):\n        x, y = pos\n        neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n        return [(nx, ny) for nx, ny in neighbors if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]]\n\n    def is_obstacle(pos):\n        x, y = pos\n        return input_grid[x, y] == obstacle_color\n\n    # Perform Breadth-First Search (BFS) for shortest path\n    from collections import deque\n    queue = deque([start_position])\n    came_from = {start_position: None}\n\n    while queue:\n        current = queue.popleft()\n\n        if current == end_position:\n            break\n\n        for neighbor in get_neighbors(current):\n            if neighbor not in came_from and not is_obstacle(neighbor):\n                queue.append(neighbor)\n                came_from[neighbor] = current\n\n    # Reconstruct the path\n    path = []\n    step = end_position\n    while step:\n        path.append(step)\n        step = came_from.get(step)\n\n    # 3. Draw the path in yellow.\n    output_grid = input_grid.copy()\n    for x, y in path:\n        if output_grid[x, y] not in {start_color, end_color}:\n            output_grid[x, y] = path_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random obstacles and defined start/end points\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place start and end points\n    start_x, start_y = np.random.randint(1, width-1), np.random.randint(1, height-1)\n    end_x, end_y = np.random.randint(1, width-1), np.random.randint(1, height-1)\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    # Add random obstacles\n    num_obstacles = np.random.randint(5, 10)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[obs_x, obs_y] == Color.BLACK:\n            grid[obs_x, obs_y] = Color.BLUE\n\n    # Ensure there is a possible path by removing a few obstacles if needed\n    while not is_path_possible(grid, (start_x, start_y), (end_x, end_y)):\n        obs_x, obs_y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[obs_x, obs_y] == Color.BLUE:\n            grid[obs_x, obs_y] = Color.BLACK\n\n    return grid\n\ndef is_path_possible(grid, start, end):\n    # Simple DFS to check if there's a path from start to end\n    stack = [start]\n    visited = set()\n    while stack:\n        current = stack.pop()\n        if current == end:\n            return True\n        if current in visited:\n            continue\n        visited.add(current)\n        for neighbor in get_neighbors(current):\n            if grid[neighbor] != Color.BLUE and neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef get_neighbors(pos):\n    x, y = pos\n    return [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, detours\n\n# description:\n# In the input, you will see a grid with a starting point and an endpoint, marked by distinct colors, and obstacles marked with another color.\n# Draw a line from the start to the end. If an obstacle is encountered, navigate around it and continue the line,\n# ensuring you do not overwrite any existing obstacles or the endpoint.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start, end, and obstacle pixels based on their colors.\n    # 2. Draw a line from the start to the end, navigating around obstacles.\n    # 3. Ensure the line reaches its intended destination while preserving existing objects.\n\n    # Identify colors\n    start_color = Color.RED\n    end_color = Color.GREEN\n    obstacle_color = Color.BLUE\n    path_color = Color.YELLOW  # Line color\n\n    # Find positions\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    end_pos = np.argwhere(input_grid == end_color)[0]\n    obstacles = np.argwhere(input_grid == obstacle_color)\n\n    # Create a function to navigate around obstacles\n    def navigate_and_draw_path(grid, start, end):\n        x, y = start\n        end_x, end_y = end\n        direction = np.sign(end - start)\n\n        # Move in the direction of the endpoint\n        while (x, y) != (end_x, end_y):\n            # Check if the next step hits an obstacle\n            next_x, next_y = x + direction[0], y + direction[1]\n            if grid[next_x, next_y] == obstacle_color:\n                # Find a detour around the obstacle\n                if direction[0] != 0:  # Currently moving horizontally\n                    # Try moving vertically as a detour\n                    if grid[x, y + 1] != obstacle_color:\n                        y += 1\n                    elif grid[x, y - 1] != obstacle_color:\n                        y -= 1\n                if direction[1] != 0:  # Currently moving vertically\n                    # Try moving horizontally as a detour\n                    if grid[x + 1, y] != obstacle_color:\n                        x += 1\n                    elif grid[x - 1, y] != obstacle_color:\n                        x -= 1\n            else:\n                # Move towards the end\n                x, y = next_x, next_y\n            \n            # Draw the path\n            grid[x, y] = path_color\n\n    # Create a copy of the input grid to modify\n    output_grid = input_grid.copy()\n\n    # Draw path from start to end\n    navigate_and_draw_path(output_grid, start_pos, end_pos)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with a start, end, and multiple obstacles\n    width, height = 10, 10\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define colors for start, end, and obstacles\n    start_color = Color.RED\n    end_color = Color.GREEN\n    obstacle_color = Color.BLUE\n\n    # Randomly place the start and end points\n    start_x, start_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    end_x, end_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n\n    grid[start_x, start_y] = start_color\n    grid[end_x, end_y] = end_color\n\n    # Randomly place obstacles\n    num_obstacles = np.random.randint(5, 10)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n        if grid[obs_x, obs_y] == Color.BLACK:  # Ensure not overwriting start/end\n            grid[obs_x, obs_y] = obstacle_color\n\n    return grid"], "seeds": ["2dd70a9a.py", "2c608aff.py", "6aa20dc0.py", "e8dc4411.py", "Concepts: \nobstacles, path blocking, line drawing, detours\n\nDescription: \nIdentify any non-background pixels (obstacles) that lie along a planned line or replication path. These obstacles block the direct path and require handling such as detours, bypassing, or recoloring. The transformation involves navigating around these obstacles to complete the path without overwriting them, ensuring the line or replication reaches its intended destination while preserving existing objects."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# The input consists of a grid with various colored objects.\n# To create the output, identify a single connected component (object) within the grid.\n# Apply a given color scheme to recolor the entire object.\n# The color scheme may be a single color or a function that determines the color based on object properties.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n\n    # Choose a single object to transform (for simplicity, choose the largest one)\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Define a color scheme; for simplicity, choose to recolor with a random color from the palette\n    new_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Apply the color scheme to the chosen object\n    largest_object[largest_object != Color.BLACK] = new_color\n\n    # Create the output grid by blitting back all objects\n    output_grid = input_grid.copy()\n    blit_object(output_grid, largest_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10 with random colored objects\n    grid_size = 10\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate random objects and place them in the grid\n    num_objects = np.random.randint(3, 6)  # Random number of objects\n    for _ in range(num_objects):\n        obj = random_sprite(n=[2, 3, 4], m=[2, 3, 4], color_palette=[Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW])\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# In the input grid, you have various colored objects. One of these objects will be selected based on its size (area).\n# The largest object in the grid will be recolored entirely with a new color, say BLUE.\n# The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    \n    # Determine the largest object based on the number of non-background pixels\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Create a copy of the input grid for the output\n    output_grid = input_grid.copy()\n    \n    # Recolor the largest object to BLUE\n    largest_object[largest_object != Color.BLACK] = Color.BLUE\n    \n    # Blit the recolored largest object back into the output grid\n    blit_object(output_grid, largest_object, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Define grid size\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n    \n    # Generate a variety of random objects with different colors\n    num_objects = np.random.randint(4, 8)\n    for _ in range(num_objects):\n        obj_size = np.random.randint(3, 7)\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        obj = random_sprite(obj_size, obj_size, color_palette=[obj_color])\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1, padding_connectivity=8)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            # If we can't place anymore objects, return the grid\n            return grid\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# Identify a single connected component (object) within the grid. Apply a given color scheme to recolor the entire object.\n# The color scheme may be a single color or a function that determines the color based on object properties. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the input grid\n    components = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n    \n    # Select one component to apply a color scheme\n    # For simplicity, let's choose the largest component\n    largest_component = max(components, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Apply a color scheme to recolor the entire object\n    # Let's use a simple color scheme based on the size of the component\n    size = np.sum(largest_component != Color.BLACK)\n    \n    if size <= 5:\n        new_color = Color.RED\n    elif size <= 10:\n        new_color = Color.GREEN\n    else:\n        new_color = Color.BLUE\n    \n    # Recolor the largest component with the determined color\n    largest_component[largest_component != Color.BLACK] = new_color\n    \n    # Create the output grid by copying the input grid\n    output_grid = input_grid.copy()\n    \n    # Blit the recolored component back onto the output grid\n    blit_object(output_grid, largest_component, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Define grid size\n    grid_size = np.random.randint(10, 20)\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate multiple random objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Create a random sprite with a random color\n        sprite = random_sprite(n=list(range(2, 6)), m=list(range(2, 6)), color_palette=list(Color.NOT_BLACK))\n        \n        # Place the sprite in a random location on the grid\n        try:\n            x, y = random_free_location_for_sprite(input_grid, sprite, padding=1)\n            blit_sprite(input_grid, sprite, x, y)\n        except ValueError:\n            # If there's no free location, skip this sprite\n            continue\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recoloring, connected components, color scheme\n\n# description:\n# The input grid contains several colored objects. Identify a single connected component (object) that isn't the background color.\n# Recolor the entire object with a specified color scheme (e.g., a gradient from one color to another).\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Choose a random object that is not just the background\n    chosen_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Define a color scheme, for example, a gradient from RED to BLUE\n    color_scheme = [Color.RED, Color.PINK, Color.BLUE]\n\n    # Apply the color scheme to the chosen object\n    object_pixels = np.argwhere(chosen_object != Color.BLACK)\n    num_pixels = len(object_pixels)\n    for idx, (x, y) in enumerate(object_pixels):\n        # Determine the color based on position in the object\n        chosen_object[x, y] = color_scheme[idx % len(color_scheme)]\n\n    # Create the output grid by overlaying the recolored object onto the original grid\n    output_grid = input_grid.copy()\n    blit_object(output_grid, chosen_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    n = np.random.randint(12, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Generate a few random objects of various colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=Color.NOT_BLACK)\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x, y)\n        except ValueError:\n            continue  # If we can't place the object, skip it\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# Identify a single connected component (object) within the grid. Apply a given color scheme to recolor the entire object. \n# The color scheme may be a single color or a function that determines the color based on object properties.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all the objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    \n    # Choose a random object to recolor\n    target_object = np.random.choice(objects)\n\n    # Determine the color scheme based on object properties\n    # Here, we simply choose a random color from the available colors except black\n    new_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Apply the color scheme to the entire object\n    target_object[target_object != Color.BLACK] = new_color\n\n    # Create the output grid by placing the modified object onto the original grid\n    output_grid = input_grid.copy()\n    blit_object(output_grid, target_object, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate and place random objects in the grid until it is somewhat full\n    for _ in range(np.random.randint(3, 6)):\n        # Generate a random colored object\n        obj = random_sprite(list(range(3, 6)), list(range(3, 6)), color_palette=list(Color.NOT_BLACK), connectivity=8)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# The input grid contains several objects of different colors.\n# The task is to find a single connected component (object) and recolor it using a specified color scheme.\n# The color scheme may be a single color or a function that determines the color based on object properties.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    \n    # Copy the input grid to the output grid\n    output_grid = input_grid.copy()\n    \n    # Pick a random object from the list of connected components to recolor\n    random_object = objects[np.random.randint(len(objects))]\n    \n    # Define the color scheme (e.g., change the object's color to GREEN)\n    new_color = Color.GREEN\n    \n    # Apply the color scheme to the selected object\n    random_object[random_object != Color.BLACK] = new_color\n    \n    # Blit the recolored object back onto the output grid\n    blit_object(output_grid, random_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10 and 20\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n    \n    # Generate random objects and place them onto the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj = random_sprite(n=[3, 4, 5], m=[3, 4, 5], color_palette=list(Color.NOT_BLACK))\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n            \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# In the input grid, you will see various colored objects. Choose one single connected component (object) randomly and apply a recolor scheme to it. \n# The recolor scheme is to change the entire object to a single random color from the available color palette. All other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n    \n    # Choose one object randomly\n    chosen_object = np.random.choice(objects)\n    \n    # Select a random color from the available color palette, excluding black\n    new_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Recolor the chosen object\n    chosen_object[chosen_object != Color.BLACK] = new_color\n    \n    # Create the output grid and place the recolored object back\n    output_grid = input_grid.copy()\n    blit_object(output_grid, chosen_object, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n    \n    # Generate random objects with random colors and place them in the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=list(Color.NOT_BLACK))\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            continue\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# In the input grid, you will see various colored objects. Choose a random single connected component (object) from the grid, and apply a specific color scheme to recolor the entire object. \n# The color scheme for recoloring will be a gradient of colors, changing from the edge to the center of the object. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n\n    # Choose a random object to recolor\n    if objects:\n        selected_object = np.random.choice(objects)\n\n        # Recolor the object using a gradient scheme\n        output_grid = input_grid.copy()\n        gradient_colors = list(Color.NOT_BLACK)  # A gradient using all colors except black\n        gradient_colors.sort()  # Ensuring a consistent gradient order\n\n        # Calculate the distance of each pixel from the center of the object\n        obj_center = np.mean(np.argwhere(selected_object != Color.BLACK), axis=0)\n        distances = np.linalg.norm(np.argwhere(selected_object != Color.BLACK) - obj_center, axis=1)\n        max_distance = distances.max()\n\n        # Apply gradient colors based on distance\n        for idx, (x, y) in enumerate(np.argwhere(selected_object != Color.BLACK)):\n            distance_ratio = distances[idx] / max_distance\n            color_index = int(distance_ratio * (len(gradient_colors) - 1))\n            output_grid[x, y] = gradient_colors[color_index]\n\n        return output_grid\n    else:\n        return input_grid.copy()\n\ndef generate_input():\n    # Grid size\n    n = np.random.randint(10, 15)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Add random objects to the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj = random_sprite(list(range(2, 5)), list(range(2, 5)), color_palette=list(Color.NOT_BLACK), connectivity=8)\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1, padding_connectivity=8)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            continue\n\n    return input_grid"], "seeds": ["810b9b61.py", "aedd82e4.py", "06df4c85.py", "d2abd087.py", "Concepts: \nrecolor, connected components, color scheme\n\nDescription: \nIdentify a single connected component (object) within the grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color or a function that determines the color based on object properties. All other grid elements remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# Extract all connected components from the grid. Identify the guide object as the one whose color is unique among all components. \n# The guide object is the only one with a color that no other object shares. All other objects are ignored in the output.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    components = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n\n    # Create a dictionary to count occurrences of each color in different components\n    color_count = {}\n    for component in components:\n        color = np.unique(component[component != Color.BLACK])[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Identify the guide object with a unique color\n    guide_object = None\n    for component in components:\n        color = np.unique(component[component != Color.BLACK])[0]\n        if color_count[color] == 1:\n            guide_object = component\n            break\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    if guide_object is not None:\n        # Blit the guide object onto the output grid\n        blit_object(output_grid, guide_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Randomly define grid size\n    n = np.random.randint(5, 10)\n    grid = np.full((n, n), Color.BLACK)\n    \n    # Create random objects with random colors\n    num_objects = np.random.randint(3, 6)\n    all_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(all_colors)\n    \n    used_colors = []\n    for _ in range(num_objects):\n        # Generate a random sprite\n        sprite = random_sprite(n=np.random.randint(1, 4), m=np.random.randint(1, 4), color_palette=all_colors, connectivity=4)\n        \n        # Randomly choose a free location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n            used_colors.append(np.unique(sprite[sprite != Color.BLACK])[0])\n        except ValueError:\n            continue\n\n    # Ensure at least one color is unique\n    if len(set(used_colors)) == len(used_colors):\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# The input grid consists of several objects of different colors. \n# To create the output grid, extract all connected components and identify the guide object as the one whose color is unique among all components.\n# The guide object is the only one with a color that no other object shares.\n# All other objects are ignored in the output.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    \n    # Determine the color of each object\n    colors = [np.unique(obj[obj != Color.BLACK])[0] for obj in objects]\n    \n    # Find the unique color\n    unique_color = None\n    for color in colors:\n        if colors.count(color) == 1:\n            unique_color = color\n            break\n\n    # Create the output grid with the guide object\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Identify and blit the guide object\n    for obj in objects:\n        if np.any(obj == unique_color):\n            blit_object(output_grid, obj, background=Color.BLACK)\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Select a set of colors for the objects, ensuring at least one unique color\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n    unique_color = colors.pop()\n    \n    # Place objects with the same color\n    for _ in range(np.random.randint(2, 4)):\n        color = np.random.choice(colors)\n        obj = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    # Place one object with the unique color\n    unique_obj = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[unique_color])\n    try:\n        x, y = random_free_location_for_sprite(grid, unique_obj, padding=1)\n        blit_sprite(grid, unique_obj, x, y, background=Color.BLACK)\n    except ValueError:\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# Extract all connected components from the input grid. Identify the guide object as the one whose color is unique among all components. \n# The guide object is the only one with a color that no other object shares. All other objects are ignored in the output.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    components = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    # Count color occurrences among components\n    color_count = {}\n    for comp in components:\n        color = np.unique(comp[comp != Color.BLACK])[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Identify the unique color for the guide object\n    unique_color = [color for color, count in color_count.items() if count == 1]\n    if not unique_color:\n        return np.full_like(input_grid, Color.BLACK)  # If no unique color, return an empty grid\n\n    unique_color = unique_color[0]\n\n    # Find the guide object with the unique color\n    guide_object = None\n    for comp in components:\n        color = np.unique(comp[comp != Color.BLACK])[0]\n        if color == unique_color:\n            guide_object = comp\n            break\n\n    # Create the output grid and blit the guide object\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    if guide_object is not None:\n        blit_object(output_grid, guide_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Define grid size\n    n = np.random.randint(10, 15)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Choose colors for objects\n    available_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(available_colors)\n\n    # Create objects with the same color and one unique color object\n    num_objects = np.random.randint(3, 6)\n    chosen_colors = available_colors[:num_objects - 1]\n    unique_color = available_colors[num_objects - 1]\n    \n    # Place same color objects\n    for color in chosen_colors:\n        obj = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[color], density=0.5)\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x, y)\n        except ValueError:\n            continue\n\n    # Place unique color object\n    unique_obj = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[unique_color], density=0.5)\n    try:\n        x, y = random_free_location_for_sprite(input_grid, unique_obj, padding=1)\n        blit_sprite(input_grid, unique_obj, x, y)\n    except ValueError:\n        return generate_input()\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# The input consists of a grid with several connected components of various colors.\n# To create the output, identify the guide object which is the only object with a unique color among all components.\n# Ignore all other objects and output only the guide object in its original location.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    components = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Extract the unique colors of each component\n    color_counts = {}\n    for component in components:\n        unique_color = np.unique(component[component != Color.BLACK])[0]\n        if unique_color in color_counts:\n            color_counts[unique_color] += 1\n        else:\n            color_counts[unique_color] = 1\n\n    # Find the guide object color (unique color)\n    guide_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            guide_color = color\n            break\n\n    # Create the output grid with only the guide object\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    for component in components:\n        if guide_color in component:\n            blit_object(output_grid, component, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    size = np.random.randint(8, 12)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Determine the number of components and create random objects with random colors\n    num_components = np.random.randint(3, 6)\n    colors_used = set()\n    for _ in range(num_components):\n        while True:\n            obj_color = np.random.choice(list(Color.NOT_BLACK))\n            if obj_color not in colors_used:\n                colors_used.add(obj_color)\n                break\n\n        # Generate a random object with the selected color\n        obj = random_sprite(n=np.random.randint(3, 5), m=np.random.randint(3, 5), color_palette=[obj_color], density=0.5)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    # Ensure one color is unique by adding an extra object with an existing color\n    unique_color = np.random.choice(list(colors_used))\n    additional_obj = random_sprite(n=np.random.randint(2, 3), m=np.random.randint(2, 3), color_palette=[unique_color], density=0.5)\n    try:\n        x, y = random_free_location_for_sprite(grid, additional_obj, padding=1)\n        blit_sprite(grid, additional_obj, x, y, background=Color.BLACK)\n    except ValueError:\n        pass\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# In the input grid, you will see various connected components of different colors.\n# One of these objects will have a unique color that no other object shares. \n# This object is called the \"guide object\". The task is to identify this guide object\n# and output a grid with only this object, ignoring all others.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    \n    # Determine the color of each component\n    color_counts = {}\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        color_counts[color] = color_counts.get(color, 0) + 1\n    \n    # Identify the unique color\n    guide_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            guide_color = color\n            break\n    \n    # Extract the guide object with the unique color\n    guide_object = None\n    for obj in objects:\n        if np.any(obj == guide_color):\n            guide_object = obj\n            break\n    \n    # Prepare the output grid with only the guide object\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    if guide_object is not None:\n        blit_object(output_grid, guide_object, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n    \n    # Define a list of colors to use\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n    \n    # Place random objects on the grid\n    num_objects = np.random.randint(5, 10)\n    unique_color_index = np.random.randint(0, num_objects)\n    \n    for i in range(num_objects):\n        color = colors[i % len(colors)] if i != unique_color_index else colors[-1]\n        sprite = random_sprite(n=3, m=3, color_palette=[color], density=0.5)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# The input grid contains various connected components of different colors.\n# Among all components, identify the guide object which has a unique color that no other object shares.\n# The output grid should only contain this guide object, with all other components ignored.\n\ndef main(input_grid):\n    # Find all connected components in the input grid\n    components = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Count the occurrences of each color among all components\n    color_count = {}\n    for component in components:\n        color = np.unique(component[component != Color.BLACK])[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Identify the unique color that appears only once\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    # Find the guide object with the unique color\n    guide_object = None\n    for component in components:\n        if np.any(component == unique_color):\n            guide_object = component\n            break\n\n    # Create an output grid and place the guide object onto it\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    if guide_object is not None:\n        blit_object(output_grid, guide_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Determine the number of components to generate\n    num_components = np.random.randint(3, 6)\n\n    # Generate random components with random colors\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n\n    for i in range(num_components):\n        # Create a random sprite\n        sprite_size = np.random.randint(3, 5)\n        sprite = random_sprite(n=sprite_size, m=sprite_size, color_palette=[colors[i]], connectivity=8)\n\n        try:\n            # Place the sprite onto the grid\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If unable to place, retry with a new sprite\n            continue\n\n    # Ensure there is one guide object with a unique color\n    unique_color = colors[num_components - 1]\n    sprite = random_sprite(n=3, m=3, color_palette=[unique_color], connectivity=8)\n    try:\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n        blit_sprite(grid, sprite, x, y)\n    except ValueError:\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# In the input grid, there are several connected components, each with its own color. Among these components, one of them has a unique color that no other component shares. \n# To create the output grid, identify this unique-colored component and display only it. All other components are ignored in the output.\n\ndef main(input_grid):\n    # Find all connected components with monochromatic colors\n    components = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    # Dictionary to track color frequencies\n    color_count = {}\n\n    # Count the frequency of each color\n    for component in components:\n        color = np.unique(component[component != Color.BLACK])[0]\n        color_count[color] = color_count.get(color, 0) + 1\n\n    # Identify the unique color\n    unique_color = next((color for color, count in color_count.items() if count == 1), None)\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find the component with the unique color and blit it onto the output grid\n    for component in components:\n        if unique_color in component:\n            blit_object(output_grid, component, background=Color.BLACK)\n            break\n\n    return output_grid\n\ndef generate_input():\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    num_components = np.random.randint(3, 6)\n    all_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(all_colors)\n\n    # Ensure one unique color component\n    used_colors = all_colors[:num_components - 1]\n    unique_color = all_colors[num_components - 1]\n\n    # Place components with non-unique colors\n    for color in used_colors:\n        for _ in range(2):  # Ensure at least two components share each color\n            try:\n                sprite = random_sprite(n=3, m=3, color_palette=[color], density=0.6)\n                x, y = random_free_location_for_sprite(input_grid, sprite, padding=1, border_size=1)\n                blit_sprite(input_grid, sprite, x, y)\n            except ValueError:\n                continue\n\n    # Place the unique color component\n    try:\n        unique_sprite = random_sprite(n=3, m=3, color_palette=[unique_color], density=0.6)\n        x, y = random_free_location_for_sprite(input_grid, unique_sprite, padding=1, border_size=1)\n        blit_sprite(input_grid, unique_sprite, x, y)\n    except ValueError:\n        return generate_input()\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, guide object identification\n\n# description:\n# The input grid contains several connected components with various colors.\n# The goal is to extract the guide object, which is the only object with a unique color among all components.\n# All other objects are ignored in the output.\n\ndef main(input_grid):\n    # Find all connected components\n    components = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    \n    # Create a dictionary to count occurrences of each color\n    color_count = {}\n    for component in components:\n        # All pixels in the component have the same color, take any\n        component_color = component[np.argwhere(component != Color.BLACK)[0][0], np.argwhere(component != Color.BLACK)[0][1]]\n        if component_color in color_count:\n            color_count[component_color] += 1\n        else:\n            color_count[component_color] = 1\n\n    # Identify the guide object's color: it should only occur once\n    guide_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            guide_color = color\n            break\n\n    # Find and return the guide object\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    for component in components:\n        if np.any(component == guide_color):\n            blit_object(output_grid, component, background=Color.BLACK)\n            break\n\n    return output_grid\n\ndef generate_input():\n    n = np.random.randint(8, 12)\n    input_grid = np.full((n, n), Color.BLACK)\n    \n    # Generate a random number of components\n    num_components = np.random.randint(4, 8)\n    used_colors = set()\n\n    for _ in range(num_components):\n        # Create random components with unique colors\n        while True:\n            color_palette = list(Color.NOT_BLACK - used_colors)\n            obj_color = np.random.choice(color_palette)\n            used_colors.add(obj_color)\n            sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[obj_color])\n            try:\n                x, y = random_free_location_for_sprite(input_grid, sprite, padding=1, border_size=1)\n                blit_sprite(input_grid, sprite, x, y)\n                break\n            except ValueError:\n                continue\n\n    # Duplicate one color to ensure all but one are non-unique\n    duplicate_color = np.random.choice(list(used_colors))\n    while True:\n        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[duplicate_color])\n        try:\n            x, y = random_free_location_for_sprite(input_grid, sprite, padding=1, border_size=1)\n            blit_sprite(input_grid, sprite, x, y)\n            break\n        except ValueError:\n            continue\n            \n    return input_grid"], "seeds": ["810b9b61.py", "aedd82e4.py", "48d8fb45.py", "d2abd087.py", "Concepts: \nunique color selection, connected components, guide object identification\n\nDescription: \nExtract all connected components from the grid. Identify the guide object as the one whose color is unique among all components. The guide object is the only one with a color that no other object shares. All other objects are ignored in the output."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, starting point, position-based transformation\n\n# description:\n# In the input grid, there is a unique guide object represented by a distinct color (TEAL).\n# The task is to identify this guide object and use its position to perform a transformation.\n# Specifically, the transformation involves creating a radial gradient of colors around the guide object\n# in the output grid. The colors in the radial gradient should be chosen randomly from the available colors,\n# excluding BLACK and TEAL, and should change with increasing distance from the guide object.\n\ndef main(input_grid):\n    # Find the guide object in the grid (TEAL colored)\n    guide_object = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=8)[0]\n    \n    # Get the position of the guide object\n    guide_x, guide_y, *_ = bounding_box(guide_object, background=Color.BLACK)\n    \n    # Create an output grid of the same size as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define the available colors for the radial gradient, excluding BLACK and TEAL\n    available_colors = [color for color in Color.NOT_BLACK if color != Color.TEAL]\n\n    # Fill the output grid with a radial gradient centered at the guide object's position\n    n, m = input_grid.shape\n    for i in range(n):\n        for j in range(m):\n            # Calculate the distance from the guide object\n            distance = int(np.sqrt((i - guide_x) ** 2 + (j - guide_y) ** 2))\n            # Choose a color based on the distance\n            color = available_colors[distance % len(available_colors)]\n            output_grid[i, j] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a unique TEAL colored guide object\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Randomly place a TEAL colored pixel as the guide object\n    guide_x, guide_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[guide_x, guide_y] = Color.TEAL\n\n    # Optionally, add some random colored pixels around the grid\n    num_random_pixels = np.random.randint(0, 5)\n    for _ in range(num_random_pixels):\n        rx, ry = np.random.randint(0, n), np.random.randint(0, m)\n        if (rx, ry) != (guide_x, guide_y):\n            grid[rx, ry] = np.random.choice([c for c in Color.NOT_BLACK if c != Color.TEAL])\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, starting point, position-based transformation\n\n# description:\n# In the input you will see a grid with multiple colored objects. One of these objects is uniquely colored and serves as the \n# guide object. The task is to identify the guide object and use its position as a reference point. Starting from the guide object's \n# position, transform the grid by mirroring the objects across a vertical axis passing through the guide object's position.\n\ndef main(input_grid):\n    # Identify the guide object, which is the uniquely colored object in the grid\n    all_colors = np.unique(input_grid)\n    guide_color = [color for color in all_colors if np.sum(input_grid == color) == 1][0]\n    \n    # Find the position of the guide object\n    guide_position = np.argwhere(input_grid == guide_color)[0]\n    guide_x = guide_position[0]\n    \n    # Initialize the output grid with the same dimensions as the input grid\n    output_grid = input_grid.copy()\n    \n    # Mirror the objects across the vertical axis passing through the guide object's position\n    for row in range(input_grid.shape[0]):\n        for col in range(input_grid.shape[1]):\n            if input_grid[row, col] != Color.BLACK:\n                # Calculate the mirrored position\n                mirrored_col = 2 * guide_x - col\n                if 0 <= mirrored_col < input_grid.shape[1]:\n                    output_grid[row, mirrored_col] = input_grid[row, col]\n    \n    return output_grid\n\ndef generate_input():\n    # Define the grid size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Choose a unique color for the guide object\n    guide_color = np.random.choice(list(Color.ALL_COLORS - {Color.BLACK}))\n    \n    # Place the guide object in the grid\n    guide_x = np.random.randint(0, n)\n    guide_y = np.random.randint(0, m)\n    grid[guide_x, guide_y] = guide_color\n    \n    # Place other random colored objects in the grid\n    num_objects = np.random.randint(2, 5)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.ALL_COLORS - {Color.BLACK, guide_color}))\n        obj_sprite = random_sprite(n=2, m=2, color_palette=[obj_color], density=0.5)\n        \n        # Find a location for the sprite such that it does not overlap with other objects or the guide object\n        try:\n            x, y = random_free_location_for_sprite(grid, obj_sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, obj_sprite, x=x, y=y)\n        except ValueError:\n            continue\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, position-based transformation, mirroring\n\n# description:\n# In the input grid, you will find a guide object represented by a unique color (e.g., Color.TEAL).\n# The task is to identify this guide object and use its position to perform a transformation.\n# Specifically, reflect the entire grid across the horizontal axis that passes through the guide object's position.\n\ndef main(input_grid):\n    # Find the guide object (Color.TEAL) in the grid\n    guide_object = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=8)[0]\n    \n    # Get the position of the guide object\n    guide_x, guide_y, _, _ = bounding_box(guide_object, background=Color.BLACK)\n    \n    # Create a copy of the input grid\n    output_grid = input_grid.copy()\n    \n    # Reflect the grid across the horizontal axis through the guide object's position\n    for i in range(input_grid.shape[0]):\n        if i < guide_x:\n            output_grid[i, :] = input_grid[2 * guide_x - i, :]\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with random size\n    n, m = np.random.randint(6, 10), np.random.randint(6, 10)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Place random colored objects in the grid\n    num_objects = np.random.randint(1, 5)\n    for _ in range(num_objects):\n        color = np.random.choice([c for c in Color.ALL_COLORS if c != Color.BLACK and c != Color.TEAL])\n        sprite = random_sprite(n=np.random.randint(1, 3), m=np.random.randint(1, 3), color_palette=[color])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, sprite, x, y)\n        except:\n            continue\n    \n    # Place the guide object (Color.TEAL) at a random location\n    guide_x, guide_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[guide_x, guide_y] = Color.TEAL\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object detection, mirroring, positional transformation\n\n# description:\n# In the input grid, there is a unique guide object of a specific color. \n# If the guide object's position is in the left half of the grid, mirror the grid horizontally.\n# If the guide object's position is in the top half of the grid, mirror the grid vertically.\n\ndef main(input_grid):\n    # Detect all objects in the grid and identify the guide object\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    \n    # Assume that the guide object is the only one in a unique color\n    guide_color = next(color for color in Color.NOT_BLACK if np.any(input_grid == color))\n    guide_object = [obj for obj in objects if np.any(obj == guide_color)][0]\n    \n    # Find the position of the guide object\n    x_guide, y_guide, _, _ = bounding_box(guide_object)\n    \n    # Determine grid dimensions\n    n, m = input_grid.shape\n    \n    # Create output grid based on guide object's position\n    if x_guide < n // 2:\n        # Mirror horizontally\n        output_grid = np.fliplr(input_grid)\n    elif y_guide < m // 2:\n        # Mirror vertically\n        output_grid = np.flipud(input_grid)\n    else:\n        # If the guide object is in the bottom-right quarter, no transformation\n        output_grid = input_grid.copy()\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random size and place a unique guide object\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Define a unique color for the guide object\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Generate a random object as the guide object\n    guide_object = random_sprite(1, 1, color_palette=[guide_color])\n    \n    # Place the guide object randomly in the grid\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = guide_color\n    \n    # Add some other random objects in different colors\n    for _ in range(np.random.randint(1, 5)):\n        obj_color = np.random.choice([c for c in Color.NOT_BLACK if c != guide_color])\n        obj = random_sprite(np.random.randint(1, 3), np.random.randint(1, 3), color_palette=[obj_color])\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=obj, padding=1, padding_connectivity=8)\n            blit_sprite(grid, obj, x, y)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, mirroring, position-based transformation\n\n# description:\n# In the input, you will find a grid containing a single teal pixel, which serves as the guide object.\n# The task is to reflect the entire grid around the teal pixel's position, creating a mirrored version of the grid.\n# The output should be a mirrored grid, with the teal pixel's position acting as the axis of reflection.\n\ndef main(input_grid):\n    # Find the position of the guide object (teal pixel)\n    teal_x, teal_y = np.argwhere(input_grid == Color.TEAL)[0]\n\n    # Create the output grid by mirroring the input grid around the teal pixel's position\n    output_grid = input_grid.copy()\n    n, m = input_grid.shape\n\n    # Reflect horizontally around the teal pixel\n    for i in range(n):\n        for j in range(m):\n            # Calculate the mirrored position\n            mirrored_x = 2 * teal_x - i\n            mirrored_y = 2 * teal_y - j\n\n            # Check if the mirrored position is within bounds\n            if 0 <= mirrored_x < n and 0 <= mirrored_y < m:\n                output_grid[mirrored_x, mirrored_y] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size with random colored pixels\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n\n    # Place a single teal pixel within the grid as the guide object\n    teal_x, teal_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[teal_x, teal_y] = Color.TEAL\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, position-based transformation, spiral fill\n\n# description:\n# In the input, you will see a grid with various colored objects, including one uniquely colored \"guide\" object.\n# The goal is to identify this guide object and use its position as the starting point to fill the grid in a \n# spiral pattern with a new color, overwriting existing colors. The output grid will show this spiral pattern\n# starting from the guide object's position.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the guide object by its unique color.\n    # 2. Determine its position within the grid.\n    # 3. Generate a spiral pattern starting from the guide object's position.\n    # 4. Fill the grid with the spiral pattern using a new color.\n\n    # Step 1: Identify the guide object by its unique color\n    unique_colors = np.unique(input_grid)\n    guide_color = next(color for color in unique_colors if np.sum(input_grid == color) == 1)\n    \n    # Step 2: Determine the position of the guide object\n    guide_position = np.argwhere(input_grid == guide_color)[0]\n    guide_x, guide_y = guide_position\n\n    # Step 3: Generate a spiral pattern starting from the guide object's position\n    def generate_spiral(n, m, start_x, start_y):\n        spiral = np.full((n, m), Color.BLACK)\n        x, y = start_x, start_y\n        dx, dy = 0, 1\n\n        for _ in range(n * m):\n            if 0 <= x < n and 0 <= y < m:\n                spiral[x, y] = Color.PINK\n            if spiral[(x + dx) % n, (y + dy) % m] != Color.BLACK:\n                dx, dy = dy, -dx\n            x, y = x + dx, y + dy\n\n        return spiral\n\n    # Step 4: Fill the grid with the spiral pattern using a new color\n    n, m = input_grid.shape\n    spiral_pattern = generate_spiral(n, m, guide_x, guide_y)\n    output_grid = np.where(spiral_pattern == Color.PINK, Color.PINK, input_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with various colored objects\n    n, m = np.random.randint(6, 10), np.random.randint(6, 10)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n\n    # Select a unique color for the guide object\n    unique_guide_color = np.random.choice(list(Color.NOT_BLACK - set(grid.flatten())))\n    \n    # Place the guide object at a random position in the grid\n    guide_x, guide_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[guide_x, guide_y] = unique_guide_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, starting point, position-based transformation\n\n# description:\n# In the input grid, there is one teal-colored guide object. The task is to find this guide object and use its position as the starting point.\n# From this starting point, transform all pixels in the grid to be the color of the pixel at the mirrored position across the guide object.\n# The output should have the same dimensions as the input.\n\ndef main(input_grid):\n    # Find the teal object, which serves as the guide object\n    teal_objects = detect_objects(input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=4)\n    assert len(teal_objects) == 1, \"There should be exactly one teal guide object in the input grid\"\n    \n    # Get the position of the teal guide object\n    teal_object = teal_objects[0]\n    teal_x, teal_y, _, _ = bounding_box(teal_object, background=Color.BLACK)\n    \n    # Create a new grid for the output with the same dimensions as the input\n    output_grid = np.copy(input_grid)\n    \n    # Iterate over each pixel in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Find the mirrored position across the guide object\n            mirrored_x = 2 * teal_x - x\n            mirrored_y = 2 * teal_y - y\n\n            # Ensure mirrored positions are within bounds\n            if 0 <= mirrored_x < input_grid.shape[0] and 0 <= mirrored_y < input_grid.shape[1]:\n                # Set the color of the current position to the color of its mirrored position\n                output_grid[x, y] = input_grid[mirrored_x, mirrored_y]\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    input_grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate a random sprite to serve as the guide object, ensure it's a teal color\n    guide_sprite = np.full((1, 1), Color.TEAL)\n\n    # Place the teal guide object randomly in the grid\n    x, y = random_free_location_for_sprite(input_grid, guide_sprite, border_size=0, padding=0, background=Color.BLACK)\n    blit_sprite(input_grid, guide_sprite, x, y)\n\n    # Fill the rest of the grid with random colors\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] == Color.BLACK:\n                input_grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, position-based transformation, rotation\n\n# description:\n# In the input grid, find the guide object with a unique color. Use its position as the pivot point to rotate\n# the entire grid 90 degrees clockwise. The output grid will reflect this transformation.\n\ndef main(input_grid):\n    # Step 1: Identify the guide object\n    unique_colors = [color for color in np.unique(input_grid) if np.sum(input_grid == color) == 1]\n    assert len(unique_colors) == 1, \"There should be exactly one guide object with a unique color\"\n    guide_color = unique_colors[0]\n    \n    # Find the guide object's position\n    guide_position = np.argwhere(input_grid == guide_color)[0]\n\n    # Step 2: Rotate the grid around the guide object's position\n    output_grid = rotate_around_point(input_grid, guide_position)\n\n    return output_grid\n\ndef rotate_around_point(grid, point):\n    n, m = grid.shape\n    x, y = point\n    output_grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Rotate each pixel around the guide object's position (x, y)\n    for i in range(n):\n        for j in range(m):\n            # Calculate the new position after 90-degree clockwise rotation\n            new_x = x + (j - y)\n            new_y = y - (i - x)\n            \n            # Check bounds and assign the color\n            if 0 <= new_x < n and 0 <= new_y < m:\n                output_grid[new_x, new_y] = grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with various objects and one guide object with a unique color\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Place random objects with random colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        sprite = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=Color.NOT_BLACK - {Color.MAROON})\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue\n\n    # Add the guide object with a unique color\n    guide_color = Color.MAROON  # Assume MAROON is not used in other objects\n    while True:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = guide_color\n            break\n\n    return grid"], "seeds": ["a8c38be5.py", "137eaa0f.py", "aedd82e4.py", "48d8fb45.py", "Concepts: \nguide object, starting point, position-based transformation\n\nDescription: \nIdentify a guide object within the grid, characterized by a unique color or distinct feature. Use the position of this guide object as a starting point for a transformation or operation. The specific transformation depends on the task context but consistently originates from the guide object's location. The rest of the grid is processed based on this positional reference, ensuring a deterministic output transformation."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, tiling\n\n# description:\n# In the input grid, identify a guide object with a unique color. Use the color of this guide object to fill a designated tiling pattern (checkerboard) across the grid. The checkerboard pattern is predefined and does not alter the structure of the grid, only the color. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect the guide object by its unique color\n    unique_color_objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=8)\n    guide_object = max(unique_color_objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    guide_color = guide_object[guide_object != Color.BLACK][0]\n\n    # Create a checkerboard pattern for the output grid\n    n, m = input_grid.shape\n    checkerboard_pattern = np.zeros((n, m), dtype=int)\n\n    # Fill the checkerboard pattern with the guide color\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == 0:\n                checkerboard_pattern[i, j] = guide_color\n    \n    # Overlay the checkerboard pattern onto the input grid\n    output_grid = np.where(checkerboard_pattern != 0, checkerboard_pattern, input_grid)\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random colors\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n\n    # Place a guide object with a unique color\n    unique_color = np.random.choice(list(Color.NOT_BLACK))\n    while unique_color in grid:\n        unique_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Define the guide object as a small square (2x2) with the unique color\n    x, y = np.random.randint(0, n-2), np.random.randint(0, m-2)\n    grid[x:x+2, y:y+2] = unique_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, tiling\n\n# description:\n# In the input grid, identify a guide object with a unique color. Use the color of this guide object to fill a predefined tiling pattern across the grid.\n# The tiling pattern is a checkerboard pattern and does not alter the structure of the grid, only the coloring. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find the guide object with a unique color\n    guide_object = detect_objects(grid=input_grid, monochromatic=True, connectivity=8)[0]\n    guide_color = guide_object[guide_object != Color.BLACK][0]\n\n    output_grid = np.copy(input_grid)\n\n    # Generate a checkerboard pattern using the guide object's color\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if (x + y) % 2 == 0:\n                output_grid[x, y] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(5, 10, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Choose a unique color for the guide object\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Place a guide object with the unique color in a random location on the grid\n    guide_object = np.array([[guide_color]])\n    x, y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK)\n    blit_sprite(grid, guide_object, x=x, y=y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object detection, color transfer, tiling pattern\n\n# description:\n# In the input grid, you will see a unique colored guide object on a black background.\n# To create the output grid, use the color of this guide object to fill a predefined checkerboard pattern\n# across the entire grid. The checkerboard pattern alternates between the guide object's color and black.\n\ndef main(input_grid):\n    # Detect the unique colored guide object in the grid\n    guide_object = detect_objects(input_grid, monochromatic=True, connectivity=8, colors=Color.NOT_BLACK)[0]\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Create an output grid with the same dimensions as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Fill the grid with the checkerboard pattern using the guide object's color\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if (x + y) % 2 == 0:\n                output_grid[x, y] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(5, 10, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place a unique colored guide object in the grid\n    available_colors = list(Color.NOT_BLACK)\n    guide_color = np.random.choice(available_colors)\n\n    # Place the guide object at a random location\n    guide_x = np.random.randint(0, width)\n    guide_y = np.random.randint(0, height)\n    grid[guide_x, guide_y] = guide_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, tiling\n\n# description:\n# The input grid contains a guide object, uniquely colored, and a predefined tiling pattern.\n# The task is to use the color of the guide object to fill the tiling pattern across the grid.\n# All other grid elements remain unchanged. The tiling pattern is a checkerboard pattern that does not alter grid structure.\n\ndef main(input_grid):\n    # Detect the guide object by finding a unique color object\n    guide_objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=8)\n    guide_object = max(guide_objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Determine the color of the guide object\n    unique_colors = {color for color in np.unique(guide_object) if color != Color.BLACK}\n    guide_color = unique_colors.pop() if unique_colors else Color.BLACK\n\n    # Create an output grid initialized with the input grid\n    output_grid = np.copy(input_grid)\n\n    # Define the tiling pattern: a checkerboard pattern with size 2x2\n    n, m = input_grid.shape\n    for i in range(0, n, 2):\n        for j in range(0, m, 2):\n            if i+1 < n and j+1 < m:\n                output_grid[i, j] = guide_color\n                if i+1 < n:\n                    output_grid[i+1, j+1] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Define the grid size\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place a guide object with a unique color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_obj = np.array([[guide_color] * 3] * 2)\n    x, y = random_free_location_for_sprite(grid, guide_obj, padding=2)\n    blit_sprite(grid, guide_obj, x=x, y=y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, tiling\n\n# description:\n# In the input grid, you will see a uniquely colored guide object. \n# The task is to use the color of this guide object to fill a predefined tiling pattern across the grid.\n# The tiling pattern is a checkerboard pattern starting from the top-left corner.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find the uniquely colored object\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    guide_object = None\n    for obj in objects:\n        colors = np.unique(obj[obj != Color.BLACK])\n        if len(colors) == 1:  # Ensure it's a monochromatic object\n            guide_object = obj\n            break\n    \n    if guide_object is None:\n        raise ValueError(\"No valid guide object found\")\n\n    # Extract the color of the guide object\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Create the output grid and apply the tiling pattern\n    output_grid = np.copy(input_grid)\n    n, m = output_grid.shape\n\n    # Create a checkerboard pattern and paint it using the guide color\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == 0:  # Checkerboard condition\n                output_grid[i, j] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random background and a uniquely colored guide object\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a unique color for the guide object\n    unique_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create the guide object with the unique color\n    obj_shape = (np.random.randint(1, 3), np.random.randint(1, 3))  # Size of the guide object\n    obj_position = (np.random.randint(0, n - obj_shape[0]), np.random.randint(0, m - obj_shape[1]))\n\n    for i in range(obj_shape[0]):\n        for j in range(obj_shape[1]):\n            grid[obj_position[0] + i, obj_position[1] + j] = unique_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, tiling\n\n# description:\n# In the input grid, you will see a unique guide object of a specific color. \n# To create the output, use the color of this guide object to fill a predefined tiling pattern across the grid, \n# while leaving all other grid elements unchanged.\n\ndef main(input_grid):\n    # Detect the guide object with a unique color\n    all_objects = detect_objects(grid=input_grid, monochromatic=True)\n    guide_object = max(all_objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Define a tiling pattern: a checkerboard pattern\n    pattern_size = 2\n    output_grid = input_grid.copy()\n\n    # Fill the grid with the tiling pattern using the guide object's color\n    for x in range(0, output_grid.shape[0], pattern_size):\n        for y in range(0, output_grid.shape[1], pattern_size):\n            if (x // pattern_size + y // pattern_size) % 2 == 0:\n                for i in range(pattern_size):\n                    for j in range(pattern_size):\n                        if x + i < output_grid.shape[0] and y + j < output_grid.shape[1]:\n                            output_grid[x + i, y + j] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid of size n x m\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a guide object with a unique color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_object = np.array([[guide_color, guide_color], [guide_color, guide_color]])\n\n    # Place the guide object randomly in the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK)\n    blit_sprite(grid, guide_object, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, tiling\n\n# description:\n# In the input grid, there is a unique guide object with a distinct color among the other objects.\n# To create the output grid, you will use the color of this guide object to fill a predefined tiling pattern \n# across the grid. The pattern remains fixed structurally but adopts the color of the guide object. \n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all objects in the grid with any color except black\n    objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=8)\n\n    # Identify the guide object by its unique color\n    unique_color = None\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])\n        if len(color) == 1:\n            unique_color = color[0]\n            break\n\n    if unique_color is None:\n        raise ValueError(\"No unique guide object found\")\n\n    # Define the tiling pattern\n    # For example, a diagonal stripe pattern\n    pattern = np.array([\n        [1, 0, 0, 1],\n        [0, 1, 1, 0],\n        [0, 1, 1, 0],\n        [1, 0, 0, 1]\n    ])\n\n    # Create the output grid by copying the input grid\n    output_grid = input_grid.copy()\n\n    # Apply the tiling pattern across the grid using the unique color\n    for i in range(0, output_grid.shape[0], pattern.shape[0]):\n        for j in range(0, output_grid.shape[1], pattern.shape[1]):\n            for x in range(pattern.shape[0]):\n                for y in range(pattern.shape[1]):\n                    if pattern[x, y] == 1:\n                        if i + x < output_grid.shape[0] and j + y < output_grid.shape[1]:\n                            output_grid[i + x, j + y] = unique_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate other objects in the grid with different colors\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        obj = np.full((np.random.randint(1, 3), np.random.randint(1, 3)), obj_color)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1, border_size=1)\n            blit_sprite(grid, obj, x=x, y=y)\n        except ValueError:\n            continue\n\n    # Create the unique guide object with a distinct color\n    guide_color = np.random.choice(list(Color.NOT_BLACK - {obj_color}))\n    guide_obj = np.full((2, 2), guide_color)\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_obj, padding=1, border_size=1)\n        blit_sprite(grid, guide_obj, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, tiling\n\n# description:\n# In the input grid, you will see various objects, each with a unique color. One of these objects acts as a guide object and has a color that is unique in the grid.\n# The task is to identify this guide object and use its color to fill a predefined tiling pattern across the grid.\n# The tiling pattern is a checkerboard pattern that only changes the color of the cells within the pattern, leaving other grid elements unchanged.\n\ndef main(input_grid):\n    # Step 1: Identify the guide object with a unique color\n    unique_colors = set(np.unique(input_grid)).intersection(Color.NOT_BLACK)\n    guide_color = None\n\n    for color in unique_colors:\n        objects_of_color = detect_objects(grid=input_grid, colors=[color], monochromatic=True)\n        if len(objects_of_color) == 1:\n            guide_color = color\n            break\n\n    if guide_color is None:\n        raise ValueError(\"No guide object found with a unique color\")\n\n    # Step 2: Apply the checkerboard pattern using the guide object's color\n    output_grid = input_grid.copy()\n    n, m = output_grid.shape\n    checkerboard_pattern = np.zeros((n, m), dtype=int)\n\n    # Create a checkerboard pattern\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == 0:\n                checkerboard_pattern[i, j] = guide_color\n\n    # Apply the pattern to the output grid\n    output_grid[checkerboard_pattern != 0] = checkerboard_pattern[checkerboard_pattern != 0]\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Generate a grid with random objects of various colors\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Step 2: Create several random objects with random colors\n    available_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(available_colors)\n\n    # Randomly choose a guide color\n    guide_color = available_colors.pop()\n\n    # Add objects of random colors\n    for color in available_colors[:3]:\n        obj_size = np.random.randint(2, 4, size=2)\n        obj = np.full(obj_size, color)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x=x, y=y)\n        except ValueError:\n            continue\n\n    # Add the guide object with a unique color\n    guide_obj_size = np.random.randint(2, 3, size=2)\n    guide_obj = np.full(guide_obj_size, guide_color)\n    try:\n        x, y = random_free_location_for_sprite(grid, guide_obj, padding=1)\n        blit_sprite(grid, guide_obj, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    return grid"], "seeds": ["995c5fa3.py", "aedd82e4.py", "810b9b61.py", "db3e9e38.py", "Concepts: \nguide object, color transfer, tiling\n\nDescription: \nIdentify a guide object with a unique color in the grid. Use the color of this guide object to fill a designated tiling area or pattern across the grid. The tiling pattern is predefined and does not alter the structure of the grid, only the color. All other grid elements remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# The input consists of a guide object with enclosed holes and a separate target object. Identify interior holes within the guide object (regions not connected to the border).\n# Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels.\n# Continue filling until all holes are filled or no more legal placements are possible. The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Detect the guide object\n    guide_objects = detect_objects(grid=input_grid, colors=Color.ALL_COLORS, monochromatic=False, connectivity=4)\n    assert len(guide_objects) == 1, \"There should be exactly one guide object\"\n    guide_object = guide_objects[0]\n\n    # Detect the target object\n    target_objects = detect_objects(grid=input_grid, colors=Color.ALL_COLORS, monochromatic=False, connectivity=4)\n    assert len(target_objects) == 2, \"There should be exactly one guide and one target object\"\n    target_object = target_objects[1]\n\n    # Identify interior holes in the guide object\n    interior_mask = object_interior(guide_object)\n    guide_mask = (guide_object != Color.BLACK)\n    holes_mask = interior_mask & ~guide_mask\n\n    output_grid = input_grid.copy()\n\n    # Fill holes using the target object\n    for x, y in np.argwhere(holes_mask):\n        try:\n            blit_sprite(output_grid, target_object, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no legal placement is possible\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    width = np.random.randint(12, 20)\n    height = np.random.randint(12, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a guide object with enclosed holes\n    guide_width = np.random.randint(6, min(width, 10))\n    guide_height = np.random.randint(6, min(height, 10))\n    guide_object = np.full((guide_width, guide_height), np.random.choice(list(Color.NOT_BLACK)))\n\n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, min(guide_width, guide_height) // 2)\n        hole_x = np.random.randint(1, guide_width - hole_size - 1)\n        hole_y = np.random.randint(1, guide_height - hole_size - 1)\n        guide_object[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Blit the guide object onto the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y)\n\n    # Create a target object\n    target_size = np.random.randint(1, 3)\n    target_object = random_sprite(target_size, target_size, color_palette=list(Color.NOT_BLACK), background=Color.BLACK)\n\n    # Blit the target object onto the grid in a random location\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, target_x, target_y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# The input consists of a guide object with enclosed holes and a separate target object. Identify interior holes within the guide object (regions not connected to the border).\n# Fill these holes using the target object by fitting its pixels into the hole geometry without overlapping existing non-background pixels.\n# Continue filling until all holes are filled or no more legal placements are possible. The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Detect the guide and target objects\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=8)\n    \n    # Assume the first object is the guide and the second is the target\n    guide = objects[0]\n    target = objects[1]\n\n    # Create a copy of the input grid for the output\n    output_grid = input_grid.copy()\n\n    # Find the interior holes in the guide object\n    interior_mask = object_interior(guide, background=Color.BLACK)\n    guide_mask = guide != Color.BLACK\n    holes_mask = interior_mask & ~guide_mask\n\n    # Extract the bounding box for the guide object\n    guide_x, guide_y, guide_width, guide_height = bounding_box(guide)\n\n    # Create a cropped version of the guide to work with\n    cropped_guide = crop(guide, background=Color.BLACK)\n\n    # Fill the holes using the target object\n    def fill_holes(cropped_guide, target):\n        target_sprite = crop(target, background=Color.BLACK)\n        for x, y in np.argwhere(holes_mask):\n            x_offset = x - guide_x\n            y_offset = y - guide_y\n            try:\n                # Check if the target can fit in the current hole without overlapping\n                if np.all((cropped_guide[x_offset:x_offset + target_sprite.shape[0], y_offset:y_offset + target_sprite.shape[1]] == Color.BLACK) | (target_sprite == Color.BLACK)):\n                    blit_sprite(cropped_guide, target_sprite, x_offset, y_offset, background=Color.BLACK)\n            except ValueError:\n                # If placement is not possible, continue to next hole\n                continue\n\n    fill_holes(cropped_guide, target)\n\n    # Blit the updated guide back to the output grid\n    blit_sprite(output_grid, cropped_guide, guide_x, guide_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random size grid\n    grid_size = np.random.randint(15, 25)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a random guide object with enclosed holes\n    guide_size = np.random.randint(10, 15)\n    guide = random_sprite(guide_size, guide_size, density=0.6, color_palette=[Color.GREY], background=Color.BLACK)\n\n    # Create holes inside the guide\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 5)\n        hole = random_sprite(hole_size, hole_size, density=0.8, color_palette=[Color.BLACK], background=Color.GREY)\n        hole_x, hole_y = np.random.randint(1, guide_size - hole_size, size=2)\n        guide[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = hole\n\n    # Blit the guide object onto the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide, padding=1)\n    blit_sprite(grid, guide, guide_x, guide_y, background=Color.BLACK)\n\n    # Generate a random target object\n    target_size = np.random.randint(2, 4)\n    target = random_sprite(target_size, target_size, density=0.7, color_palette=[Color.RED], background=Color.BLACK)\n\n    # Blit the target object onto the grid at a random free location\n    target_x, target_y = random_free_location_for_sprite(grid, target, padding=1)\n    blit_sprite(grid, target, target_x, target_y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# The input consists of a guide object with enclosed holes and a separate target object. \n# Identify interior holes within the guide object (regions not connected to the border). \n# Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels. \n# Continue filling until all holes are filled or no more legal placements are possible. \n# The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Separate the guide object and the target object\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    target_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Find the interior holes of the guide object\n    guide_interior = object_interior(guide_object)\n\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Try to fill the holes with the target object\n    for x, y in np.argwhere(guide_interior):\n        # Check if the target object can be placed at this position\n        try:\n            blit_sprite(output_grid, target_object, x, y, background=Color.BLACK)\n            # Check for overlaps\n            if np.any((output_grid != input_grid) & (input_grid != Color.BLACK)):\n                # Revert blit if overlap occurs\n                blit_sprite(output_grid, np.full(target_object.shape, Color.BLACK), x, y, background=Color.BLACK)\n        except ValueError:\n            # If placement isn't possible, continue to the next position\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Create grid size\n    size = np.random.randint(12, 20)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Generate a guide object with holes\n    guide_size = np.random.randint(8, 12)\n    guide_obj = np.full((guide_size, guide_size), Color.BLUE)\n    guide_obj[1:-1, 1:-1] = Color.BLACK\n\n    # Create holes inside the guide object\n    num_holes = np.random.randint(1, 3)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 4)\n        hole_x, hole_y = np.random.randint(1, guide_size - hole_size - 1), np.random.randint(1, guide_size - hole_size - 1)\n        guide_obj[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Place the guide object on the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_obj, padding=1)\n    blit_sprite(grid, guide_obj, guide_x, guide_y, background=Color.BLACK)\n\n    # Generate a target object\n    target_size = np.random.randint(2, 4)\n    target_obj = random_sprite(target_size, target_size, color_palette=[Color.RED, Color.YELLOW], background=Color.BLACK)\n\n    # Place the target object randomly on the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_obj, padding=1)\n    blit_sprite(grid, target_obj, target_x, target_y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# The input consists of a guide object with enclosed holes and a separate target object. The goal is to fill the interior holes within the guide object using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels. The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Detect the guide object and the target object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    \n    # Assuming the larger object is the guide and the smaller one is the target\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    target_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    output_grid = input_grid.copy()\n    \n    # Identify the interior holes within the guide object\n    guide_interior_mask = object_interior(guide_object, background=Color.BLACK)\n    holes_mask = guide_interior_mask & (guide_object == Color.BLACK)\n\n    # Try to fill each hole with the target object\n    for x, y in np.argwhere(holes_mask):\n        try:\n            # Attempt to place the target object at this hole position\n            blit_sprite(output_grid, target_object, x, y, background=Color.BLACK)\n            # Update the hole mask to prevent overlap\n            holes_mask[x:x+target_object.shape[0], y:y+target_object.shape[1]] = False\n        except ValueError:\n            # If placement is not possible, continue with the next position\n            continue\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a guide object and a target object\n    width, height = np.random.randint(12, 16), np.random.randint(12, 16)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate a guide object with enclosed holes\n    guide_object = random_sprite(width-4, height-4, color_palette=[Color.BLUE], background=Color.BLACK)\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=2)\n    blit_sprite(grid, guide_object, guide_x, guide_y)\n\n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 4)\n        hole_x, hole_y = np.random.randint(1, guide_object.shape[0]-hole_size), np.random.randint(1, guide_object.shape[1]-hole_size)\n        guide_object[hole_x:hole_x+hole_size, hole_y:hole_y+hole_size] = Color.BLACK\n\n    # Blit the guide object back with holes\n    blit_sprite(grid, guide_object, guide_x, guide_y)\n\n    # Generate a target object\n    target_size = np.random.randint(2, 4)\n    target_object = random_sprite(target_size, target_size, color_palette=[Color.RED], background=Color.BLACK)\n\n    # Place the target object separately on the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=2, border_size=1)\n    blit_sprite(grid, target_object, target_x, target_y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# Input consists of a guide object with enclosed holes and a separate target object. Identify interior holes within the guide object (regions not connected to the border).\n# Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels. \n# Continue filling until all holes are filled or no more legal placements are possible. The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Detect the guide object and the target object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    guide_object, target_object = None, None\n    \n    for obj in objects:\n        colors = object_colors(obj, background=Color.BLACK)\n        if len(colors) > 1:  # Assume the guide object has multiple colors\n            guide_object = obj\n        else:\n            target_object = obj\n\n    # Get the interior holes in the guide object\n    guide_interior_mask = object_interior(guide_object, background=Color.BLACK)\n    holes = find_connected_components(guide_interior_mask, background=False, connectivity=4)\n\n    output_grid = input_grid.copy()\n    \n    for hole in holes:\n        hole_bbox = bounding_box(hole, background=False)\n        hole_region = np.zeros_like(output_grid)\n        hole_region[hole_bbox[1]:hole_bbox[1]+hole_bbox[3], hole_bbox[0]:hole_bbox[0]+hole_bbox[2]] = hole\n        \n        # Try to fit the target object in the hole\n        try:\n            x, y = random_free_location_for_sprite(hole_region, target_object, background=Color.BLACK, padding=0)\n            blit_sprite(output_grid, target_object, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no fitting position is found, skip this hole\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Create a guide object with random enclosed holes\n    guide_size = np.random.randint(10, 15)\n    guide_object = np.full((guide_size, guide_size), np.random.choice(list(Color.NOT_BLACK)))\n\n    # Carve out holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 5)\n        hole_x = np.random.randint(1, guide_size - hole_size)\n        hole_y = np.random.randint(1, guide_size - hole_size)\n        guide_object[hole_x:hole_x+hole_size, hole_y:hole_y+hole_size] = Color.BLACK\n\n    # Place the guide object in the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y)\n\n    # Create a target object\n    target_size = np.random.randint(2, 4)\n    target_object = random_sprite(target_size, target_size, density=0.5, color_palette=[np.random.choice(list(Color.NOT_BLACK))])\n\n    # Place the target object in a separate area of the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, target_x, target_y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# The input consists of a guide object with enclosed holes and a separate target object.\n# The goal is to fill the interior holes within the guide object (regions not connected to the border) with the target object.\n# The target object should be fitted into the hole geometry without overlapping existing non-background pixels.\n# Filling continues until all holes are filled or no more legal placements are possible.\n# The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Extract the guide object and target object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))  # Assume largest object is the guide\n    target_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))  # Assume smallest object is the target\n\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Find the interior holes in the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    holes = np.argwhere(interior_mask & (guide_object == Color.BLACK))\n\n    # Attempt to fill each hole with the target object\n    for x, y in holes:\n        try:\n            # Try to place the target object at this hole location\n            blit_sprite(output_grid, target_object, x, y, background=Color.BLACK)\n            # If blit is successful, mark this hole as filled\n            for i in range(target_object.shape[0]):\n                for j in range(target_object.shape[1]):\n                    if target_object[i, j] != Color.BLACK:\n                        interior_mask[x+i, y+j] = False\n        except ValueError:\n            # If placement isn't possible, move to the next hole\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random size\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a guide object with enclosed holes\n    guide_object = random_sprite(np.random.randint(5, 10), np.random.randint(5, 10), density=0.8, color_palette=[Color.BLUE], background=Color.BLACK)\n    guide_object = np.pad(guide_object, 2, constant_values=Color.BLACK)  # Pad to ensure it's fully enclosed\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, x, y)\n\n    # Create a target object\n    target_object = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), density=0.5, color_palette=[Color.RED], background=Color.BLACK)\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# Input consists of a guide object with enclosed holes and a separate target object. Identify interior holes within the guide object (regions not connected to the border).\n# Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels.\n# Continue filling until all holes are filled or no more legal placements are possible. \n# The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the guide object and target object from the input grid\n    # 2. Identify holes in the guide object\n    # 3. Try to fill each hole with the target object without overlapping\n    # 4. Create the output grid with holes filled with target object pixels\n\n    # 1. Detect the guide object and target object\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))  # Assume the largest object is the guide\n    target_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))  # Assume the smallest is the target\n\n    # 2. Identify interior holes within the guide\n    guide_interior = object_interior(guide_object)\n    guide_holes = np.logical_and(guide_interior, guide_object == Color.BLACK)\n\n    # 3. Try to fill each hole with the target object\n    output_grid = input_grid.copy()\n    hole_locations = np.argwhere(guide_holes)\n    for x, y in hole_locations:\n        # Attempt to place the target object at each hole location\n        try:\n            blit_sprite(output_grid, target_object, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Create a random size grid\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate the guide object with random holes\n    guide_width = np.random.randint(6, min(width, 10))\n    guide_height = np.random.randint(6, min(height, 10))\n    guide_object = np.full((guide_width, guide_height), Color.GREY)\n\n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, 3)\n        hole_x = np.random.randint(1, guide_width - hole_size)\n        hole_y = np.random.randint(1, guide_height - hole_size)\n        guide_object[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Place the guide object onto the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK)\n    blit_sprite(grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n\n    # Generate the target object\n    target_width = np.random.randint(1, 3)\n    target_height = np.random.randint(1, 3)\n    target_object = random_sprite(target_width, target_height, color_palette=[Color.RED], background=Color.BLACK)\n\n    # Place the target object separately in the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, target_object, target_x, target_y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# hole filling, guide object, target object, enclosed regions, non-overlapping placement\n\n# description:\n# The input consists of a grid with a guide object that has enclosed holes and a separate target object.\n# The task is to identify interior holes within the guide object (regions not connected to the border).\n# Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels.\n# Continue filling until all holes are filled or no more legal placements are possible.\n# The output grid shows previously empty regions inside the guide object filled with the target object's pixels.\n\ndef main(input_grid):\n    # Step 1: Identify the guide object and the target object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    \n    # Assume the largest object is the guide object and the second largest is the target object\n    objects = sorted(objects, key=lambda obj: np.count_nonzero(obj != Color.BLACK), reverse=True)\n    guide_object = objects[0]\n    target_object = objects[1]\n\n    # Step 2: Find the interior holes in the guide object\n    guide_interior = object_interior(guide_object, background=Color.BLACK)\n    hole_mask = (guide_interior) & (guide_object == Color.BLACK)\n\n    # Create an output grid from the input grid\n    output_grid = input_grid.copy()\n\n    # Step 3: Fill the holes with the target object\n    # Extract the target sprite\n    target_sprite = crop(target_object, background=Color.BLACK)\n\n    # Try to fill each hole by randomly placing the target sprite\n    for x, y in np.argwhere(hole_mask):\n        try:\n            # Attempt to place the target sprite at this hole position\n            blit_sprite(output_grid, target_sprite, x, y, background=Color.BLACK)\n            # Update the hole mask to remove filled region\n            filled_region = (output_grid != Color.BLACK) & hole_mask\n            hole_mask[filled_region] = False\n        except ValueError:\n            # If placement fails, continue to the next hole\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random size\n    width = np.random.randint(12, 20)\n    height = np.random.randint(12, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a guide object, a large hollow shape\n    guide_width = np.random.randint(8, min(width, height))\n    guide_height = np.random.randint(8, min(width, height))\n    guide_object = np.full((guide_width, guide_height), Color.BLUE)\n\n    # Cut out a few random holes inside the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_width = np.random.randint(2, guide_width // 2)\n        hole_height = np.random.randint(2, guide_height // 2)\n        hole_x = np.random.randint(1, guide_width - hole_width - 1)\n        hole_y = np.random.randint(1, guide_height - hole_height - 1)\n        guide_object[hole_x:hole_x + hole_width, hole_y:hole_y + hole_height] = Color.BLACK\n\n    # Place the guide object on the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n\n    # Create a target object, a small random shape\n    target_width = np.random.randint(2, 4)\n    target_height = np.random.randint(2, 4)\n    target_object = random_sprite(target_width, target_height, color_palette=[Color.ORANGE], background=Color.BLACK)\n\n    # Place the target object randomly on the grid, separate from the guide object\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, target_x, target_y, background=Color.BLACK)\n\n    return grid"], "seeds": ["44d8ac46.py", "444801d8.py", "810b9b61.py", "aba27056.py", "Concepts: \nhole filling, guide object, target object, enclosed regions, non-overlapping placement\n\nDescription: \nInput consists of a guide object with enclosed holes and a separate target object. Identify interior holes within the guide object (regions not connected to the border). Fill these holes using the target object by fitting its pixels or blocks into the hole geometry without overlapping existing non-background pixels. Continue filling until all holes are filled or no more legal placements are possible. The output grid shows previously empty regions inside the guide object filled with the target object's pixels."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input consists of a grid with a single object enclosing empty spaces (holes). Identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border. Use flood-fill from the border to exclude non-enclosed regions. Output the grid with holes marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create an output grid based on the input grid\n    output_grid = input_grid.copy()\n\n    # Use flood-fill to mark non-enclosed regions connected to the border\n    non_enclosed_mask = object_interior(output_grid, background=Color.BLACK)\n\n    # Find all empty regions in the grid\n    empty_regions = find_connected_components(output_grid, background=Color.BLACK, connectivity=4)\n\n    # Identify and fill holes\n    for region in empty_regions:\n        region_mask = (region != Color.BLACK)\n        \n        # Check if the region is touching the border using non_enclosed_mask\n        touching_border = np.any(non_enclosed_mask & region_mask)\n        \n        if not touching_border:\n            # It is a hole, fill it with a specific color (e.g., Color.RED)\n            region[region_mask] = Color.RED\n            blit_object(output_grid, region, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size between 10x10 and 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a single large object enclosing empty spaces\n    enclosing_object_size = np.random.randint(6, min(n, 12))\n    enclosing_object = np.full((enclosing_object_size, enclosing_object_size), Color.BLUE)\n    enclosing_object[1:-1, 1:-1] = Color.BLACK  # Making the object hollow\n\n    # Place the enclosing object in the grid\n    x, y = random_free_location_for_sprite(grid, enclosing_object, padding=1)\n    blit_sprite(grid, enclosing_object, x, y)\n\n    # Optionally, create random shapes inside the object to act as obstructions\n    for _ in range(np.random.randint(1, 4)):\n        obstruction_size = np.random.randint(2, enclosing_object_size // 2)\n        obstruction = random_sprite(obstruction_size, obstruction_size, color_palette=[Color.GREEN], background=Color.BLACK)\n        try:\n            x_obs, y_obs = random_free_location_for_sprite(grid, obstruction, padding=0)\n            blit_sprite(grid, obstruction, x_obs, y_obs)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input grid contains a single object of a random color that encloses empty spaces (holes). These holes are regions of the background color (0) that are fully enclosed by the object and do not touch the grid's border. \n# The task is to identify these enclosed holes and fill them with a specified target color. The output grid should preserve the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create a copy of the input grid to serve as the output grid\n    output_grid = input_grid.copy()\n\n    # Get the background color\n    background_color = Color.BLACK\n\n    # Identify all connected components in the grid\n    components = find_connected_components(input_grid, background=background_color, connectivity=8)\n\n    # Determine the target color to fill holes with\n    target_color = Color.RED\n\n    # Flood fill from the border to exclude non-enclosed regions\n    border_filled = np.zeros_like(input_grid, dtype=bool)\n    for i in range(input_grid.shape[0]):\n        if input_grid[i, 0] == background_color:\n            flood_fill(border_filled, input_grid, i, 0, background_color)\n        if input_grid[i, -1] == background_color:\n            flood_fill(border_filled, input_grid, i, input_grid.shape[1] - 1, background_color)\n    for j in range(input_grid.shape[1]):\n        if input_grid[0, j] == background_color:\n            flood_fill(border_filled, input_grid, 0, j, background_color)\n        if input_grid[-1, j] == background_color:\n            flood_fill(border_filled, input_grid, input_grid.shape[0] - 1, j, background_color)\n\n    # Fill the enclosed holes with the target color\n    for component in components:\n        if np.all(component != border_filled):\n            # The component is fully enclosed and not touching the border\n            output_grid[component == background_color] = target_color\n\n    return output_grid\n\n\ndef flood_fill(filled, grid, x, y, target_color):\n    if filled[x, y] or grid[x, y] != target_color:\n        return\n    filled[x, y] = True\n    if x > 0:\n        flood_fill(filled, grid, x - 1, y, target_color)\n    if x < grid.shape[0] - 1:\n        flood_fill(filled, grid, x + 1, y, target_color)\n    if y > 0:\n        flood_fill(filled, grid, x, y - 1, target_color)\n    if y < grid.shape[1] - 1:\n        flood_fill(filled, grid, x, y + 1, target_color)\n\n\ndef generate_input():\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a random colored enclosing object\n    enclosing_color = np.random.choice(list(Color.ALL_COLORS - {Color.BLACK}))\n    enclosing_object = random_sprite(n - 4, n - 4, color_palette=[enclosing_color], connectivity=8)\n\n    # Ensure the object is hollow by marking interior as black\n    interior_mask = object_interior(enclosing_object)\n    enclosing_object[interior_mask] = Color.BLACK\n\n    # Place the enclosing object randomly within the grid\n    x, y = random_free_location_for_sprite(grid, enclosing_object, border_size=2)\n    blit_sprite(grid, enclosing_object, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input grid contains a single object that can enclose empty spaces (holes). \n# The task is to identify holes, which are regions of background-color (0) that are fully enclosed by the object and not touching the grid border. \n# Use flood-fill from the border to exclude non-enclosed regions. \n# The output is the grid where the holes are marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create a copy of the input grid to use as the output grid\n    output_grid = input_grid.copy()\n\n    # Use flood-fill from the border to mark all regions connected to the border\n    border_filled = flood_fill_from_border(input_grid)\n\n    # Find the holes by identifying regions that are not part of the border-flooded area and are background\n    holes = (input_grid == Color.BLACK) & ~border_filled\n\n    # Fill the holes with a target color, e.g., Color.RED\n    output_grid[holes] = Color.RED\n\n    return output_grid\n\ndef flood_fill_from_border(grid):\n    # Initialize a mask for the border-flooded areas\n    # Start with a mask of False (background)\n    border_filled = np.zeros(grid.shape, dtype=bool)\n\n    # Flood-fill from each edge of the grid\n    for x in range(grid.shape[0]):\n        flood_fill(grid, border_filled, x, 0)\n        flood_fill(grid, border_filled, x, grid.shape[1] - 1)\n\n    for y in range(grid.shape[1]):\n        flood_fill(grid, border_filled, 0, y)\n        flood_fill(grid, border_filled, grid.shape[0] - 1, y)\n\n    return border_filled\n\ndef flood_fill(grid, mask, x, y):\n    # If the pixel is out of bounds or already filled or not background, return\n    if not (0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]):\n        return\n    if mask[x, y] or grid[x, y] != Color.BLACK:\n        return\n\n    # Mark the current pixel as filled\n    mask[x, y] = True\n\n    # Recurse in all 4 directions (up, down, left, right)\n    flood_fill(grid, mask, x + 1, y)\n    flood_fill(grid, mask, x - 1, y)\n    flood_fill(grid, mask, x, y + 1)\n    flood_fill(grid, mask, x, y - 1)\n\ndef generate_input():\n    # Create a grid of size 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate a single large object with potential holes\n    object_height = np.random.randint(5, n - 3)\n    object_width = np.random.randint(5, n - 3)\n    object_x = np.random.randint(1, n - object_height - 1)\n    object_y = np.random.randint(1, n - object_width - 1)\n\n    object_grid = np.full((object_height, object_width), np.random.choice(Color.NOT_BLACK))\n    grid[object_x:object_x + object_height, object_y:object_y + object_width] = object_grid\n\n    # Create random enclosed holes within the object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_height = np.random.randint(1, object_height - 2)\n        hole_width = np.random.randint(1, object_width - 2)\n        hole_x = np.random.randint(object_x + 1, object_x + object_height - hole_height - 1)\n        hole_y = np.random.randint(object_y + 1, object_y + object_width - hole_width - 1)\n        grid[hole_x:hole_x + hole_height, hole_y:hole_y + hole_width] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# Input consists of a grid with a single object enclosing empty spaces (holes). Identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border.\n# Use flood-fill from the border to exclude non-enclosed regions. Output the grid with holes marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = input_grid.copy()\n\n    # Flood fill from the border to mark non-enclosed regions\n    border_mask = np.zeros_like(input_grid, dtype=bool)\n    flood_fill_from_border(input_grid, border_mask)\n\n    # Identify all connected components of background color\n    holes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Fill enclosed holes with a target color, e.g., red\n    for hole in holes:\n        if is_enclosed(hole, border_mask):\n            hole[hole == Color.BLACK] = Color.RED\n            blit_object(output_grid, hole, background=Color.BLACK)\n\n    return output_grid\n\ndef flood_fill_from_border(grid, mask):\n    h, w = grid.shape\n    queue = []\n\n    # Add border positions to the queue\n    for x in range(h):\n        if grid[x, 0] == Color.BLACK:\n            queue.append((x, 0))\n        if grid[x, w-1] == Color.BLACK:\n            queue.append((x, w-1))\n    for y in range(w):\n        if grid[0, y] == Color.BLACK:\n            queue.append((0, y))\n        if grid[h-1, y] == Color.BLACK:\n            queue.append((h-1, y))\n\n    # Perform flood fill\n    while queue:\n        x, y = queue.pop(0)\n        if not (0 <= x < h and 0 <= y < w) or grid[x, y] != Color.BLACK or mask[x, y]:\n            continue\n        mask[x, y] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            queue.append((x + dx, y + dy))\n\ndef is_enclosed(hole, border_mask):\n    # If any part of the hole touches the border, it is not enclosed\n    for x, y in np.argwhere(hole):\n        if border_mask[x, y]:\n            return False\n    return True\n\ndef generate_input():\n    # Create a grid with a single object enclosing empty spaces\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create an outer object\n    outer_object = random_sprite(n=grid_size-2, m=grid_size-2, density=0.8, color_palette=[Color.BLUE], background=Color.BLACK)\n    grid[1:-1, 1:-1] = outer_object\n\n    # Randomly create enclosed holes\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 4)\n        hole = random_sprite(n=hole_size, m=hole_size, density=0.5, color_palette=[Color.BLACK], background=Color.BLUE)\n        try:\n            x, y = random_free_location_for_sprite(grid, hole, border_size=1, background=Color.BLUE, padding=1)\n            blit_sprite(grid, hole, x, y, background=Color.BLUE)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input is a grid with a single object that encloses empty spaces (holes). The task is to identify the holes as regions of the background color (0)\n# that are fully enclosed by the object and do not touch the grid border. Using a flood-fill algorithm from the border, we exclude non-enclosed regions.\n# The output should be the grid with these holes filled by a target color, while preserving the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on.\n    output_grid = input_grid.copy()\n\n    # Use flood-fill from the edges to mark regions that are not holes.\n    flood_fill_from_edges(output_grid)\n\n    # Find the connected components that are still marked as the background color.\n    holes = find_connected_components(output_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Fill these regions with the target color, e.g., Color.RED.\n    target_color = Color.RED\n    for hole in holes:\n        if is_completely_enclosed(hole, input_grid.shape):\n            fill_hole(hole, target_color)\n            blit_object(output_grid, hole, background=Color.BLACK)\n\n    return output_grid\n\ndef flood_fill_from_edges(grid):\n    # Start flood-fill from each edge of the grid to mark non-enclosed regions.\n    for x in range(grid.shape[0]):\n        if grid[x, 0] == Color.BLACK:\n            flood_fill(grid, x, 0)\n        if grid[x, grid.shape[1] - 1] == Color.BLACK:\n            flood_fill(grid, x, grid.shape[1] - 1)\n    for y in range(grid.shape[1]):\n        if grid[0, y] == Color.BLACK:\n            flood_fill(grid, 0, y)\n        if grid[grid.shape[0] - 1, y] == Color.BLACK:\n            flood_fill(grid, grid.shape[0] - 1, y)\n\ndef flood_fill(grid, x, y):\n    # Perform flood-fill from (x, y) marking visited cells with a special marker.\n    stack = [(x, y)]\n    while stack:\n        cx, cy = stack.pop()\n        if 0 <= cx < grid.shape[0] and 0 <= cy < grid.shape[1] and grid[cx, cy] == Color.BLACK:\n            grid[cx, cy] = -1  # Use a special marker for visited cells\n            stack.extend([(cx + dx, cy + dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]])\n\ndef is_completely_enclosed(component, grid_shape):\n    # Check if the component does not touch the edges of the grid.\n    for (x, y) in np.argwhere(component):\n        if x == 0 or y == 0 or x == grid_shape[0] - 1 or y == grid_shape[1] - 1:\n            return False\n    return True\n\ndef fill_hole(hole, color):\n    # Fill the hole with the specified color.\n    hole[hole != Color.BLACK] = color\n\ndef generate_input():\n    # Create a grid with a single enclosing object and random holes.\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create an enclosing object.\n    enclosing_object = random_sprite(n-2, n-2, color_palette=[Color.BLUE], connectivity=8)\n    x, y = random_free_location_for_sprite(grid, enclosing_object, border_size=1)\n    blit_sprite(grid, enclosing_object, x, y)\n\n    # Create random holes inside the enclosing object.\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 4)\n        hole = np.full((hole_size, hole_size), Color.BLACK)\n        hx, hy = random_free_location_for_sprite(enclosing_object, hole, padding=1, background=Color.BLUE)\n        blit_sprite(enclosing_object, hole, hx, hy)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input grid contains a single object, which is a contiguous region of non-background color, that may fully enclose areas of background color (holes).\n# The transformation involves identifying these holes, which are regions of background color fully enclosed by the object, and not touching the grid border.\n# The output grid should have these holes marked or filled by a target color, preserving the enclosing object and any other non-hole regions.\n\ndef main(input_grid):\n    # Identify all connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    output_grid = input_grid.copy()\n\n    # Assume there's only one main object in the grid\n    main_object = objects[0]\n    interior_mask = object_interior(main_object, background=Color.BLACK)\n    boundary_mask = object_boundary(main_object, background=Color.BLACK)\n    holes = interior_mask & ~boundary_mask\n\n    # Fill the holes with the target color, e.g., Color.RED\n    for x, y in np.argwhere(holes):\n        output_grid[x, y] = Color.RED\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 15x15 with a single object enclosing potential holes\n    grid_size = 15\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Generate a random object with potential holes\n    obj_size = np.random.randint(5, 10)\n    object_sprite = random_sprite(obj_size, obj_size, color_palette=[Color.TEAL], connectivity=8)\n    interior_mask = object_interior(object_sprite, background=Color.BLACK)\n    boundary_mask = object_boundary(object_sprite, background=Color.BLACK)\n    interior_but_not_edges = interior_mask & ~boundary_mask\n    object_sprite[interior_but_not_edges] = np.random.choice([Color.BLACK, Color.TEAL], p=[0.3, 0.7])\n\n    # Place the object on the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, object_sprite, border_size=1, padding=1)\n    except ValueError:\n        return generate_input()  # Retry if no suitable location\n\n    blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input is a grid with a single object enclosing empty spaces (holes). \n# The task is to identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border.\n# Use flood-fill from the border to exclude non-enclosed regions. \n# The output is the grid where holes are filled with a target color, preserving the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create an output grid copying the input grid to retain the structure\n    output_grid = input_grid.copy()\n\n    # Identify all connected components using the background color (0)\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n\n    # Flood-fill from the border to exclude non-enclosed regions\n    border_filled = np.full(input_grid.shape, False)\n    for i in range(input_grid.shape[0]):\n        if input_grid[i, 0] == Color.BLACK:\n            flood_fill(input_grid, border_filled, i, 0)\n        if input_grid[i, -1] == Color.BLACK:\n            flood_fill(input_grid, border_filled, i, input_grid.shape[1] - 1)\n    for j in range(input_grid.shape[1]):\n        if input_grid[0, j] == Color.BLACK:\n            flood_fill(input_grid, border_filled, 0, j)\n        if input_grid[-1, j] == Color.BLACK:\n            flood_fill(input_grid, border_filled, input_grid.shape[0] - 1, j)\n\n    # Identify holes as regions not touched by the border flood-fill\n    for component in components:\n        interior_points = np.argwhere(component)\n        is_hole = not np.any(border_filled[tuple(interior_points.T)])\n        if is_hole:\n            # Fill the hole with the target color\n            for x, y in interior_points:\n                output_grid[x, y] = Color.RED  # Example target color\n\n    return output_grid\n\n\ndef flood_fill(grid, filled, x, y):\n    if not (0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]):\n        return\n    if grid[x, y] != Color.BLACK or filled[x, y]:\n        return\n    filled[x, y] = True\n    flood_fill(grid, filled, x + 1, y)\n    flood_fill(grid, filled, x - 1, y)\n    flood_fill(grid, filled, x, y + 1)\n    flood_fill(grid, filled, x, y - 1)\n\n\ndef generate_input():\n    # Create a grid of size 10x10 with a single enclosing object\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Draw an enclosing object, for example, a square frame with some holes inside\n    enclosing_object = np.full((8, 8), Color.BLUE)\n    enclosing_object[1:-1, 1:-1] = Color.BLACK  # Make it hollow\n    blit(grid, enclosing_object, 1, 1)\n\n    # Randomly add holes inside the hollow object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, 3)\n        hole_x = np.random.randint(2, 8 - hole_size)\n        hole_y = np.random.randint(2, 8 - hole_size)\n        grid[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input consists of a grid with a single object enclosing empty spaces (holes). Identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border. Use flood-fill from the border to exclude non-enclosed regions. Output the grid with holes marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = input_grid.copy()\n    \n    # Use flood-fill from the border to mark all background regions connected to the border\n    flood_fill_border(output_grid, Color.BLACK)\n    \n    # Find all connected components, which now include only the enclosed regions\n    enclosed_components = find_connected_components(output_grid, background=Color.BLACK, connectivity=4)\n    \n    # Determine the target color for filling the holes\n    target_color = Color.YELLOW\n    \n    # Fill the enclosed regions (holes) with the target color\n    for component in enclosed_components:\n        if is_fully_enclosed(component, input_grid):\n            component[component == Color.BLACK] = target_color\n            blit_object(output_grid, component, background=Color.BLACK)\n    \n    return output_grid\n\ndef flood_fill_border(grid, background):\n    \"\"\"Flood fill from the border to mark non-enclosed regions.\"\"\"\n    # Create a working grid to mark the flood-fill\n    fill_grid = np.full(grid.shape, False, dtype=bool)\n    \n    # Flood-fill from the border to mark all reachable regions\n    for x in range(grid.shape[0]):\n        if grid[x, 0] == background:\n            flood_fill(grid, fill_grid, x, 0, background)\n        if grid[x, grid.shape[1] - 1] == background:\n            flood_fill(grid, fill_grid, x, grid.shape[1] - 1, background)\n    for y in range(grid.shape[1]):\n        if grid[0, y] == background:\n            flood_fill(grid, fill_grid, 0, y, background)\n        if grid[grid.shape[0] - 1, y] == background:\n            flood_fill(grid, fill_grid, grid.shape[0] - 1, y, background)\n    \n    # Mark all flood-filled areas in the grid as a different color (e.g., 1)\n    grid[fill_grid] = 1\n\ndef flood_fill(grid, fill_grid, x, y, background):\n    \"\"\"Recursive flood-fill algorithm.\"\"\"\n    if x < 0 or x >= grid.shape[0] or y < 0 or y >= grid.shape[1]:\n        return\n    if fill_grid[x, y] or grid[x, y] != background:\n        return\n    fill_grid[x, y] = True\n    flood_fill(grid, fill_grid, x + 1, y, background)\n    flood_fill(grid, fill_grid, x - 1, y, background)\n    flood_fill(grid, fill_grid, x, y + 1, background)\n    flood_fill(grid, fill_grid, x, y - 1, background)\n\ndef is_fully_enclosed(component, original_grid):\n    \"\"\"Check if a component is fully enclosed by verifying it's not connected to any border.\"\"\"\n    x, y, w, h = bounding_box(component)\n    return (x > 0 and x + w < original_grid.shape[0] and \n            y > 0 and y + h < original_grid.shape[1])\n\ndef generate_input():\n    # Create a grid of random size between 10 and 20\n    size = np.random.randint(10, 21)\n    grid = np.full((size, size), Color.BLACK)\n    \n    # Create a random enclosing object\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    enclosing_object = random_sprite(size // 2, size // 2, color_palette=[object_color], background=Color.BLACK)\n    \n    # Find location for the enclosing object\n    x, y = random_free_location_for_sprite(grid, enclosing_object, border_size=1, padding=1)\n    \n    # Place the enclosing object in the grid\n    blit_sprite(grid, enclosing_object, x, y)\n    \n    # Create random holes within the object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 5)\n        hole = random_sprite(hole_size, hole_size, color_palette=[Color.BLACK], background=Color.BLACK)\n        hole_x, hole_y = random_free_location_for_sprite(enclosing_object, hole, border_size=1, padding=1)\n        blit_sprite(enclosing_object, hole, hole_x, hole_y)\n    \n    # Place the modified enclosing object back into the grid\n    blit_sprite(grid, enclosing_object, x, y)\n    \n    return grid"], "seeds": ["44d8ac46.py", "810b9b61.py", "00d62c1b.py", "e73095fd.py", "Concepts: \nholes, enclosed regions, flood-fill, connected components\n\nDescription: \nInput consists of a grid with a single object enclosing empty spaces (holes). Identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border. Use flood-fill from the border to exclude non-enclosed regions. Output the grid with holes marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification, guide object\n\n# description:\n# In the input grid, several colored objects are present. Each object is a connected component of pixels and has a single color.\n# The task is to identify the object whose color is unique among all objects, referred to as the guide object.\n# The output grid should highlight or isolate the guide object based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components (objects) in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    # Count the occurrences of each color\n    color_counts = {}\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        color_counts[color] = color_counts.get(color, 0) + 1\n\n    # Identify the unique color with only one occurrence\n    guide_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            guide_color = color\n            break\n\n    # Prepare the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Isolate the guide object in the output grid\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        if color == guide_color:\n            blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Define available colors\n    available_colors = list(Color.NOT_BLACK)\n\n    # Randomly decide the number of objects\n    num_objects = np.random.randint(5, 10)\n\n    # Place objects with colors\n    for _ in range(num_objects):\n        # Choose a random color\n        color = np.random.choice(available_colors)\n\n        # Generate a random sprite for the object\n        sprite = random_sprite(n=np.random.randint(3, 5), m=np.random.randint(3, 5), color_palette=[color], connectivity=4)\n\n        # Try to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(input_grid, sprite, padding=1)\n            blit_sprite(input_grid, sprite, x=x, y=y)\n        except ValueError:\n            continue\n\n    # Ensure there is exactly one unique color\n    color_counts = {}\n    for obj in find_connected_components(input_grid, monochromatic=True, connectivity=8):\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        color_counts[color] = color_counts.get(color, 0) + 1\n\n    # If there is no unique color, add one\n    if len([c for c in color_counts if color_counts[c] == 1]) == 0:\n        unique_color = np.random.choice([c for c in available_colors if c not in color_counts])\n        sprite = random_sprite(n=np.random.randint(3, 5), m=np.random.randint(3, 5), color_palette=[unique_color], connectivity=4)\n        try:\n            x, y = random_free_location_for_sprite(input_grid, sprite, padding=1)\n            blit_sprite(input_grid, sprite, x=x, y=y)\n        except ValueError:\n            return generate_input()\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification, guide object\n\n# description:\n# In the input grid, you will see several colored objects, each object is a connected component of the same color.\n# One of these objects has a unique color not shared with any other object. This object is the guide object.\n# In the output grid, highlight the guide object by changing it to a distinct color (e.g., yellow), while leaving all other objects unchanged.\n\ndef main(input_grid):\n    # Identify all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    # Create a color frequency dictionary to determine unique colors\n    color_count = {}\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]  # Get the color of the object\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Find the unique color\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    # Prepare the output grid\n    output_grid = input_grid.copy()\n\n    # Highlight the guide object by changing its color to yellow\n    for obj in objects:\n        obj_color = np.unique(obj[obj != Color.BLACK])[0]\n        if obj_color == unique_color:\n            obj[obj != Color.BLACK] = Color.YELLOW  # Change the color to yellow\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Select colors for the objects and ensure one has a unique color\n    available_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(available_colors)\n    unique_color = available_colors.pop()\n    other_colors = available_colors[:np.random.randint(2, 5)]\n\n    # Create objects with the selected colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        color = unique_color if np.random.rand() < 0.2 else np.random.choice(other_colors)\n        sprite = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), color_palette=[color], density=0.6)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification, guide object\n\n# description:\n# In the input grid, you will see various colored objects. Each object is a connected component of the grid with a single color.\n# Identify the color that is unique among all objects (meaning no other object has this color).\n# The output grid should highlight or isolate the object with this unique color, turning all its pixels teal, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all the connected components in the grid\n    connected_components = find_connected_components(input_grid, monochromatic=True)\n    \n    # Dictionary to count occurrences of each color\n    color_count = {}\n\n    # Map each component to its color and count the occurrences\n    for component in connected_components:\n        color = np.unique(component)[1]  # skip background color (assumed to be first)\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Find the unique color (count == 1)\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    if unique_color is None:\n        raise ValueError(\"No unique color found in the grid.\")\n\n    # Create the output grid\n    output_grid = input_grid.copy()\n    \n    # Isolate the object with the unique color by turning it teal\n    for component in connected_components:\n        if np.any(component == unique_color):\n            output_grid[component == unique_color] = Color.TEAL\n    \n    return output_grid\n\ndef generate_input():\n    n = np.random.randint(10, 16)\n    m = np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # List of colors to use, excluding black\n    available_colors = list(Color.NOT_BLACK)\n    \n    # Number of objects to generate\n    num_objects = np.random.randint(5, 8)\n\n    # Ensure there's at least one unique color\n    unique_color = np.random.choice(available_colors)\n    colors_to_use = [unique_color] + np.random.choice(available_colors, num_objects - 1).tolist()\n\n    np.random.shuffle(colors_to_use)  # Shuffle to ensure unique color is placed randomly\n    \n    for color in colors_to_use:\n        # Generate random object (connected component) using the specified color\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[color])\n        \n        # Try to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no valid position is found, retry\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification\n\n# description:\n# In the input grid, you will see various objects of different colors. Each object is a connected component with the same color.\n# To make the output grid, identify the objects that have colors unique to them (no other object shares their color).\n# Highlight the guide object (the unique colored object) by isolating it, and leave all other objects unchanged.\n\ndef main(input_grid):\n    # Find the connected components (objects) in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    color_count = {}\n    \n    # Count the occurrence of each color among the objects\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find and isolate the guide object\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        if color_count[color] == 1:  # Unique colored object\n            blit_object(output_grid, obj, background=Color.BLACK)\n            break\n    \n    return output_grid\n\ndef generate_input():\n    n = np.random.randint(10, 15)\n    input_grid = np.full((n, n), Color.BLACK)\n    available_colors = list(Color.NOT_BLACK)\n    num_objects = np.random.randint(3, 6)\n    \n    used_colors = []\n    \n    for _ in range(num_objects):\n        obj_size = np.random.randint(2, 4)\n        obj_color = np.random.choice([c for c in available_colors if c not in used_colors])\n        used_colors.append(obj_color)\n        sprite = random_sprite(n=obj_size, m=obj_size, color_palette=[obj_color])\n        \n        try:\n            x, y = random_free_location_for_sprite(input_grid, sprite, padding=1)\n            blit_sprite(input_grid, sprite, x=x, y=y)\n        except ValueError:\n            continue\n    \n    # Ensure at least one color is unique\n    unique_color_object = random_sprite(n=3, m=3, color_palette=[np.random.choice(available_colors)])\n    try:\n        x, y = random_free_location_for_sprite(input_grid, unique_color_object, padding=1)\n        blit_sprite(input_grid, unique_color_object, x=x, y=y)\n    except ValueError:\n        return generate_input()\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification, guide object\n\n# description:\n# In the input grid, you will see various objects each having a different color. \n# The task is to identify all connected components and determine their colors. \n# Select the object whose color is unique (not shared by any other object) as the guide object.\n# The output should be the grid with only the guide object highlighted, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Map colors to the number of objects with that color\n    color_count = {}\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Identify the unique color (appears exactly once)\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    # Create the output grid with the same dimensions, filled with black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Highlight the guide object (unique color)\n    for obj in objects:\n        if unique_color in obj:\n            blit_object(output_grid, obj, background=Color.BLACK)\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Choose a subset of colors to use\n    colors = np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(3, 6), replace=False)\n\n    # Place random objects with these colors\n    for color in colors:\n        sprite = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), color_palette=[color], density=0.5)\n        try:\n            x, y = random_free_location_for_sprite(input_grid, sprite, padding=1)\n            blit_sprite(input_grid, sprite, x=x, y=y)\n        except ValueError:\n            continue\n\n    # Ensure at least one color is unique\n    unique_color = np.random.choice(colors)\n    unique_sprite = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), color_palette=[unique_color], density=0.5)\n    try:\n        x, y = random_free_location_for_sprite(input_grid, unique_sprite, padding=1)\n        blit_sprite(input_grid, unique_sprite, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification, guide object\n\n# description:\n# In the input grid, you will see various colored objects. Some objects may share the same color.\n# To make the output grid, identify the object with a unique color (not shared by any other object).\n# Highlight or isolate this guide object based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components (objects) in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    # Determine the color of each object\n    color_counts = {}\n    for obj in objects:\n        # Assume all pixels in a monochromatic object have the same color\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    # Find the unique color\n    unique_colors = [color for color, count in color_counts.items() if count == 1]\n\n    # There should be exactly one unique color\n    if len(unique_colors) != 1:\n        raise ValueError(\"There should be exactly one object with a unique color.\")\n\n    unique_color = unique_colors[0]\n\n    # Find the object with the unique color\n    guide_object = next(obj for obj in objects if np.any(obj == unique_color))\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place the guide object onto the output grid\n    blit_object(output_grid, guide_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Random grid size between 10x10 and 20x20\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Choose a random number of objects to place\n    num_objects = np.random.randint(3, 6)\n\n    # Choose a set of colors to use\n    possible_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(possible_colors)\n    colors_used = possible_colors[:num_objects - 1]\n\n    # Place objects on the grid\n    for _ in range(num_objects - 1):\n        # Randomly generate an object with one of the selected colors\n        obj_color = np.random.choice(colors_used)\n        obj = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[obj_color], density=0.7)\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            continue\n\n    # Ensure at least one object with a unique color exists\n    unique_color = possible_colors[num_objects - 1]\n    unique_obj = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[unique_color], density=0.7)\n    try:\n        x, y = random_free_location_for_sprite(input_grid, unique_obj, padding=1)\n        blit_sprite(input_grid, unique_obj, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification, guide object\n\n# description:\n# In the input grid, you will see various objects, each with a specific color.\n# The task is to identify the object whose color is unique among all objects in the grid.\n# The output grid should highlight or isolate the guide object based on its unique color,\n# while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components, assuming each component is monochromatic\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Dictionary to count the frequency of each color\n    color_count = {}\n\n    for obj in objects:\n        # Since objects are monochromatic, any non-black pixel will give the color of the object\n        color = np.unique(obj[obj != Color.BLACK])[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Find the unique color (appears only once among the objects)\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    if unique_color is None:\n        raise ValueError(\"No unique colored object found.\")\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Isolate the object with the unique color\n    for obj in objects:\n        if np.any(obj == unique_color):\n            blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x n\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate a set of colors to use, ensuring one unique color\n    available_colors = list(Color.NOT_BLACK)\n    unique_color = np.random.choice(available_colors)\n    colors = [unique_color] + [np.random.choice(available_colors) for _ in range(np.random.randint(3, 6))]\n\n    for color in colors:\n        # Create a random object with the chosen color\n        sprite = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[color], density=np.random.uniform(0.3, 0.7))\n        \n        # Try to place the object on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If there is no space, skip placing this object\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color selection, connected components, object identification, guide object\n\n# description:\n# In the input grid, identify all connected components and determine their colors. Select the object whose color is unique (not shared by any other object) as the guide object.\n# The output is the grid with the guide object highlighted or isolated based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all the connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    \n    # Count the occurrence of each color\n    color_count = {}\n    for obj in objects:\n        # Get the color of the object (all pixels in the object will have the same color)\n        obj_color = np.unique(obj[obj != Color.BLACK])[0]\n        if obj_color in color_count:\n            color_count[obj_color] += 1\n        else:\n            color_count[obj_color] = 1\n    \n    # Find the color that is unique\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n    \n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Highlight or isolate the guide object with the unique color\n    for obj in objects:\n        obj_color = np.unique(obj[obj != Color.BLACK])[0]\n        if obj_color == unique_color:\n            blit_object(output_grid, obj, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with multiple objects of different colors\n    grid_size = np.random.randint(10, 15)\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Select a random number of objects to generate\n    num_objects = np.random.randint(3, 6)\n    \n    # Choose colors for the objects\n    available_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(available_colors)\n    \n    for _ in range(num_objects):\n        # Create a random sprite with a chosen color\n        color = available_colors.pop()\n        sprite_size = np.random.randint(2, 4)\n        sprite = random_sprite(n=sprite_size, m=sprite_size, color_palette=[color], density=0.5)\n        \n        # Place the sprite in a random location on the grid\n        try:\n            x, y = random_free_location_for_sprite(input_grid, sprite, padding=1)\n            blit_sprite(input_grid, sprite, x=x, y=y)\n        except ValueError:\n            # If no space is left, break early\n            break\n    \n    return input_grid"], "seeds": ["810b9b61.py", "aedd82e4.py", "941d9a10.py", "48d8fb45.py", "Concepts: \nunique color selection, connected components, object identification, guide object\n\nDescription: \nIdentify all connected components in the grid and determine their colors. Select the object whose color is unique (not shared by any other object) as the guide object. The output is the grid with the guide object highlighted or isolated based on its unique color, while all other objects remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization\n\n# description:\n# In the input grid, you will see a guide object (a larger shape with holes) and a target object (a smaller shape that can be used for filling).\n# The goal is to fill the holes in the guide object using the target object in a Tetris-style manner. The target object can be rotated or flipped to achieve the best fit.\n# The objective is to maximize the filled area within the guide object without altering its structure.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the guide object and the target object from the grid.\n    # 2. Find and mark the holes inside the guide object.\n    # 3. Attempt to fit the target object into the holes as optimally as possible.\n    # 4. Return the grid with the holes filled by the target object.\n    \n    # Identify objects in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Assume the largest object is the guide and the second largest is the target\n    objects = sorted(objects, key=lambda obj: np.sum(obj != Color.BLACK), reverse=True)\n    guide_object = objects[0]\n    target_object = objects[1]\n    \n    # Extract the mask for the guide object\n    guide_mask = guide_object != Color.BLACK\n    \n    # Find holes in the guide object\n    interior = object_interior(guide_object, background=Color.BLACK)\n    holes = interior & ~guide_mask\n    \n    # Prepare the output grid\n    output_grid = input_grid.copy()\n    \n    # Attempt to fill holes with the target object\n    target_sprite = crop(target_object)\n    target_variants = [target_sprite, np.rot90(target_sprite), np.rot90(target_sprite, 2), np.rot90(target_sprite, 3),\n                       np.fliplr(target_sprite), np.flipud(target_sprite)]\n    \n    # Iterate over each hole and try to place the target object\n    for hole_x, hole_y in np.argwhere(holes):\n        best_fit = None\n        for variant in target_variants:\n            try:\n                # Try blitting the variant into the hole\n                blit_sprite(output_grid, variant, hole_x, hole_y, background=Color.BLACK)\n                # If successful, mark as best fit\n                best_fit = variant\n                break\n            except ValueError:\n                pass\n        \n        # If a best fit was found, update the grid\n        if best_fit is not None:\n            blit_sprite(output_grid, best_fit, hole_x, hole_y, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(15, 20, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n    \n    # Create a guide object with holes\n    guide_width, guide_height = np.random.randint(8, 12, size=2)\n    guide_sprite = random_sprite(guide_width, guide_height, color_palette=[Color.GREY], background=Color.BLACK, symmetry='not_symmetric')\n    \n    # Create holes in the guide object\n    num_holes = np.random.randint(2, 4)\n    for _ in range(num_holes):\n        hole_width, hole_height = np.random.randint(1, 3, size=2)\n        hole_sprite = np.full((hole_width, hole_height), Color.BLACK)\n        hole_x, hole_y = random_free_location_for_sprite(guide_sprite, hole_sprite, background=Color.GREY, border_size=1)\n        blit_sprite(guide_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n    \n    # Place the guide object on the grid\n    guide_x, guide_y = random_free_location_for_sprite(input_grid, guide_sprite, padding=1, border_size=1)\n    blit_sprite(input_grid, guide_sprite, guide_x, guide_y, background=Color.BLACK)\n    \n    # Create a target object\n    target_width, target_height = np.random.randint(2, 4, size=2)\n    target_color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.GREY])\n    target_sprite = random_sprite(target_width, target_height, color_palette=[target_color], background=Color.BLACK)\n    \n    # Place the target object on the grid\n    target_x, target_y = random_free_location_for_sprite(input_grid, target_sprite, padding=1)\n    blit_sprite(input_grid, target_sprite, target_x, target_y, background=Color.BLACK)\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization\n\n# description:\n# In the input grid, you will see a guide object with holes and a separate target object. The task is to fill the holes of the guide object using the target object.\n# The goal is to maximize the area filled within the guide object without altering its structure. The target object may be used fully or partially to fill the holes.\n# Non-hole areas and the guide object's boundaries remain unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Parse the input to identify the guide object and the target object.\n    # 2. Identify the holes within the guide object.\n    # 3. Fit the target object into the holes optimally.\n    # 4. Return the modified grid with filled holes.\n\n    # Step 1: Identify guide and target objects\n    guide_color = Color.GREY\n    target_color = Color.RED\n\n    # Extract guide object\n    guide_input = input_grid.copy()\n    guide_input[input_grid != guide_color] = Color.BLACK\n    guide_objects = find_connected_components(guide_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Extract target object\n    target_input = input_grid.copy()\n    target_input[input_grid != target_color] = Color.BLACK\n    target_objects = find_connected_components(target_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Assume only one guide object and one target object for simplicity\n    guide_object = guide_objects[0]\n    target_object = target_objects[0]\n\n    # Step 2: Identify holes within the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    holes_mask = interior_mask & (guide_object == Color.BLACK)\n\n    # Step 3: Fit the target object into the holes\n    output_grid = input_grid.copy()\n    target_sprite = crop(target_object, background=Color.BLACK)\n\n    # Try to fit as much of the target object as possible into the holes\n    for x, y in np.argwhere(holes_mask):\n        if np.all(target_sprite == Color.BLACK):  # no more target to place\n            break\n\n        # Try fitting the target sprite at this location\n        if can_fit(output_grid, target_sprite, x, y):\n            blit_sprite(output_grid, target_sprite, x, y, background=Color.BLACK)\n            # Update the holes mask to reflect filled areas\n            holes_mask[x:x+target_sprite.shape[0], y:y+target_sprite.shape[1]] = False\n\n    return output_grid\n\ndef can_fit(grid, sprite, x, y):\n    \"\"\"Check if the sprite can fit in the grid at position (x, y) without overlaps.\"\"\"\n    sprite_height, sprite_width = sprite.shape\n    if x + sprite_height > grid.shape[0] or y + sprite_width > grid.shape[1]:\n        return False\n\n    for i in range(sprite_height):\n        for j in range(sprite_width):\n            if sprite[i, j] != Color.BLACK and grid[x + i, y + j] != Color.BLACK:\n                return False\n    return True\n\ndef generate_input():\n    # Create a grid with a guide object and a target object\n    n, m = np.random.randint(10, 20, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Create the guide object\n    guide_width, guide_height = np.random.randint(6, 10, size=2)\n    guide_object = np.full((guide_width, guide_height), Color.GREY)\n\n    # Create holes in the guide object\n    n_holes = np.random.randint(1, 4)\n    for _ in range(n_holes):\n        hole_size = np.random.randint(1, 3)\n        hole_x, hole_y = np.random.randint(1, guide_width - hole_size), np.random.randint(1, guide_height - hole_size)\n        guide_object[hole_x:hole_x+hole_size, hole_y:hole_y+hole_size] = Color.BLACK\n\n    # Place the guide object in the grid\n    x, y = random_free_location_for_sprite(input_grid, guide_object, border_size=1, padding=1)\n    blit_sprite(input_grid, guide_object, x, y, background=Color.BLACK)\n\n    # Create the target object\n    target_width, target_height = np.random.randint(1, 4), np.random.randint(1, 4)\n    target_object = random_sprite(target_width, target_height, color_palette=[Color.RED], background=Color.BLACK)\n\n    # Place the target object in the grid\n    x, y = random_free_location_for_sprite(input_grid, target_object, border_size=1, padding=1)\n    blit_sprite(input_grid, target_object, x, y, background=Color.BLACK)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization\n\n# description:\n# The grid contains a guide object and a target object. The guide object has holes that need to be filled with parts of the target object. The target object should be used in a Tetris-like manner to fill the holes optimally, maximizing the filled area without changing the guide's structure. Non-hole areas and guide boundaries remain unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the guide and target objects\n    # 2. Detect holes within the guide object\n    # 3. Fill these holes optimally using the target object\n    \n    # Step 1: Identify the guide and target objects\n    objects = find_connected_components(input_grid, connectivity=4)\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))  # Assuming the guide is the largest object\n    target_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))  # Assuming the target is the smallest object\n\n    # Step 2: Detect holes within the guide object\n    interior_mask = object_interior(guide_object)\n    guide_mask = guide_object != Color.BLACK\n    hole_mask = interior_mask & ~guide_mask\n\n    # Step 3: Attempt to fill holes optimally using the target object\n    output_grid = np.copy(input_grid)\n    \n    # Convert target object to sprite and crop\n    target_sprite = crop(target_object, background=Color.BLACK)\n\n    # Iterate over the holes and try to fill them with parts of the target object\n    for x, y in np.argwhere(hole_mask):\n        # Attempt to place the target object at each hole location\n        try:\n            blit_sprite(output_grid, target_sprite, x, y, background=Color.BLACK)\n            # Check overlap and if it's a valid placement\n            if np.array_equal(output_grid[guide_mask], input_grid[guide_mask]):\n                # If valid, update hole_mask to avoid double filling\n                hole_mask[x:x+target_sprite.shape[0], y:y+target_sprite.shape[1]] &= ~(target_sprite != Color.BLACK)\n            else:\n                # If invalid, revert changes\n                output_grid = np.copy(input_grid)\n        except IndexError:\n            # If the placement is out of bounds, continue\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a guide object and a target object\n    n, m = np.random.randint(15, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Create guide object\n    guide_width, guide_height = np.random.randint(6, 10, size=2)\n    guide_sprite = np.full((guide_width, guide_height), np.random.choice(list(Color.NOT_BLACK - {Color.GREY})))\n\n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 3)\n    for _ in range(num_holes):\n        hole_width, hole_height = np.random.randint(1, guide_width // 2), np.random.randint(1, guide_height // 2)\n        hole_x, hole_y = np.random.randint(1, guide_width - hole_width), np.random.randint(1, guide_height - hole_height)\n        guide_sprite[hole_x:hole_x + hole_width, hole_y:hole_y + hole_height] = Color.BLACK\n\n    # Place the guide object on the grid\n    x, y = random_free_location_for_sprite(input_grid, guide_sprite, padding=1)\n    blit_sprite(input_grid, guide_sprite, x, y, background=Color.BLACK)\n\n    # Create target object\n    target_width, target_height = np.random.randint(2, 4, size=2)\n    target_sprite = random_sprite(target_width, target_height, color_palette=list(Color.NOT_BLACK - {Color.GREY}), background=Color.BLACK)\n\n    # Place the target object on the grid\n    x, y = random_free_location_for_sprite(input_grid, target_sprite, padding=1)\n    blit_sprite(input_grid, target_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization, Tetris-style filling\n\n# description:\n# The input grid contains a guide object and a target object.\n# The guide object includes some black holes which need to be filled using the target object.\n# The target object can be used partially or fully to fill the holes in a Tetris-like manner.\n# The goal is to maximize the filled area within the guide object without altering the guide's structure.\n# Non-hole areas and the guide object's boundaries remain unchanged.\n\ndef main(input_grid):\n    # Extract guide and target objects\n    guide_input = input_grid.copy()\n    guide_input[input_grid != Color.GREY] = Color.BLACK\n    guide_object = find_connected_components(guide_input, background=Color.BLACK, connectivity=4, monochromatic=True)[0]\n    \n    target_input = input_grid.copy()\n    target_input[input_grid == Color.GREY] = Color.BLACK\n    target_object = find_connected_components(target_input, background=Color.BLACK, connectivity=4, monochromatic=True)[0]\n    target_sprite = crop(target_object, background=Color.BLACK)\n    \n    # Identify holes within guide object\n    guide_interior = object_interior(guide_object, background=Color.BLACK)\n    holes = guide_interior & (guide_object == Color.BLACK)\n    \n    # Initialize output grid\n    output_grid = input_grid.copy()\n    \n    # Try to fill each hole optimally using target object\n    hole_coords = np.argwhere(holes)\n    for x, y in hole_coords:\n        if target_sprite.shape[0] <= guide_object.shape[0] - x and target_sprite.shape[1] <= guide_object.shape[1] - y:\n            # Attempt to place target object in the hole\n            fit_area = output_grid[x:x+target_sprite.shape[0], y:y+target_sprite.shape[1]]\n            if np.all((fit_area == Color.BLACK) | (fit_area == Color.GREY)):\n                blit_sprite(output_grid, target_sprite, x, y, background=Color.BLACK)\n                break  # Use only one target object\n                \n    return output_grid\n\n\ndef generate_input():\n    n, m = np.random.randint(10, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Create the guide object\n    guide_width, guide_height = np.random.randint(8, 12, size=2)\n    guide_sprite = np.full((guide_width, guide_height), Color.GREY)\n    \n    # Create holes within the guide object\n    for _ in range(np.random.randint(1, 3)):\n        hole_width, hole_height = np.random.randint(1, guide_width-2), np.random.randint(1, guide_height-2)\n        hole_sprite = np.full((hole_width, hole_height), Color.BLACK)\n        hole_x, hole_y = random_free_location_for_sprite(guide_sprite, hole_sprite, border_size=1, background=Color.GREY)\n        blit_sprite(guide_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n    \n    # Place the guide object in the input grid\n    x, y = random_free_location_for_sprite(input_grid, guide_sprite, padding=1, border_size=1)\n    blit_sprite(input_grid, guide_sprite, x, y, background=Color.BLACK)\n    \n    # Create the target object\n    target_width, target_height = np.random.randint(1, 4), np.random.randint(1, 4)\n    target_color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREY])\n    target_sprite = random_sprite(target_width, target_height, color_palette=[target_color], background=Color.BLACK)\n    \n    # Place the target object in the input grid\n    x, y = random_free_location_for_sprite(input_grid, target_sprite, padding=1, border_size=1)\n    blit_sprite(input_grid, target_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization, Tetris-style filling\n\n# description:\n# Given a grid with a guide object and a target object, identify holes within the guide object (enclosed black areas). \n# Fill these holes using the target object, aiming for an optimal fit. \n# The target object may be fully or partially used to fill the holes, similar to a \"Tetris\" style filling. \n# The goal is to maximize the filled area within the guide object without altering the guide's boundaries. \n# Non-hole areas and the guide object's boundaries remain unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Parse the input to identify the guide object and target object.\n    # 2. Find holes (enclosed black regions) within the guide object.\n    # 3. Determine how to optimally fit the target object into these holes.\n    # 4. Fill the holes with the target object, maximizing the filled area.\n    \n    output_grid = input_grid.copy()\n    \n    # Separate guide and target objects\n    guide_input = input_grid.copy()\n    guide_input[input_grid != Color.GREY] = Color.BLACK\n    guide_object = find_connected_components(guide_input, background=Color.BLACK, connectivity=8, monochromatic=True)[0]\n\n    target_input = input_grid.copy()\n    target_input[input_grid == Color.GREY] = Color.BLACK\n    target_objects = find_connected_components(target_input, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Assume the target object is the first non-black object\n    target_object = [obj for obj in target_objects if np.any(obj != Color.BLACK)][0]\n    target_sprite = crop(target_object, background=Color.BLACK)\n    \n    # Find holes within the guide object\n    guide_interior = object_interior(guide_object)\n    hole_mask = guide_interior & (guide_object == Color.BLACK)\n    \n    # Attempt to fill the holes with the target object, aiming for the best fit\n    hole_bounding_boxes = find_connected_components(hole_mask, background=False, connectivity=8, monochromatic=True)\n    for hole in hole_bounding_boxes:\n        hole_sprite = crop(hole, background=False)\n        \n        # Check if the target can fit in the hole\n        target_mask = target_sprite != Color.BLACK\n        hole_capacity = np.sum(hole_sprite)\n        \n        if np.sum(target_mask) <= hole_capacity:\n            # Use the target to fill the hole, maximizing the filled area\n            hole_x, hole_y = object_position(hole)\n            blit_sprite(output_grid, target_sprite, hole_x, hole_y, background=False)\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a guide object and target object\n    n, m = np.random.randint(15, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n    \n    # Create a guide object with holes\n    guide_width, guide_height = np.random.randint(10, 15, size=2)\n    guide_sprite = np.full((guide_width, guide_height), Color.GREY)\n    \n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 3)\n    for _ in range(num_holes):\n        hole_width, hole_height = np.random.randint(2, 5, size=2)\n        hole_sprite = random_sprite(hole_width, hole_height, color_palette=[Color.BLACK], background=Color.GREY)\n        hole_x, hole_y = random_free_location_for_sprite(guide_sprite, hole_sprite, border_size=1, background=Color.GREY)\n        blit_sprite(guide_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n    \n    # Place the guide object in the grid\n    x, y = random_free_location_for_sprite(input_grid, guide_sprite, padding=1, border_size=1)\n    blit_sprite(input_grid, guide_sprite, x, y, background=Color.BLACK)\n    \n    # Create a target object\n    target_width, target_height = np.random.randint(2, 7, size=2)\n    target_color = np.random.choice(Color.NOT_BLACK - {Color.GREY})\n    target_sprite = random_sprite(target_width, target_height, color_palette=[target_color], background=Color.BLACK)\n    \n    # Place the target object in the grid\n    x, y = random_free_location_for_sprite(input_grid, target_sprite, padding=1, border_size=1)\n    blit_sprite(input_grid, target_sprite, x, y, background=Color.BLACK)\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization\n\n# description:\n# Given a grid with a guide object and a target object, identify holes within the guide object. Fill these holes using the target object, aiming for an optimal fit. \n# The target object may be fully or partially used to fill the holes, similar to a \"Tetris\" style filling. \n# The goal is to maximize the filled area within the guide object without altering the guide's structure. Non-hole areas and the guide object's boundaries remain unchanged.\n\ndef main(input_grid):\n    # Step 1: Identify the guide object and target object\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n    \n    # Separate the guide object and target object based on their size or color\n    guide_object = None\n    target_object = None\n    for obj in objects:\n        if np.any(obj == Color.GREY):\n            guide_object = obj\n        else:\n            target_object = obj\n\n    # Step 2: Identify holes within the guide object\n    guide_interior = object_interior(guide_object, background=Color.BLACK)\n    hole_mask = (guide_interior & (guide_object == Color.BLACK))\n\n    # Step 3: Optimize filling the holes using the target object\n    output_grid = input_grid.copy()\n    target_sprite = crop(target_object, background=Color.BLACK)\n    \n    # Fill as much of the hole as possible using the target sprite\n    for x, y in np.argwhere(hole_mask):\n        if collision(object1=output_grid, object2=target_sprite, x2=x, y2=y, background=Color.BLACK):\n            continue\n        blit_sprite(output_grid, target_sprite, x, y, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n    \n    # Create a guide object with a hole\n    guide_width, guide_height = np.random.randint(6, 10, size=2)\n    guide_object = np.full((guide_width, guide_height), Color.GREY)\n    \n    # Create a hole inside the guide object\n    hole_width, hole_height = np.random.randint(1, guide_width-2), np.random.randint(1, guide_height-2)\n    hole_x, hole_y = np.random.randint(1, guide_width-hole_width-1), np.random.randint(1, guide_height-hole_height-1)\n    guide_object[hole_x:hole_x+hole_width, hole_y:hole_y+hole_height] = Color.BLACK\n    \n    # Place the guide object on the grid\n    x, y = random_free_location_for_sprite(input_grid, guide_object, padding=1)\n    blit_sprite(input_grid, guide_object, x, y, background=Color.BLACK)\n    \n    # Create a target object, possibly larger than the hole\n    target_width, target_height = np.random.randint(1, min(hole_width+2, guide_width)), np.random.randint(1, min(hole_height+2, guide_height))\n    target_object = random_sprite(target_width, target_height, color_palette=[Color.RED], background=Color.BLACK)\n    \n    # Place the target object on the grid\n    x, y = random_free_location_for_sprite(input_grid, target_object, padding=1)\n    blit_sprite(input_grid, target_object, x, y, background=Color.BLACK)\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization\n\n# description:\n# The input consists of a grid containing a guide object (in grey) with black holes and a target object (in a random color).\n# The task is to fill the holes in the guide object with parts or the entirety of the target object.\n# The aim is to maximize the filled area within the guide object without altering its boundaries or structure.\n\ndef main(input_grid):\n    # Process the input grid to identify the guide object, holes, and target object\n    guide_input = input_grid.copy()\n    guide_input[input_grid != Color.GREY] = Color.BLACK\n    guide_objects = find_connected_components(guide_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    target_input = input_grid.copy()\n    target_input[input_grid == Color.GREY] = Color.BLACK\n    target_objects = find_connected_components(target_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Assume there's only one target object\n    target_object = target_objects[0]\n    target_sprite = crop(target_object, background=Color.BLACK)\n    target_color = np.unique(target_sprite[target_sprite != Color.BLACK])[0]\n\n    # Identify holes in the guide object\n    guide_object = guide_objects[0]\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    holes_mask = interior_mask & (guide_object == Color.BLACK)\n\n    output_grid = input_grid.copy()\n\n    # Attempt to fill the holes with the target object\n    for x, y in np.argwhere(holes_mask):\n        if np.any(target_sprite != Color.BLACK):\n            output_grid[x, y] = target_color\n            # Remove the used part of the target object\n            target_sprite[target_sprite != Color.BLACK] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    n, m = np.random.randint(10, 20, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Create guide object with holes\n    guide_width, guide_height = np.random.randint(5, 8, size=2)\n    guide_sprite = np.full((guide_width, guide_height), Color.GREY)\n\n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_width, hole_height = np.random.randint(1, guide_width - 2), np.random.randint(1, guide_height - 2)\n        hole_sprite = np.full((hole_width, hole_height), Color.BLACK)\n        hole_x, hole_y = random_free_location_for_sprite(guide_sprite, hole_sprite, border_size=1, background=Color.GREY)\n        blit_sprite(guide_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n\n    # Place the guide object on the grid\n    x, y = random_free_location_for_sprite(input_grid, guide_sprite, padding=1, border_size=1)\n    blit_sprite(input_grid, guide_sprite, x, y, background=Color.BLACK)\n\n    # Create a target object\n    target_width, target_height = np.random.randint(2, 5, size=2)\n    target_color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.GREY])\n    target_sprite = np.full((target_width, target_height), target_color)\n\n    # Place the target object on the grid\n    x, y = random_free_location_for_sprite(input_grid, target_sprite, padding=1, border_size=1)\n    blit_sprite(input_grid, target_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, filling, guide object, target object, optimization\n\n# description:\n# In the input grid, there is a guide object and a target object. The guide object has one or more \"holes\" (regions of contiguous black pixels).\n# The task is to fill these holes using the target object, aiming for an optimal fit similar to a \"Tetris\" style filling.\n# The target object may be fully or partially used. The goal is to maximize the filled area within the guide object without altering the guide's structure.\n# Non-hole areas and the guide object's boundaries remain unchanged.\n\ndef main(input_grid):\n    # 1. Separate the guide and target objects\n    guide_grid = input_grid.copy()\n    target_grid = input_grid.copy()\n    guide_grid[input_grid != Color.GREY] = Color.BLACK\n    target_grid[input_grid == Color.GREY] = Color.BLACK\n\n    guide_objects = find_connected_components(guide_grid, background=Color.BLACK)\n    target_objects = find_connected_components(target_grid, background=Color.BLACK)\n\n    # Assume there's only one target object for simplicity\n    target_object = target_objects[0]\n    target_sprite = crop(target_object, background=Color.BLACK)\n\n    output_grid = np.copy(input_grid)\n\n    # 2. For each guide object, find and fill holes optimally\n    for guide_object in guide_objects:\n        interior_mask = object_interior(guide_object) & (guide_object == Color.BLACK)\n\n        # Determine the bounding box of the guide object\n        guide_x, guide_y, guide_width, guide_height = bounding_box(guide_object)\n\n        # Try to fit the target object in the holes optimally\n        for rot in range(4):  # Attempt with different orientations\n            rotated_sprite = np.rot90(target_sprite, rot)\n            for x in range(guide_width - rotated_sprite.shape[0] + 1):\n                for y in range(guide_height - rotated_sprite.shape[1] + 1):\n                    # Check if the rotated sprite fits in the hole\n                    sprite_mask = rotated_sprite != Color.BLACK\n                    fit_mask = interior_mask[x:x + sprite_mask.shape[0], y:y + sprite_mask.shape[1]]\n                    if np.all(fit_mask[sprite_mask]):\n                        # Fill the hole with the target object\n                        output_grid[guide_x + x:guide_x + x + sprite_mask.shape[0], guide_y + y:guide_y + y + sprite_mask.shape[1]][sprite_mask] = rotated_sprite[sprite_mask]\n                        # Break since we want to maximize filling, but do not over-fill\n                        break\n                else:\n                    continue\n                break\n\n    return output_grid\n\n\ndef generate_input():\n    grid_size = np.random.randint(10, 20)\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a guide object with holes\n    guide_width = np.random.randint(5, grid_size)\n    guide_height = np.random.randint(5, grid_size)\n    guide_sprite = np.full((guide_width, guide_height), Color.GREY)\n\n    # Create random holes in the guide object\n    num_holes = np.random.randint(1, 3)\n    for _ in range(num_holes):\n        hole_width = np.random.randint(1, guide_width // 2)\n        hole_height = np.random.randint(1, guide_height // 2)\n        hole_x = np.random.randint(1, guide_width - hole_width)\n        hole_y = np.random.randint(1, guide_height - hole_height)\n        guide_sprite[hole_x:hole_x + hole_width, hole_y:hole_y + hole_height] = Color.BLACK\n\n    # Place the guide object on the grid\n    gx, gy = random_free_location_for_sprite(input_grid, guide_sprite, border_size=1)\n    blit_sprite(input_grid, guide_sprite, gx, gy, background=Color.BLACK)\n\n    # Create a target object\n    target_width = np.random.randint(2, 4)\n    target_height = np.random.randint(2, 4)\n    target_sprite = random_sprite(target_width, target_height, color_palette=[Color.RED], background=Color.BLACK)\n\n    # Place the target object on the grid\n    tx, ty = random_free_location_for_sprite(input_grid, target_sprite, border_size=1)\n    blit_sprite(input_grid, target_sprite, tx, ty, background=Color.BLACK)\n\n    return input_grid"], "seeds": ["228f6490.py", "44d8ac46.py", "aba27056.py", "810b9b61.py", "Concepts: \nholes, filling, guide object, target object, optimization\n\nDescription: \nGiven a grid with a guide object and a target object, identify holes within the guide object. Fill these holes using the target object, aiming for an optimal fit. The target object may be fully or partially used to fill the holes, similar to a \"Tetris\" style filling. The goal is to maximize the filled area within the guide object without altering the guide's structure. Non-hole areas and the guide object's boundaries remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, guide object, filling, connected components, interior regions\n\n# description:\n# The input grid consists of a guide object and a target object. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). \n# For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. \n# The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Separate the guide and target objects based on colors\n    guide_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    target_object_color = Color.RED  # Assuming RED is the target object color\n    target_object = None\n    \n    for obj in guide_objects:\n        if np.any(obj == target_object_color):\n            target_object = obj\n            break\n    \n    # Ensure there's exactly one target object\n    assert target_object is not None, \"No target object found\"\n    \n    # Create a mask for the guide object excluding the target object\n    guide_object = input_grid.copy()\n    guide_object[input_grid == target_object_color] = Color.BLACK\n    \n    # Find interior holes in the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    interior_mask &= (guide_object == Color.BLACK)\n    \n    # Create an output grid to store results\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Iterate through each hole and check if the target object can be placed\n    for hole_x, hole_y in np.argwhere(interior_mask):\n        target_sprite = crop(target_object, background=Color.BLACK)\n        sprite_height, sprite_width = target_sprite.shape\n        \n        # Check if the target object fits\n        if hole_x + sprite_height <= output_grid.shape[0] and hole_y + sprite_width <= output_grid.shape[1]:\n            hole_area = output_grid[hole_x:hole_x + sprite_height, hole_y:hole_y + sprite_width]\n            if np.all(hole_area == Color.BLACK):\n                blit_sprite(output_grid, target_sprite, hole_x, hole_y, background=Color.BLACK)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a guide object and a target object\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Create a guide object\n    guide_color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.RED])\n    guide_width = np.random.randint(6, 10)\n    guide_height = np.random.randint(6, 10)\n    guide_object = np.full((guide_height, guide_width), guide_color)\n    \n    # Add random holes to the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_width = np.random.randint(1, guide_width - 2)\n        hole_height = np.random.randint(1, guide_height - 2)\n        hole_x = np.random.randint(1, guide_width - hole_width)\n        hole_y = np.random.randint(1, guide_height - hole_height)\n        guide_object[hole_y:hole_y + hole_height, hole_x:hole_x + hole_width] = Color.BLACK\n    \n    # Place the guide object on the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1)\n    blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n    \n    # Create a target object\n    target_width = np.random.randint(2, 5)\n    target_height = np.random.randint(2, 5)\n    target_object = random_sprite(target_height, target_width, color_palette=[Color.RED], background=Color.BLACK)\n    \n    # Place the target object on the grid\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1, border_size=1)\n    blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, guide object, filling, connected components, interior regions\n\n# description:\n# The input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity).\n# For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling.\n# The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Find connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Separate guide and target objects\n    guide_object = [obj for obj in objects if np.any(obj == Color.RED)][0]\n    target_object = [obj for obj in objects if np.any(obj == Color.BLUE)][0]\n\n    # Create an output grid to store the result\n    output_grid = input_grid.copy()\n\n    # Find the interior holes of the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    hole_mask = interior_mask & (guide_object == Color.BLACK)\n\n    # Find the connected components of the holes\n    holes = find_connected_components(hole_mask, background=False, connectivity=4, monochromatic=True)\n\n    # Check if the target object can fit into each hole\n    for hole in holes:\n        hole_sprite = crop(hole, background=False)\n        target_sprite = crop(target_object, background=Color.BLACK)\n\n        # Check if target can be fully or partially filled into the hole\n        if target_sprite.shape[0] <= hole_sprite.shape[0] and target_sprite.shape[1] <= hole_sprite.shape[1]:\n            # Determine placement position\n            hole_x, hole_y = object_position(hole, background=False)\n            # Blit the target object into the hole\n            blit_sprite(output_grid, target_sprite, hole_x, hole_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid\n    grid_size = np.random.randint(12, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Add a guide object (red border)\n    guide_size = np.random.randint(5, grid_size - 2)\n    guide_object = np.full((guide_size, guide_size), Color.RED)\n    guide_object[1:-1, 1:-1] = Color.BLACK\n\n    # Position guide object on the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK, padding=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n\n    # Add a target object (blue)\n    target_size = np.random.randint(2, guide_size - 1)\n    target_object = random_sprite(target_size, target_size, color_palette=[Color.BLUE], background=Color.BLACK)\n    \n    # Position target object on the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, background=Color.BLACK, padding=1)\n    blit_sprite(grid, target_object, target_x, target_y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, guide object, filling, connected components, interior regions\n\n# description:\n# The input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). \n# For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. \n# The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Find the guide object and the target object\n    guide_object = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)[0]\n    target_object = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)[1]\n    \n    # Create a mask for the interior of the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    \n    # Find all the holes inside the guide object\n    holes = find_connected_components(interior_mask & (guide_object == Color.BLACK), background=False, connectivity=4)\n    \n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Check each hole to see if the target object can fit\n    for hole in holes:\n        # Crop the hole and target object to their respective bounding boxes\n        hole_sprite = crop(hole, background=False)\n        target_sprite = crop(target_object, background=Color.BLACK)\n        \n        # Check if the target object can fit into the hole\n        if target_sprite.shape[0] <= hole_sprite.shape[0] and target_sprite.shape[1] <= hole_sprite.shape[1]:\n            # Check if the hole is at least as large as the target object in both dimensions\n            hole_x, hole_y, _, _ = bounding_box(hole, background=False)\n            blit_sprite(output_grid, target_sprite, hole_x, hole_y, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n    \n    # Generate a guide object with random interior holes\n    guide_width = np.random.randint(5, min(width, 10))\n    guide_height = np.random.randint(5, min(height, 10))\n    guide_object = np.full((guide_width, guide_height), Color.RED)\n    \n    # Create holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_width = np.random.randint(1, guide_width // 2)\n        hole_height = np.random.randint(1, guide_height // 2)\n        hole_x = np.random.randint(1, guide_width - hole_width - 1)\n        hole_y = np.random.randint(1, guide_height - hole_height - 1)\n        guide_object[hole_x:hole_x + hole_width, hole_y:hole_y + hole_height] = Color.BLACK\n    \n    # Place the guide object onto the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n    \n    # Generate a target object\n    target_width = np.random.randint(1, 4)\n    target_height = np.random.randint(1, 4)\n    target_object = random_sprite(target_width, target_height, color_palette=[Color.BLUE], background=Color.BLACK)\n    \n    # Place the target object randomly on the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, target_x, target_y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, guide object, filling, connected components, interior regions\n\n# description:\n# The input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Separate guide object and target object\n    guide_input = input_grid.copy()\n    guide_input[input_grid != Color.GREY] = Color.BLACK\n    guide_objects = find_connected_components(guide_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    target_input = input_grid.copy()\n    target_input[input_grid == Color.GREY] = Color.BLACK\n    target_objects = find_connected_components(target_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Assume there's only one target object\n    target_sprite = crop(target_objects[0], background=Color.BLACK)\n    \n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Process each guide object\n    for guide_obj in guide_objects:\n        # Get interior holes of the guide object\n        interior_holes = object_interior(guide_obj, background=Color.BLACK) & (guide_obj == Color.BLACK)\n        \n        # Find connected components of the holes\n        hole_components = find_connected_components(interior_holes, background=False, connectivity=4, monochromatic=True)\n        \n        for hole in hole_components:\n            # Check if the target can be placed in the hole\n            hole_space = crop(hole, background=False)\n            target_mask = target_sprite != Color.BLACK\n            \n            if np.all(hole_space.shape >= target_sprite.shape) and np.all(hole_space[target_mask]):\n                # Store the hole in the output grid by its coordinates\n                x, y = object_position(hole, background=Color.BLACK)\n                hole_coords = np.argwhere(hole) + [x, y]\n                for coord in hole_coords:\n                    output_grid[coord[0], coord[1]] = Color.RED  # Mark viable hole with some color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a guide object and a target object\n    grid_size = np.random.randint(15, 25)\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Create a guide object with random holes\n    guide_width, guide_height = np.random.randint(8, 12, size=2)\n    guide_object = np.full((guide_width, guide_height), Color.GREY)\n    \n    # Add random holes to the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_width, hole_height = np.random.randint(2, 4, size=2)\n        hole = np.full((hole_width, hole_height), Color.BLACK)\n        hole_x, hole_y = random_free_location_for_sprite(guide_object, hole, padding=1, background=Color.GREY)\n        blit_sprite(guide_object, hole, hole_x, hole_y, background=Color.GREY)\n\n    # Place the guide object on the grid\n    guide_x, guide_y = random_free_location_for_sprite(input_grid, guide_object, padding=1, border_size=1)\n    blit_sprite(input_grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n    \n    # Create and place a target object\n    target_size = np.random.randint(2, 4)\n    target_object = random_sprite(target_size, target_size, color_palette=[Color.BLUE], background=Color.BLACK)\n    target_x, target_y = random_free_location_for_sprite(input_grid, target_object, padding=1, border_size=1)\n    blit_sprite(input_grid, target_object, target_x, target_y, background=Color.BLACK)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, guide object, filling, connected components, interior regions\n\n# description:\n# Input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Separate the guide and target objects from the input grid\n    guide_grid = input_grid.copy()\n    target_grid = input_grid.copy()\n\n    # Assume guide object is composed of a specific color (e.g., Color.GREY)\n    guide_grid[input_grid != Color.GREY] = Color.BLACK\n    guide_objects = find_connected_components(guide_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # Assume target object is composed of a specific color (e.g., Color.RED)\n    target_grid[input_grid != Color.RED] = Color.BLACK\n    target_objects = find_connected_components(target_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Ensure there's one guide object and one target object\n    assert len(guide_objects) == 1, \"There should be exactly one guide object\"\n    assert len(target_objects) == 1, \"There should be exactly one target object\"\n    \n    guide_object = guide_objects[0]\n    target_object = target_objects[0]\n\n    # Find interior holes in the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    holes = find_connected_components(interior_mask, background=False, connectivity=4, monochromatic=True)\n\n    # Determine if the target object can fit into any of the holes\n    fit_holes = []\n    target_sprite = crop(target_object, background=Color.BLACK)\n    target_mask = target_sprite != Color.BLACK\n\n    for hole in holes:\n        hole_sprite = crop(hole, background=False)\n        hole_mask = hole_sprite\n        \n        # Check if target can fit into the hole\n        if np.all(hole_mask[:target_sprite.shape[0], :target_sprite.shape[1]] | ~target_mask):\n            fit_holes.append(hole)\n\n    # Create an output list of hole coordinates where the target can fit\n    hole_coordinates = []\n    for hole in fit_holes:\n        hole_coords = np.argwhere(hole)\n        hole_coordinates.append(hole_coords.tolist())\n\n    return hole_coordinates\n\n\ndef generate_input():\n    # Create a grid\n    grid_size = np.random.randint(15, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a guide object with possible interior holes\n    guide_size = np.random.randint(8, 12)\n    guide_object = np.full((guide_size, guide_size), Color.GREY)\n    interior_size = np.random.randint(3, guide_size - 2)\n    \n    # Create random holes in the guide object\n    for _ in range(np.random.randint(1, 3)):\n        hole = random_sprite(interior_size, interior_size, color_palette=[False], background=True)\n        hole_x, hole_y = random_free_location_for_sprite(guide_object, hole, border_size=1, background=Color.GREY)\n        blit_sprite(guide_object, hole, hole_x, hole_y, background=Color.GREY)\n\n    # Place the guide object in the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n\n    # Create a target object\n    target_size = np.random.randint(2, 4)\n    target_object = random_sprite(target_size, target_size, color_palette=[Color.RED], background=Color.BLACK)\n    \n    # Place the target object in the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, target_x, target_y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts: \n# holes, guide object, filling, connected components, interior regions\n\n# description: \n# Input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Separate the guide object from the rest of the input\n    guide_input = input_grid.copy()\n    guide_input[input_grid != Color.GREY] = Color.BLACK\n    guide_objects = find_connected_components(guide_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Separate the target object from the rest of the input\n    target_input = input_grid.copy()\n    target_input[input_grid == Color.GREY] = Color.BLACK\n    target_objects = find_connected_components(target_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Assume there's only one guide object and one target object for simplicity\n    guide_object = guide_objects[0]\n    target_object = target_objects[0]\n    target_sprite = crop(target_object, background=Color.BLACK)\n\n    # Get the interior holes within the guide object\n    interior_holes = object_interior(guide_object, background=Color.BLACK) & (guide_object == Color.BLACK)\n\n    # List to store valid hole positions\n    valid_holes = []\n\n    # Check each interior hole to see if the target object can fit\n    for hole in find_connected_components(interior_holes, background=False, connectivity=4, monochromatic=True):\n        hole_sprite = crop(hole, background=False)\n        if np.array_equal(hole_sprite.shape, target_sprite.shape):\n            # If the shapes match, record the position\n            x, y = object_position(hole, background=False)\n            valid_holes.append((x, y))\n\n    return valid_holes\n\ndef generate_input():\n    # Create a grid of random size\n    width, height = np.random.randint(10, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate a guide object with random holes\n    guide_width, guide_height = np.random.randint(5, 8, size=2)\n    guide_object = np.full((guide_width, guide_height), Color.GREY)\n\n    # Create random interior holes\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_width, hole_height = np.random.randint(1, guide_width // 2), np.random.randint(1, guide_height // 2)\n        hole_sprite = random_sprite(hole_width, hole_height, color_palette=[Color.BLACK], background=Color.GREY)\n        hole_x, hole_y = random_free_location_for_sprite(guide_object, hole_sprite, background=Color.GREY, border_size=1)\n        blit_sprite(guide_object, hole_sprite, hole_x, hole_y, background=Color.GREY)\n\n    # Place the guide object in the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK, padding=1)\n    blit_sprite(grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n\n    # Generate a target object\n    target_width, target_height = np.random.randint(1, min(guide_width, guide_height) - 1, size=2)\n    target_object = random_sprite(target_width, target_height, color_palette=[Color.RED], background=Color.BLACK)\n\n    # Place the target object in the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, background=Color.BLACK, padding=1)\n    blit_sprite(grid, target_object, target_x, target_y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, guide object, filling, connected components, interior regions\n\n# description:\n# Input consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity).\n# For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling.\n# The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Find the guide object and target object\n    guide_object = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    target_object = [obj for obj in guide_object if np.any(obj != Color.GREY)][0]\n    guide_object = [obj for obj in guide_object if np.any(obj == Color.GREY)][0]\n    \n    # Create an output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Find interior holes within the guide object\n    interior_mask = object_interior(guide_object, background=Color.BLACK)\n    hole_mask = interior_mask & (guide_object == Color.BLACK)\n    holes = find_connected_components(hole_mask, background=False, connectivity=4, monochromatic=True)\n    \n    # Process each hole to see if it can fit the target object\n    target_sprite = crop(target_object, background=Color.BLACK)\n    target_mask = target_sprite != Color.BLACK\n    \n    for hole in holes:\n        hole_sprite = crop(hole, background=False)\n        hole_mask = hole_sprite != False\n        \n        # Check if target object fits in the hole\n        if np.all(hole_mask.shape >= target_mask.shape):\n            fits = True\n            for dx in range(hole_mask.shape[0] - target_mask.shape[0] + 1):\n                for dy in range(hole_mask.shape[1] - target_mask.shape[1] + 1):\n                    if np.all(hole_mask[dx:dx+target_mask.shape[0], dy:dy+target_mask.shape[1]] == target_mask):\n                        fits = True\n                        break\n                if fits:\n                    break\n            if fits:\n                # Blit the target object into the hole\n                hole_x, hole_y = object_position(hole, background=False)\n                blit_sprite(output_grid, target_sprite, hole_x + dx, hole_y + dy)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Generate the guide object with random holes\n    guide_object = np.full((np.random.randint(5, 8), np.random.randint(5, 8)), Color.GREY)\n    num_holes = np.random.randint(1, 3)\n    \n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, min(guide_object.shape))\n        hole_x, hole_y = np.random.randint(1, guide_object.shape[0] - hole_size), np.random.randint(1, guide_object.shape[1] - hole_size)\n        guide_object[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n    \n    # Place the guide object in the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, x, y)\n    \n    # Generate the target object\n    target_size = np.random.randint(1, 4)\n    target_object = random_sprite(target_size, target_size, color_palette=[Color.RED], background=Color.BLACK)\n    \n    # Place the target object in the grid\n    try:\n        target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=1)\n        blit_sprite(grid, target_object, target_x, target_y)\n    except ValueError:\n        pass  # If no space, it's okay for this example\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, guide object, filling, connected components, interior regions\n\n# description:\n# The input consists of a guide object and a target object on a grid. \n# Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). \n# For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. \n# The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. \n# The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Extract the guide object\n    guide_input = input_grid.copy()\n    guide_input[input_grid != Color.GREY] = Color.BLACK\n    guide_objects = find_connected_components(guide_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Extract the target object\n    target_input = input_grid.copy()\n    target_input[input_grid == Color.GREY] = Color.BLACK\n    target_objects = find_connected_components(target_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    assert len(guide_objects) == 1, \"There should be exactly one guide object\"\n    assert len(target_objects) == 1, \"There should be exactly one target object\"\n\n    guide_object = guide_objects[0]\n    target_object = target_objects[0]\n    target_sprite = crop(target_object, background=Color.BLACK)\n\n    # Find all interior holes in the guide object\n    guide_interior = object_interior(guide_object, background=Color.BLACK)\n    hole_mask = guide_interior & (guide_object == Color.BLACK)\n    holes = find_connected_components(hole_mask, background=False, connectivity=4, monochromatic=True)\n\n    # Prepare the output as a list of hole coordinates\n    output_holes = []\n\n    for hole in holes:\n        # Check if the target object can be fully or partially placed within the hole\n        hole_crop = crop(hole, background=False)\n        hole_position = object_position(hole, background=False)\n        \n        # Ensure target can fit within the hole\n        if (hole_crop.shape[0] >= target_sprite.shape[0] and\n            hole_crop.shape[1] >= target_sprite.shape[1]):\n            # Check if space is available for the target sprite\n            hole_x, hole_y = hole_position\n            target_x, target_y = object_position(target_sprite, background=Color.BLACK)\n            fit = True\n            for i in range(target_sprite.shape[0]):\n                for j in range(target_sprite.shape[1]):\n                    if target_sprite[i, j] != Color.BLACK and hole_crop[i, j] != True:\n                        fit = False\n                        break\n                if not fit:\n                    break\n\n            if fit:\n                output_holes.append((hole_x, hole_y))\n\n    return output_holes\n\ndef generate_input():\n    # Define grid dimensions\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a guide object with random holes\n    guide_width, guide_height = np.random.randint(5, min(n, m), size=2)\n    guide_object = np.full((guide_width, guide_height), Color.GREY)\n    \n    # Introduce random holes in the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_width, hole_height = np.random.randint(1, min(guide_width, guide_height)//2, size=2)\n        hole_sprite = random_sprite(hole_width, hole_height, color_palette=[Color.BLACK], background=Color.GREY)\n        hole_x, hole_y = random_free_location_for_sprite(guide_object, hole_sprite, border_size=1, background=Color.GREY)\n        blit_sprite(guide_object, hole_sprite, hole_x, hole_y, background=Color.GREY)\n\n    # Add the guide object to the grid\n    guide_x, guide_y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1, background=Color.BLACK)\n    blit_sprite(grid, guide_object, guide_x, guide_y, background=Color.BLACK)\n\n    # Create a target object\n    target_width, target_height = np.random.randint(1, min(guide_width//2, guide_height//2), size=2)\n    target_object = random_sprite(target_width, target_height, color_palette=[Color.RED], background=Color.BLACK)\n\n    # Add the target object to the grid\n    target_x, target_y = random_free_location_for_sprite(grid, target_object, padding=1, border_size=1, background=Color.BLACK)\n    blit_sprite(grid, target_object, target_x, target_y, background=Color.BLACK)\n\n    return grid"], "seeds": ["44d8ac46.py", "228f6490.py", "810b9b61.py", "aba27056.py", "Concepts: \nholes, guide object, filling, connected components, interior regions\n\nDescription: \nInput consists of a guide object and a target object on a grid. Identify all interior holes within the guide object that are not connected to the border (using 4-connectivity). For each hole, determine if the target object can be fully or partially filled into these holes, akin to a Tetris-style filling. The output is a list of hole objects, each represented by its pixel coordinates, where the target object can be placed. The rest of the grid remains unchanged."]}
{"code": ["from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# Input consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border.\n# Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes with a distinct color, such as blue.\n\ndef main(input_grid):\n    # Create an initial copy of the input grid to store the result\n    output_grid = input_grid.copy()\n\n    # Find the boundary of the grid\n    n, m = input_grid.shape\n\n    # Use flood-fill to mark connected components from the border\n    border_connected = np.zeros((n, m), dtype=bool)\n\n    def flood_fill(x, y):\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return\n        if input_grid[x, y] != 0 or border_connected[x, y]:\n            return\n        border_connected[x, y] = True\n        flood_fill(x + 1, y)\n        flood_fill(x - 1, y)\n        flood_fill(x, y + 1)\n        flood_fill(x, y - 1)\n\n    # Apply flood fill from the border\n    for i in range(n):\n        flood_fill(i, 0)\n        flood_fill(i, m - 1)\n    for j in range(m):\n        flood_fill(0, j)\n        flood_fill(n - 1, j)\n\n    # Highlight the enclosed holes\n    for x in range(n):\n        for y in range(m):\n            if input_grid[x, y] == 0 and not border_connected[x, y]:\n                output_grid[x, y] = Color.BLUE  # Highlight enclosed holes\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a single object\n    n, m = np.random.randint(12, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random object\n    obj_n, obj_m = np.random.randint(6, min(n, m) - 2, size=2)\n    obj_x, obj_y = np.random.randint(1, n - obj_n), np.random.randint(1, m - obj_m)\n\n    grid[obj_x:obj_x + obj_n, obj_y:obj_y + obj_m] = Color.RED\n\n    # Add random holes within the object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_n, hole_m = np.random.randint(2, min(obj_n, obj_m) // 2, size=2)\n        hole_x, hole_y = np.random.randint(obj_x + 1, obj_x + obj_n - hole_n), np.random.randint(obj_y + 1, obj_y + obj_m - hole_m)\n        grid[hole_x:hole_x + hole_n, hole_y:hole_y + hole_m] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# The input consists of a grid with a single object and background (0). The object may contain several fully enclosed 0-regions, or \"holes\".\n# The output grid highlights these enclosed holes by changing their color to red. \n# Non-enclosed regions (connected to the grid border) should remain unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = input_grid.copy()\n    \n    # Step 1: Identify all components of 0s\n    zero_components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # Step 2: Flood-fill from the border to identify non-enclosed regions\n    border_connected = np.zeros_like(input_grid, dtype=bool)\n    for x in range(input_grid.shape[0]):\n        for y in [0, input_grid.shape[1]-1]:\n            if input_grid[x, y] == Color.BLACK:\n                border_connected[x, y] = True\n    for y in range(input_grid.shape[1]):\n        for x in [0, input_grid.shape[0]-1]:\n            if input_grid[x, y] == Color.BLACK:\n                border_connected[x, y] = True\n\n    border_connected = flood_fill(input_grid, border_connected, Color.BLACK)\n\n    # Step 3: Highlight the fully enclosed zero regions by changing their color to red\n    for component in zero_components:\n        # Check if the component is fully enclosed by the object\n        component_mask = (component == Color.BLACK)\n        if not np.any(border_connected & component_mask):\n            output_grid[component_mask] = Color.RED\n\n    return output_grid\n\ndef flood_fill(grid, mask, target_color):\n    # A simple flood-fill algorithm to mark all connected regions of target_color\n    from scipy.ndimage import binary_dilation\n    filled = binary_dilation(mask, structure=np.ones((3, 3)), iterations=-1)\n    return filled & (grid == target_color)\n\ndef generate_input():\n    # Create a grid with a single object and background (0)\n    n = np.random.randint(10, 15)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Generate a random monochromatic non-black object\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    obj = random_sprite(n-2, n-2, density=0.7, color_palette=[object_color], background=Color.BLACK)\n\n    # Blit the object into the grid\n    blit_object(input_grid, obj)\n\n    # Introduce some holes (enclosed 0-regions) within the object\n    for _ in range(np.random.randint(1, 4)):\n        hole_size = np.random.randint(2, 4)\n        hole = np.full((hole_size, hole_size), Color.BLACK)\n        try:\n            x, y = random_free_location_for_sprite(input_grid, hole, background=object_color, padding=1)\n            blit_sprite(input_grid, hole, x, y)\n        except ValueError:\n            continue\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# The input consists of a grid with a single object using one color and a black background (0).\n# The task is to identify holes, which are fully enclosed black regions within the object that are not connected to the grid border.\n# The output grid should highlight these enclosed holes with a different color, such as red, while leaving non-enclosed regions the same.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output.\n    output_grid = input_grid.copy()\n\n    # Flood fill from the grid border to identify non-enclosed regions.\n    border_filled = flood_fill_from_border(input_grid)\n\n    # Calculate enclosed regions by finding black areas not connected to the border-filled areas.\n    enclosed_mask = (input_grid == Color.BLACK) & ~border_filled\n\n    # Color enclosed holes with red.\n    output_grid[enclosed_mask] = Color.RED\n\n    return output_grid\n\ndef flood_fill_from_border(grid):\n    # Create a mask to track filled areas starting from the border.\n    filled = np.zeros_like(grid, dtype=bool)\n\n    # Add border pixels to the queue to start flood fill.\n    queue = []\n    n, m = grid.shape\n    for i in range(n):\n        if grid[i, 0] == Color.BLACK:\n            queue.append((i, 0))\n        if grid[i, m - 1] == Color.BLACK:\n            queue.append((i, m - 1))\n    \n    for j in range(m):\n        if grid[0, j] == Color.BLACK:\n            queue.append((0, j))\n        if grid[n - 1, j] == Color.BLACK:\n            queue.append((n - 1, j))\n\n    # Perform flood fill to find all black regions connected to the border.\n    while queue:\n        x, y = queue.pop(0)\n        if filled[x, y] or grid[x, y] != Color.BLACK:\n            continue\n        filled[x, y] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and not filled[nx, ny]:\n                queue.append((nx, ny))\n\n    return filled\n\ndef generate_input():\n    # Create a grid with a size between 10x10 and 20x20.\n    size = np.random.randint(10, 21)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Generate a single object with a random size.\n    object_size = np.random.randint(5, size - 2)\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    object_sprite = random_sprite(object_size, object_size, color_palette=[object_color], background=Color.BLACK)\n\n    # Place the object randomly on the grid.\n    try:\n        x, y = random_free_location_for_sprite(grid, object_sprite, background=Color.BLACK, border_size=1)\n    except ValueError:\n        return generate_input()\n\n    blit_sprite(grid, object_sprite, x, y)\n\n    # Introduce holes within the object.\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, object_size // 2)\n        hole_x, hole_y = np.random.randint(1, object_size - hole_size, size=2)\n        grid[x + hole_x:x + hole_x + hole_size, y + hole_y:y + hole_y + hole_size] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# The input consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border. \n# Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes, typically for further processing or filling.\n\ndef main(input_grid):\n    # Create an output grid that will store the result\n    output_grid = input_grid.copy()\n\n    # Flood-fill from the border to identify non-enclosed regions\n    def flood_fill_from_border(grid, x, y, target_color, replacement_color):\n        if target_color == replacement_color:\n            return\n        if grid[x, y] != target_color:\n            return\n\n        grid[x, y] = replacement_color\n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            for nx, ny in [(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]:\n                if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:\n                    if grid[nx, ny] == target_color:\n                        grid[nx, ny] = replacement_color\n                        stack.append((nx, ny))\n\n    # Mark all non-enclosed 0-regions starting from the border\n    border_color = Color.MAROON  # Temporary color for flood-filled non-enclosed regions\n    for i in range(input_grid.shape[0]):\n        if input_grid[i, 0] == 0:\n            flood_fill_from_border(output_grid, i, 0, 0, border_color)\n        if input_grid[i, -1] == 0:\n            flood_fill_from_border(output_grid, i, -1, 0, border_color)\n\n    for j in range(input_grid.shape[1]):\n        if input_grid[0, j] == 0:\n            flood_fill_from_border(output_grid, 0, j, 0, border_color)\n        if input_grid[-1, j] == 0:\n            flood_fill_from_border(output_grid, -1, j, 0, border_color)\n\n    # Find and highlight enclosed holes\n    enclosed_hole_color = Color.YELLOW\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if output_grid[i, j] == 0:\n                flood_fill_from_border(output_grid, i, j, 0, enclosed_hole_color)\n\n    # Restore non-enclosed regions to the original color\n    output_grid[output_grid == border_color] = 0\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random size from 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    input_grid = np.full((n, n), 0)\n\n    # Create a random object with holes inside\n    object_size = np.random.randint(5, min(n, 10))\n    obj = random_sprite(object_size, object_size, color_palette=[Color.BLUE], background=0)\n\n    # Randomly place the object in the grid\n    try:\n        x, y = random_free_location_for_sprite(input_grid, obj, background=0, border_size=1, padding=1)\n        blit_sprite(input_grid, obj, x, y, background=0)\n    except ValueError:\n        return generate_input()\n\n    # Create random holes inside the object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(2, 5)\n        hole = random_sprite(hole_size, hole_size, color_palette=[0], background=Color.BLUE)\n        try:\n            hx, hy = random_free_location_for_sprite(obj, hole, background=Color.BLUE, border_size=1, padding=1)\n            blit_sprite(obj, hole, hx, hy, background=Color.BLUE)\n        except ValueError:\n            continue\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# The input grid consists of a grid with a single object and a background of black pixels (0). The task is to identify holes, which are fully enclosed regions of black pixels within the object that are not connected to the grid border.\n# The output grid should highlight these enclosed holes for further processing or filling.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    \n    # Flood-fill from the border to detect and exclude non-enclosed regions\n    border_mask = np.zeros_like(input_grid, dtype=bool)\n    for i in range(input_grid.shape[0]):\n        if input_grid[i, 0] == 0:\n            border_mask[i, 0] = True\n        if input_grid[i, -1] == 0:\n            border_mask[i, -1] = True\n    for j in range(input_grid.shape[1]):\n        if input_grid[0, j] == 0:\n            border_mask[0, j] = True\n        if input_grid[-1, j] == 0:\n            border_mask[-1, j] = True\n\n    # Use flood fill to find all connected regions from the border\n    from scipy.ndimage import label\n    labeled_array, num_features = label(border_mask, structure=np.ones((3, 3)))\n    \n    # Identify and highlight enclosed holes\n    for i in range(1, num_features + 1):\n        component = (labeled_array == i)\n        connected_to_border = np.any(component & border_mask)\n        if not connected_to_border:\n            # Highlight enclosed hole\n            output_grid[component] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a single object that is a random shape and fills a significant part of the grid\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    sprite_size = np.random.randint(6, min(n, 10))\n    sprite = random_sprite(sprite_size, sprite_size, color_palette=[object_color], connectivity=4)\n    interior_mask = object_interior(sprite)\n    boundary_mask = object_boundary(sprite)\n    interior_but_not_edges = interior_mask & ~boundary_mask\n    sprite[interior_but_not_edges] = Color.BLACK  # Create potential holes\n\n    # Place the object in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, border_size=0, padding=1)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# The input grid consists of a single contiguous object of arbitrary color(s) on a black background. \n# The goal is to identify regions of black pixels (holes) that are fully enclosed by the object and not connected to the grid border. \n# The output grid should highlight these enclosed holes by coloring them with a specific color, such as yellow.\n\ndef main(input_grid):\n    # Create an output grid initialized to the input grid's content\n    output_grid = input_grid.copy()\n\n    # Find all connected components within the input grid using the background as black\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    \n    # Use flood-fill to identify the border-connected components\n    border_connected = np.zeros(input_grid.shape, dtype=bool)\n    flood_fill(input_grid, border_connected, start_points=[(0, 0)], target_color=Color.BLACK, new_color=True)\n    \n    # For each component identified, check if it's not border-connected\n    for component in components:\n        if not np.any(border_connected & component):\n            # If the component is a hole, color it yellow in the output grid\n            output_grid[component] = Color.YELLOW\n\n    return output_grid\n\ndef flood_fill(grid, mask, start_points, target_color, new_color):\n    \"\"\"\n    Perform a flood-fill algorithm on the grid starting from the given points, \n    marking the mask with new_color where target_color is found.\n    \"\"\"\n    stack = list(start_points)\n    while stack:\n        x, y = stack.pop()\n        if mask[x, y] or grid[x, y] != target_color:\n            continue\n        mask[x, y] = new_color\n        # Add neighbors to the stack\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:\n                stack.append((nx, ny))\n\ndef generate_input():\n    # Create a 10x10 to 20x20 grid\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a single contiguous object of arbitrary color(s)\n    object_colors = [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY]\n    obj_color = np.random.choice(object_colors)\n    object_size = np.random.randint(5, min(n, 10))\n    \n    # Generate a random sprite with potential holes\n    sprite = random_sprite(object_size, object_size, color_palette=[obj_color], background=Color.BLACK)\n    \n    # Ensure it has at least one fully enclosed hole\n    hole_size = np.random.randint(1, object_size - 1)\n    hole_x, hole_y = np.random.randint(1, object_size - hole_size), np.random.randint(1, object_size - hole_size)\n    sprite[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Place the sprite into the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n    except ValueError:\n        return generate_input()\n    \n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# Input consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border. \n# Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes, typically for further processing or filling.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = input_grid.copy()\n\n    # Find the object in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    assert len(objects) == 1, \"There should be exactly one object in the input grid.\"\n    obj = objects[0]\n\n    # Find the boundaries of the object\n    boundary_mask = object_boundary(obj, background=Color.BLACK)\n\n    # Flood-fill from the border to identify non-enclosed regions\n    border_filled = np.zeros_like(input_grid, dtype=bool)\n    flood_fill_from_border(border_filled, input_grid, boundary_mask)\n\n    # Identify enclosed holes by finding regions not touched by the flood-fill\n    enclosed_holes = (input_grid == Color.BLACK) & ~border_filled\n\n    # Highlight enclosed holes in the output grid\n    output_grid[enclosed_holes] = Color.RED  # Mark enclosed holes with red, for example\n\n    return output_grid\n\ndef flood_fill_from_border(filled_grid, input_grid, boundary_mask):\n    # Use a queue for flood-fill\n    queue = []\n\n    # Start from the border and add all boundary points to the queue\n    for x, y in np.argwhere(boundary_mask):\n        queue.append((x, y))\n        filled_grid[x, y] = True\n\n    # Perform flood-fill\n    while queue:\n        x, y = queue.pop(0)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # 4-way connectivity\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:\n                if not filled_grid[nx, ny] and input_grid[nx, ny] == Color.BLACK:\n                    filled_grid[nx, ny] = True\n                    queue.append((nx, ny))\n\ndef generate_input():\n    # Generate a grid of size between 10x10 and 20x20 with a single object\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a single random object and place it in the grid\n    obj_size = np.random.randint(5, n - 1)\n    object_sprite = random_sprite(obj_size, obj_size, color_palette=[Color.BLUE], connectivity=8)\n\n    # Ensure there's at least one enclosed region (hole) inside the object\n    hole_size = np.random.randint(2, obj_size - 2)\n    hole_x, hole_y = np.random.randint(1, obj_size - hole_size), np.random.randint(1, obj_size - hole_size)\n    object_sprite[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Place the object on the grid\n    obj_x, obj_y = random_free_location_for_sprite(grid, object_sprite, border_size=1, padding=1)\n    blit_sprite(grid, object_sprite, obj_x, obj_y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# The input grid consists of a single object on a black background (0), with some internal regions that are also black (0).\n# These internal black regions might be fully enclosed \"holes\" by the object itself, or they might be connected to the grid's border via the black background.\n# The task is to find and highlight those fully enclosed holes by changing their color to red, leaving the rest of the grid unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid for processing\n    output_grid = input_grid.copy()\n\n    # Identify all connected components using black (0) as the background\n    connected_components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Create a mask for flood-fill from the border\n    border_flood_fill = np.zeros_like(input_grid, dtype=bool)\n    flood_fill_stack = [(0, 0)]  # Start flood-fill from a corner\n    while flood_fill_stack:\n        x, y = flood_fill_stack.pop()\n        if border_flood_fill[x, y] or input_grid[x, y] != Color.BLACK:\n            continue\n        border_flood_fill[x, y] = True\n        # Check 4-connectivity neighbors\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:\n                flood_fill_stack.append((nx, ny))\n\n    # Process each connected component\n    for component in connected_components:\n        # Check if the component is fully enclosed\n        is_hole = np.all(component[border_flood_fill] == Color.BLACK)\n        if is_hole:\n            # Highlight the hole by coloring it red\n            component[component == Color.BLACK] = Color.RED\n        # Blit the component back onto the output grid\n        blit_object(output_grid, component, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 12x12 grid with a single object on a black background\n    grid = np.full((12, 12), Color.BLACK)\n\n    # Randomly generate a single object with possible enclosed holes\n    object_size = np.random.randint(6, 10)\n    obj = random_sprite(object_size, object_size, color_palette=[Color.BLUE], background=Color.BLACK)\n    \n    # Randomly create holes within the object\n    num_holes = np.random.randint(1, 3)\n    for _ in range(num_holes):\n        hole_size = np.random.randint(1, object_size // 2)\n        hole_x, hole_y = np.random.randint(1, object_size - hole_size, size=2)\n        obj[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n    # Place the object onto the grid\n    x, y = 1, 1  # Place the object with a buffer from the grid edges\n    blit_sprite(grid, obj, x, y, background=Color.BLACK)\n\n    return grid"], "seeds": ["44d8ac46.py", "810b9b61.py", "e73095fd.py", "00d62c1b.py", "Concepts: \nholes, enclosed regions, flood-fill, background components\n\nDescription: \nInput consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border. Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes, typically for further processing or filling."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# The input consists of a grid with at least two distinct objects: a target object and a guide object.\n# Identify the target object and change its color to match the color of the guide object. \n# The guide object is distinct and serves as the reference for the new color.\n# All other grid elements remain unchanged.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Detect all objects in the grid\n    objects = find_connected_components(grid=input_grid, connectivity=4)\n\n    # Assume the largest object is the target and the smallest is the guide\n    target_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    guide_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Find the color of the guide object\n    guide_color = guide_object[guide_object != Color.BLACK][0]\n\n    # Change the color of the target object to match the guide object\n    target_object[target_object != Color.BLACK] = guide_color\n\n    # Place all objects back into the output grid\n    output_grid = np.zeros_like(input_grid)\n    for obj in objects:\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Define grid size\n    grid_size = 10\n\n    # Create an empty grid\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a target object with a random color\n    target_color = random.choice(Color.NOT_BLACK)\n    target_object = random_sprite(n=[3, 4, 5], m=[3, 4, 5], color_palette=[target_color])\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1)\n    grid = blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n\n    # Generate a guide object with a different random color\n    guide_color = random.choice([c for c in Color.NOT_BLACK if c != target_color])\n    guide_object = random_sprite(n=[1, 2], m=[1, 2], color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    grid = blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    # Optionally, add more random objects to fill the grid\n    while True:\n        random_color = random.choice(Color.NOT_BLACK)\n        random_object = random_sprite(n=[1, 2, 3], m=[1, 2, 3], color_palette=[random_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, random_object, padding=1)\n            grid = blit_sprite(grid, random_object, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# The input grid contains at least two distinct objects: a target object and a guide object. \n# The task is to identify the target object and change its color to match the guide object's color. \n# The guide object serves as the reference for the new color. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n\n    # There should be at least two objects: one guide and one target\n    assert len(objects) >= 2\n\n    # Randomly choose one object to be the guide and the rest as potential targets\n    guide_object = random.choice(objects)\n    potential_targets = [obj for obj in objects if not np.array_equal(obj, guide_object)]\n\n    # Extract the guide object's color\n    guide_color = guide_object[guide_object != Color.BLACK][0]\n\n    # Randomly choose one of the potential targets to be the actual target object\n    target_object = random.choice(potential_targets)\n\n    # Recolor the target object with the guide object's color\n    target_object[target_object != Color.BLACK] = guide_color\n\n    # Create the output grid and blit all objects back to it\n    output_grid = np.zeros_like(input_grid)\n    for obj in objects:\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate and place the guide object\n    guide_color = random.choice(Color.NOT_BLACK)\n    guide_object = random_sprite(n=[2, 3], m=[2, 3], color_palette=[guide_color])\n    x_guide, y_guide = random_free_location_for_sprite(grid, guide_object, padding=1)\n    grid = blit_sprite(grid, guide_object, x_guide, y_guide, background=Color.BLACK)\n\n    # Generate and place the target object and additional objects\n    target_color = random.choice([c for c in Color.NOT_BLACK if c != guide_color])\n    target_object = random_sprite(n=[2, 3], m=[2, 3], color_palette=[target_color])\n    x_target, y_target = random_free_location_for_sprite(grid, target_object, padding=1)\n    grid = blit_sprite(grid, target_object, x_target, y_target, background=Color.BLACK)\n\n    # Fill remaining space with additional random objects\n    while True:\n        obj_color = random.choice(Color.NOT_BLACK)\n        obj = random_sprite(n=[1, 2, 3], m=[1, 2, 3], color_palette=[obj_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# The input consists of a grid with at least two distinct objects: a target object and a guide object.\n# Identify the target object and change its color to match the color of the guide object. The guide object is distinct \n# and serves as the reference for the new color. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find all the objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Assume the largest object is the guide object\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Determine the color of the guide object\n    guide_color = input_grid[guide_object != Color.BLACK][0]\n\n    # Assume the smallest object is the target object\n    target_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Recolor the target object to match the guide object\n    output_grid = input_grid.copy()\n    target_coords = np.argwhere(target_object != Color.BLACK)\n    for x, y in target_coords:\n        output_grid[x, y] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate a guide object with a random color\n    guide_color = random.choice(Color.NOT_BLACK)\n    guide_object = random_sprite(3, 3, color_palette=[guide_color], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1, border_size=1)\n    blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    # Generate a target object with a different random color\n    target_color = random.choice([c for c in Color.NOT_BLACK if c != guide_color])\n    target_object = random_sprite(2, 2, color_palette=[target_color], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1, border_size=1)\n    blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# Input consists of a grid with at least two distinct objects: a target object and a guide object.\n# Identify the target object and change its color to match the color of the guide object.\n# The guide object is distinct and serves as the reference for the new color.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Assume the last object is the guide object\n    guide_object = objects[-1]\n\n    # Determine the color of the guide object\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Assume the first object is the target object\n    target_object = objects[0]\n\n    # Change the color of the target object to match the guide object\n    target_object[target_object != Color.BLACK] = guide_color\n\n    # Create an output grid, initially a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Place the recolored target object back into the grid\n    output_grid = blit_object(output_grid, target_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate a target object with a random color\n    target_color = random.choice(Color.NOT_BLACK)\n    target_object = random_sprite(3, 3, color_palette=[target_color], connectivity=8)\n\n    # Generate a guide object with a different random color\n    guide_color = random.choice([c for c in Color.NOT_BLACK if c != target_color])\n    guide_object = random_sprite(2, 2, color_palette=[guide_color], connectivity=8)\n\n    # Place the target object randomly in the grid\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n\n    # Place the guide object randomly in the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# Input consists of a grid with at least two distinct objects: a target object and a guide object.\n# Identify the target object and change its color to match the color of the guide object.\n# The guide object is distinct and serves as the reference for the new color. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=4)\n\n    # Assuming the first object is the target and the second is the guide for simplicity\n    # In a real scenario, you'd have more complex logic to distinguish them\n    target_object = objects[0]\n    guide_object = objects[1]\n\n    # Determine the color of the guide object\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Change the color of the target object to match the guide object's color\n    target_object[target_object != Color.BLACK] = guide_color\n\n    # Create the output grid and blit the modified target object back\n    output_grid = np.copy(input_grid)\n    output_grid = blit_object(output_grid, target_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a target object\n    target_color = np.random.choice(Color.NOT_BLACK)\n    target_object = random_sprite(n=[2, 3], m=[2, 3], color_palette=[target_color], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, target_object, background=Color.BLACK, padding=1)\n    blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n\n    # Create a guide object with a different color\n    guide_color = np.random.choice([c for c in Color.NOT_BLACK if c != target_color])\n    guide_object = random_sprite(n=[2, 3], m=[2, 3], color_palette=[guide_color], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, guide_object, background=Color.BLACK, padding=1)\n    blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# Input consists of a grid with at least two distinct objects: a target object and a guide object.\n# Identify the target object and change its color to match the color of the guide object.\n# The guide object is distinct and serves as the reference for the new color. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Extract all objects from the grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # Separate objects into the target object and the guide object\n    # For simplicity, let's assume the guide object is always the smallest object\n    # And the target object is the largest object\n    objects_sorted = sorted(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    guide_object = objects_sorted[0]\n    target_object = objects_sorted[-1]\n\n    # Find the color of the guide object\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Recolor the target object to match the guide object's color\n    target_object[target_object != Color.BLACK] = guide_color\n\n    # Place the modified target object back into the grid\n    output_grid = np.copy(input_grid)\n    output_grid = blit_object(output_grid, target_object, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a target object\n    target_size = np.random.randint(4, 8)\n    target_color = random.choice(Color.NOT_BLACK)\n    target_object = random_sprite(target_size, target_size, color_palette=[target_color])\n\n    # Generate a guide object\n    guide_size = np.random.randint(2, 4)\n    guide_color = random.choice([c for c in Color.NOT_BLACK if c != target_color])\n    guide_object = random_sprite(guide_size, guide_size, color_palette=[guide_color])\n\n    # Place the target object in the grid\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1)\n    grid = blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n\n    # Place the guide object in the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    grid = blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# The input consists of a grid with at least two distinct objects: a target object and a guide object.\n# Identify the target object and change its color to match the color of the guide object. The guide object is distinct and serves as the reference for the new color. All other grid elements remain unchanged.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n    \n    # Assume the first object is the guide and the second object is the target\n    # The guide object is the one with the largest area\n    guide_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # The target object is the one with the smallest area (excluding black background)\n    target_object = min((obj for obj in objects if obj is not guide_object), key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Get the color of the guide object\n    guide_color = input_grid[guide_object.nonzero()[0][0], guide_object.nonzero()[1][0]]\n\n    # Change the color of the target object to match the guide object\n    for x, y in zip(*target_object.nonzero()):\n        input_grid[x, y] = guide_color\n    \n    return input_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate a guide object\n    guide_color = random.choice(Color.NOT_BLACK)\n    guide_object = random_sprite(n=[2, 3], m=[2, 3], color_palette=[guide_color], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    # Generate a target object\n    target_color = random.choice([c for c in Color.NOT_BLACK if c != guide_color])\n    target_object = random_sprite(n=[2, 3], m=[2, 3], color_palette=[target_color], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1)\n    blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n\n    # Optionally, add more objects to the grid\n    for _ in range(np.random.randint(1, 3)):\n        obj_color = random.choice(Color.NOT_BLACK)\n        obj = random_sprite(n=[2, 3], m=[2, 3], color_palette=[obj_color], connectivity=4)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, guide object, connected components\n\n# description:\n# The input consists of a grid with at least two distinct objects: a target object and a guide object.\n# Identify the target object and change its color to match the color of the guide object.\n# The guide object is distinct and serves as the reference for the new color.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    # Assume the guide object is the smallest object by area\n    guide_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Get color of the guide object\n    guide_color = input_grid[guide_object != Color.BLACK][0]\n\n    # Assume the target object is the largest object by area\n    # (which is not the guide object)\n    target_object = max(\n        [obj for obj in objects if not np.array_equal(obj, guide_object)],\n        key=lambda obj: np.sum(obj != Color.BLACK)\n    )\n\n    # Create an output grid by copying the input grid\n    output_grid = input_grid.copy()\n\n    # Recolor the target object to guide's color\n    output_grid[target_object != Color.BLACK] = guide_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 10x10 grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate a guide object with a random color\n    guide_color = random.choice(Color.NOT_BLACK)\n    guide_object = random_sprite(2, 2, color_palette=[guide_color])\n\n    # Place the guide object on the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    grid = blit_sprite(grid, guide_object, x, y, background=Color.BLACK)\n\n    # Generate a target object with a different random color\n    target_color = random.choice([c for c in Color.NOT_BLACK if c != guide_color])\n    target_object = random_sprite(list(range(3, 5)), list(range(3, 5)), color_palette=[target_color])\n\n    # Place the target object on the grid\n    x, y = random_free_location_for_sprite(grid, target_object, padding=1)\n    grid = blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n\n    return grid"], "seeds": ["d2abd087.py", "aedd82e4.py", "1f642eb9.py", "06df4c85.py", "Concepts: \nrecolor, guide object, connected components\n\nDescription: \nInput consists of a grid with at least two distinct objects: a target object and a guide object. Identify the target object and change its color to match the color of the guide object. The guide object is distinct and serves as the reference for the new color. All other grid elements remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# Input consists of multiple distinct objects on a grid, each with a unique color. Identify the guide object as the one whose color is not shared by any other object in the grid. The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all distinct monochromatic objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8, background=Color.BLACK)\n    \n    # Determine the color of each object\n    color_counts = {}\n    for obj in objects:\n        color = object_colors(obj, background=Color.BLACK)[0]\n        color_counts[color] = color_counts.get(color, 0) + 1\n    \n    # Identify the guide object by its unique color\n    guide_object = None\n    for obj in objects:\n        color = object_colors(obj, background=Color.BLACK)[0]\n        if color_counts[color] == 1:\n            guide_object = obj\n            break\n    \n    # Create an output grid where only the guide object is highlighted\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    if guide_object is not None:\n        blit_object(output_grid, guide_object, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n    \n    n_objects = np.random.randint(3, 6)\n    used_colors = set()\n    \n    # Create and place objects with unique colors\n    for _ in range(n_objects):\n        while True:\n            color = random.choice(list(Color.NOT_BLACK - used_colors))\n            used_colors.add(color)\n            sprite = random_sprite([2, 3, 4], [2, 3, 4], color_palette=[color])\n            try:\n                x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n                blit_sprite(grid, sprite, x, y)\n                break\n            except ValueError:\n                continue\n    \n    # Add one more object with a unique color as the guide object\n    while True:\n        guide_color = random.choice(list(Color.NOT_BLACK - used_colors))\n        guide_sprite = random_sprite([2, 3, 4], [2, 3, 4], color_palette=[guide_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, guide_sprite, padding=1)\n            blit_sprite(grid, guide_sprite, x, y)\n            break\n        except ValueError:\n            continue\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# The input consists of multiple distinct objects on a grid, each with a unique color. Identify the guide object as the\n# one whose color is not shared by any other object in the grid. The output is a transformation where the guide object\n# is selected based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Step 1: Extract all objects from the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Step 2: Determine the color of each object\n    color_to_object = {}\n    for obj in objects:\n        obj_colors = object_colors(obj, background=Color.BLACK)\n        # Since the objects are monochromatic, we take the first color\n        color = obj_colors[0]\n        if color in color_to_object:\n            color_to_object[color].append(obj)\n        else:\n            color_to_object[color] = [obj]\n\n    # Step 3: Identify the guide object with a unique color\n    guide_object = None\n    for color, objs in color_to_object.items():\n        if len(objs) == 1:  # Unique color\n            guide_object = objs[0]\n            break\n\n    # Step 4: Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 5: Place the guide object on the output grid\n    if guide_object is not None:\n        blit_object(output_grid, guide_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define possible colors excluding black\n    colors = list(Color.NOT_BLACK)\n\n    # Generate random objects with unique colors\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        # Randomly select a color for the object\n        object_color = colors.pop(np.random.randint(0, len(colors)))\n\n        # Generate a random sprite for the object\n        sprite = random_sprite(n=[2, 3, 4], m=[2, 3, 4], color_palette=[object_color])\n\n        # Place the sprite on the grid at a random free location\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no free location is found, skip this object\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# The input consists of multiple distinct objects on a grid, each with a unique color.\n# Identify the guide object as the one whose color is not shared by any other object in the grid.\n# The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Count occurrences of each color in the grid\n    color_count = {}\n    for obj in objects:\n        color = object_colors(obj, background=Color.BLACK)[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    # Identify the unique color that appears only once\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n    \n    # Create a copy of the input grid for the output\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find and copy the guide object with the unique color to the output grid\n    for obj in objects:\n        obj_color = object_colors(obj, background=Color.BLACK)[0]\n        if obj_color == unique_color:\n            blit_object(output_grid, obj, background=Color.BLACK)\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Random grid size\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate a set of unique colors for the objects\n    n_objects = np.random.randint(3, 6)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=n_objects, replace=False)\n\n    # Place objects with unique colors on the grid\n    for color in colors:\n        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[color])\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# The input consists of multiple distinct objects on a grid, each with a unique color. \n# Identify the guide object as the one whose color is not shared by any other object in the grid. \n# The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Detect all the objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8, background=Color.BLACK)\n\n    # Determine the colors of each object\n    color_count = {}\n    for obj in objects:\n        colors = object_colors(obj, background=Color.BLACK)\n        for color in colors:\n            if color not in color_count:\n                color_count[color] = 0\n            color_count[color] += 1\n\n    # Find the unique colored object\n    unique_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Highlight the unique object by changing its color to a specific highlight color (e.g., TEAL)\n    highlight_color = Color.TEAL\n    for obj in objects:\n        if unique_color in object_colors(obj, background=Color.BLACK):\n            mask = obj != Color.BLACK\n            output_grid[mask] = highlight_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random objects, each with a unique color\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # List of possible colors\n    colors = list(Color.NOT_BLACK)\n\n    # Randomly shuffle colors to ensure uniqueness\n    np.random.shuffle(colors)\n\n    # Determine how many objects to create\n    num_objects = np.random.randint(3, min(8, len(colors)))\n\n    # Generate and place objects on the grid\n    for i in range(num_objects):\n        color = colors.pop()  # Use a unique color for each object\n        sprite = random_sprite(n=[2, 3, 4], m=[2, 3, 4], color_palette=[color], connectivity=8)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue  # If no space is available, skip this sprite\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# The input consists of multiple distinct objects on a grid, each with a unique color.\n# Identify the guide object as the one whose color is not shared by any other object in the grid.\n# The output is a transformation where the guide object is preserved based on its unique color,\n# while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Extract all objects from the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    # Count the occurrences of each color\n    color_count = {}\n    for obj in objects:\n        color = object_colors(obj)[0]\n        if color not in color_count:\n            color_count[color] = 0\n        color_count[color] += 1\n\n    # Identify the unique guide object\n    guide_object = None\n    for obj in objects:\n        color = object_colors(obj)[0]\n        if color_count[color] == 1:\n            guide_object = obj\n            break\n\n    # Create a blank output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Blit all objects onto the output grid keeping their original state\n    for obj in objects:\n        if obj is guide_object:\n            blit_object(output_grid, obj, background=Color.BLACK)\n        else:\n            blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid size\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Choose a random color for the unique guide object\n    unique_color = random.choice(list(Color.ALL_COLORS))\n\n    # Create the unique guide object\n    guide_sprite = random_sprite(n=[2, 3, 4], m=[2, 3, 4], color_palette=[unique_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK, border_size=1, padding=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Create other objects with non-unique colors\n    for _ in range(np.random.randint(3, 6)):\n        # Choose a color different from the unique color\n        object_color = random.choice([color for color in Color.ALL_COLORS if color != unique_color])\n        sprite = random_sprite(n=[2, 3, 4], m=[2, 3, 4], color_palette=[object_color])\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# Input consists of multiple distinct objects on a grid, each with a unique color. Identify the guide object as the one whose color is not shared by any other object in the grid. The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    \n    # Find the unique color among all objects\n    color_count = {}\n    for obj in objects:\n        color = object_colors(obj, background=Color.BLACK)[0]\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n    \n    # Identify the guide object color\n    guide_color = None\n    for color, count in color_count.items():\n        if count == 1:\n            guide_color = color\n            break\n    \n    # Create output grid, highlighting the guide object\n    output_grid = input_grid.copy()\n    for obj in objects:\n        obj_color = object_colors(obj, background=Color.BLACK)[0]\n        if obj_color == guide_color:\n            # Highlight the guide object\n            output_grid[obj != Color.BLACK] = obj_color\n        else:\n            # Set other objects to black\n            output_grid[obj != Color.BLACK] = Color.BLACK\n\n    return output_grid\n\ndef generate_input():\n    # Define grid dimensions\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a list of unique colors\n    available_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(available_colors)\n\n    # Number of objects to place\n    num_objects = np.random.randint(3, len(available_colors) + 1)\n\n    # Place objects with unique colors\n    for _ in range(num_objects):\n        # Randomly select a color for the object\n        color = available_colors.pop()\n        \n        # Generate a sprite for the object\n        sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), color_palette=[color])\n        \n        # Place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n        blit_sprite(grid, sprite, x, y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# Input consists of multiple distinct objects on a grid, each with a unique color. Identify the guide object as the one whose color is not shared by any other object in the grid. The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Extract all objects from the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Determine the color of each object\n    object_color_map = {tuple(object_colors(obj, background=Color.BLACK)): obj for obj in objects}\n\n    # Count the occurrences of each color in the objects\n    color_counts = {}\n    for color_tuple in object_color_map.keys():\n        color = color_tuple[0]\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    # Identify the guide object as the one with a unique color\n    guide_object = None\n    for color, count in color_counts.items():\n        if count == 1:\n            guide_object = object_color_map[(color,)]\n            break\n\n    # Create the output grid with only the guide object\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    if guide_object is not None:\n        blit_object(output_grid, guide_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Define the grid size\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Select a set of colors, ensuring one of the colors will be unique\n    all_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(all_colors)\n    unique_color = all_colors.pop()\n    other_colors = all_colors[:np.random.randint(3, 5)]\n\n    # Generate objects with the non-unique colors\n    for color in other_colors:\n        for _ in range(np.random.randint(1, 3)):\n            sprite = random_sprite([3, 4], [3, 4], color_palette=[color])\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y)\n\n    # Generate a single object with the unique color\n    unique_sprite = random_sprite([3, 4], [3, 4], color_palette=[unique_color])\n    x, y = random_free_location_for_sprite(grid, unique_sprite, background=Color.BLACK, border_size=1, padding=1)\n    blit_sprite(grid, unique_sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# unique color identification, guide object selection, connected components\n\n# description:\n# Input consists of multiple distinct objects on a grid, each with a unique color.\n# Identify the guide object as the one whose color is not shared by any other object in the grid.\n# The output is a transformation where the guide object is highlighted based on its unique color, while all other objects remain unchanged.\n\ndef main(input_grid):\n    # Find all objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8, background=Color.BLACK)\n    \n    # Get the color of each object\n    object_color_map = {tuple(object_colors(obj, background=Color.BLACK)): obj for obj in objects}\n    \n    # Determine the unique color\n    color_counts = {}\n    for color in object_color_map.keys():\n        color_counts[color] = color_counts.get(color, 0) + 1\n    \n    unique_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            unique_color = color\n            break\n    \n    # Create the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Highlight the guide object with unique color\n    if unique_color:\n        guide_object = object_color_map[unique_color]\n        guide_mask = guide_object != Color.BLACK\n        output_grid[guide_mask] = Color.YELLOW  # Highlight the unique object with yellow\n    \n    return output_grid\n\n\ndef generate_input():\n    # Initialize grid dimensions\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Define possible colors\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n    \n    # Create multiple distinct objects with unique colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        if not colors:\n            break\n        color = colors.pop()\n        sprite_size = np.random.randint(2, 4, size=2)\n        sprite = random_sprite(sprite_size[0], sprite_size[1], color_palette=[color])\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue\n    \n    return grid"], "seeds": ["776ffc46.py", "aedd82e4.py", "d2abd087.py", "e509e548.py", "Concepts: \nunique color identification, guide object selection, connected components\n\nDescription: \nInput consists of multiple distinct objects on a grid, each with a unique color. Identify the guide object as the one whose color is not shared by any other object in the grid. The output is a transformation where the guide object is selected based on its unique color, while all other objects remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# The input grid contains full-length separator rows or columns of a single color that divide the grid into distinct regions.\n# The task is to identify these separators and use them to partition the grid into contiguous sub-grids.\n# Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves.\n# The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    height, width = input_grid.shape\n    separator_color = None\n    \n    # Determine the separator color by finding any row or column with a single color\n    for i in range(height):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            separator_color = input_grid[i, 0]\n            break\n    if separator_color is None:\n        for j in range(width):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                separator_color = input_grid[0, j]\n                break\n\n    assert separator_color is not None, \"No separator color found\"\n    \n    # Find separator rows and columns\n    separator_rows = [i for i in range(height) if np.all(input_grid[i, :] == separator_color)]\n    separator_cols = [j for j in range(width) if np.all(input_grid[:, j] == separator_color)]\n\n    # Ensure the first and last indexes are included for proper slicing\n    if separator_rows[0] != 0:\n        separator_rows = [0] + separator_rows\n    if separator_rows[-1] != height - 1:\n        separator_rows = separator_rows + [height]\n\n    if separator_cols[0] != 0:\n        separator_cols = [0] + separator_cols\n    if separator_cols[-1] != width - 1:\n        separator_cols = separator_cols + [width]\n\n    # Create sub-grids\n    sub_grids = []\n    for i in range(len(separator_rows) - 1):\n        for j in range(len(separator_cols) - 1):\n            row_start, row_end = separator_rows[i] + 1, separator_rows[i + 1]\n            col_start, col_end = separator_cols[j] + 1, separator_cols[j + 1]\n            sub_grid = input_grid[row_start:row_end, col_start:col_end]\n            sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.NOT_BLACK), (height, width))\n\n    # Randomly decide on the separator color\n    separator_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Randomly select the number of separators\n    n_separator_rows = np.random.randint(1, 4)\n    n_separator_cols = np.random.randint(1, 4)\n\n    # Place separator rows and columns\n    separator_rows = randomly_spaced_indices(height, n_separator_rows, border_size=1, padding=1)\n    separator_cols = randomly_spaced_indices(width, n_separator_cols, border_size=1, padding=1)\n\n    for r in separator_rows:\n        grid[r, :] = separator_color\n    for c in separator_cols:\n        grid[:, c] = separator_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# The input grid contains full-length separator rows or columns of a single color that divide the grid into distinct regions.\n# The task is to identify these separators and use them to partition the grid into contiguous sub-grids.\n# Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves.\n# The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Identify the background color\n    unique_colors = np.unique(input_grid)\n    background_color = [color for color in unique_colors if np.all(input_grid == color, axis=0).any() or np.all(input_grid == color, axis=1).any()]\n    assert background_color, \"No separator color found\"\n    separator_color = background_color[0]\n\n    # Find the separator lines\n    vertical_separators = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == separator_color)]\n    horizontal_separators = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == separator_color)]\n\n    # Add edges as separators\n    vertical_separators = [0] + vertical_separators + [input_grid.shape[0]]\n    horizontal_separators = [0] + horizontal_separators + [input_grid.shape[1]]\n\n    # Deduplicate successive lines\n    vertical_separators = [x for i, x in enumerate(vertical_separators) if i == 0 or x != vertical_separators[i - 1]]\n    horizontal_separators = [y for i, y in enumerate(horizontal_separators) if i == 0 or y != horizontal_separators[i - 1]]\n\n    # Extract sub-grids\n    sub_grids = []\n    for i in range(1, len(vertical_separators)):\n        for j in range(1, len(horizontal_separators)):\n            x1, x2 = vertical_separators[i-1]+1, vertical_separators[i]\n            y1, y2 = horizontal_separators[j-1]+1, horizontal_separators[j]\n            sub_grid = input_grid[x1:x2, y1:y2]\n            if sub_grid.size > 0:\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly determine grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(list(Color.ALL_COLORS), (width, height))\n\n    # Choose a separator color\n    separator_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly place vertical and horizontal separators\n    num_vertical_separators = np.random.randint(2, 5)\n    num_horizontal_separators = np.random.randint(2, 5)\n\n    vertical_positions = randomly_spaced_indices(width, num_vertical_separators, border_size=1, padding=1)\n    horizontal_positions = randomly_spaced_indices(height, num_horizontal_separators, border_size=1, padding=1)\n\n    for x in vertical_positions:\n        grid[x, :] = separator_color\n\n    for y in horizontal_positions:\n        grid[:, y] = separator_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# Input is a grid containing full-length separator rows or columns of a single color that divide the grid into distinct regions.\n# Identify these separators and use them to partition the grid into contiguous sub-grids.\n# Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves.\n# The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect full-length separator rows and columns.\n    # 2. Partition the grid into sub-grids between consecutive separators.\n    # 3. Return the list of sub-grids.\n\n    width, height = input_grid.shape\n    background = Color.BLACK\n\n    # 1. Detecting separator lines\n    vertical_separators = [x for x in range(width) if np.all(input_grid[x, :] == background)]\n    horizontal_separators = [y for y in range(height) if np.all(input_grid[:, y] == background)]\n\n    # Add boundaries as virtual separators\n    vertical_separators = [0] + vertical_separators + [width]\n    horizontal_separators = [0] + horizontal_separators + [height]\n\n    # 2. Extract sub-grids\n    sub_grids = []\n    for i in range(len(vertical_separators) - 1):\n        for j in range(len(horizontal_separators) - 1):\n            x1, x2 = vertical_separators[i], vertical_separators[i + 1]\n            y1, y2 = horizontal_separators[j], horizontal_separators[j + 1]\n\n            # Extracting sub-grid without the separators\n            if x2 > x1 + 1 and y2 > y1 + 1:\n                sub_grid = input_grid[x1+1:x2, y1+1:y2]\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n\n    # Randomly select the number of separators\n    num_vertical_separators = np.random.randint(1, 4)\n    num_horizontal_separators = np.random.randint(1, 4)\n\n    # Randomly choose separator color\n    separator_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Generate vertical separators\n    vertical_separators = randomly_spaced_indices(width, num_vertical_separators, border_size=1, padding=2)\n    for x in vertical_separators:\n        grid[x, :] = separator_color\n\n    # Generate horizontal separators\n    horizontal_separators = randomly_spaced_indices(height, num_horizontal_separators, border_size=1, padding=2)\n    for y in horizontal_separators:\n        grid[:, y] = separator_color\n\n    return grid", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# The input is a grid containing full-length separator rows or columns of a single color. These separators divide the grid into distinct regions.\n# The task is to identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves.\n# The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    separator_color = None\n\n    # Detect separator color by finding any complete row or column of the same color\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            separator_color = input_grid[i, 0]\n            break\n\n    for j in range(input_grid.shape[1]):\n        if np.all(input_grid[:, j] == input_grid[0, j]):\n            separator_color = input_grid[0, j]\n            break\n\n    assert separator_color is not None, \"No separator color found\"\n\n    # Partition the grid into sub-grids\n    horizontal_separators = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == separator_color)]\n    vertical_separators = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == separator_color)]\n\n    # Add edges as separators\n    horizontal_separators = [0] + horizontal_separators + [input_grid.shape[0]]\n    vertical_separators = [0] + vertical_separators + [input_grid.shape[1]]\n\n    sub_grids = []\n    for h in range(len(horizontal_separators) - 1):\n        for v in range(len(vertical_separators) - 1):\n            x1, x2 = horizontal_separators[h], horizontal_separators[h + 1]\n            y1, y2 = vertical_separators[v], vertical_separators[v + 1]\n            if x2 - x1 > 1 and y2 - y1 > 1:\n                sub_grid = input_grid[x1 + 1:x2, y1 + 1:y2]\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n\n    # Choose a random separator color\n    separator_color = random.choice(list(Color.NOT_BLACK))\n    \n    # Randomly determine the number of horizontal and vertical separators\n    num_horizontal_separators = np.random.randint(1, 4)\n    num_vertical_separators = np.random.randint(1, 4)\n\n    # Get random indices for where to place separators\n    horizontal_indices = randomly_spaced_indices(max_len=width, n_indices=num_horizontal_separators, border_size=1, padding=2)\n    vertical_indices = randomly_spaced_indices(max_len=height, n_indices=num_vertical_separators, border_size=1, padding=2)\n\n    # Place horizontal separators\n    for x in horizontal_indices:\n        grid[x, :] = separator_color\n\n    # Place vertical separators\n    for y in vertical_indices:\n        grid[:, y] = separator_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# The input grid contains full-length separator rows or columns of a single color that divide the grid into distinct regions.\n# Identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves.\n# The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Identify separator color by checking fully colored rows or columns\n    separator_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            separator_color = input_grid[i, 0]\n            break\n    if separator_color is None:\n        for j in range(input_grid.shape[1]):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                separator_color = input_grid[0, j]\n                break\n\n    assert separator_color is not None, \"No separator color found.\"\n\n    # Find horizontal and vertical separators\n    horizontal_separators = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == separator_color)]\n    vertical_separators = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == separator_color)]\n\n    # Partition the grid into sub-grids\n    sub_grids = []\n\n    # Use the separators to slice the grid\n    horizonal_slices = [0] + horizontal_separators + [input_grid.shape[0]]\n    vertical_slices = [0] + vertical_separators + [input_grid.shape[1]]\n\n    for i in range(len(horizonal_slices) - 1):\n        for j in range(len(vertical_slices) - 1):\n            x1, x2 = horizonal_slices[i], horizonal_slices[i + 1]\n            y1, y2 = vertical_slices[j], vertical_slices[j + 1]\n            if x1 < x2 - 1 and y1 < y2 - 1:\n                sub_grid = input_grid[x1 + 1:x2, y1 + 1:y2]\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate the grid size\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n\n    # Randomly select separator color\n    separator_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly create horizontal separators\n    num_horizontal_separators = np.random.randint(1, 4)\n    horizontal_indices = randomly_spaced_indices(width, num_horizontal_separators, border_size=1, padding=2)\n\n    for idx in horizontal_indices:\n        grid[idx, :] = separator_color\n\n    # Randomly create vertical separators\n    num_vertical_separators = np.random.randint(1, 4)\n    vertical_indices = randomly_spaced_indices(height, num_vertical_separators, border_size=1, padding=2)\n\n    for idx in vertical_indices:\n        grid[:, idx] = separator_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# Input is a grid containing full-length separator rows or columns of a single color that divide the grid into distinct regions. \n# Identify these separators and use them to partition the grid into contiguous sub-grids. \n# Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves. \n# The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the full-length separator rows and columns\n    # 2. Partition the grid into sub-grids based on these separators\n    # 3. Return the list of sub-grids\n\n    height, width = input_grid.shape\n    separator_color = None\n    \n    # Detect the separator color, which is any color forming a full-length line\n    for color in Color.NOT_BLACK:\n        if any(np.all(input_grid[i, :] == color) for i in range(height)) or \\\n           any(np.all(input_grid[:, j] == color) for j in range(width)):\n            separator_color = color\n            break\n\n    assert separator_color is not None, \"No separator color found.\"\n\n    # Identify separator rows and columns\n    separator_rows = [i for i in range(height) if np.all(input_grid[i, :] == separator_color)]\n    separator_cols = [j for j in range(width) if np.all(input_grid[:, j] == separator_color)]\n\n    # Partition the grid into sub-grids\n    sub_grids = []\n\n    # Process row partitions\n    row_partitions = [0] + separator_rows + [height]\n    for i in range(len(row_partitions) - 1):\n        row_start = row_partitions[i] + 1\n        row_end = row_partitions[i + 1]\n        if row_start >= row_end:\n            continue\n\n        # Process column partitions within each row partition\n        col_partitions = [0] + separator_cols + [width]\n        for j in range(len(col_partitions) - 1):\n            col_start = col_partitions[j] + 1\n            col_end = col_partitions[j + 1]\n            if col_start >= col_end:\n                continue\n\n            # Extract the sub-grid\n            sub_grid = input_grid[row_start:row_end, col_start:col_end]\n            sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((height, width), np.random.choice(Color.NOT_BLACK))\n\n    # Randomly select separator color\n    separator_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly create full-length separators\n    num_separators_rows = np.random.randint(1, 3)\n    num_separators_cols = np.random.randint(1, 3)\n\n    separator_rows = randomly_spaced_indices(max_len=height, n_indices=num_separators_rows, border_size=1, padding=1)\n    separator_cols = randomly_spaced_indices(max_len=width, n_indices=num_separators_cols, border_size=1, padding=1)\n\n    for row in separator_rows:\n        grid[row, :] = separator_color\n\n    for col in separator_cols:\n        grid[:, col] = separator_color\n\n    # Randomly fill the regions with different colors\n    for i in range(len(separator_rows) + 1):\n        for j in range(len(separator_cols) + 1):\n            row_start = 0 if i == 0 else separator_rows[i - 1] + 1\n            row_end = separator_rows[i] if i < len(separator_rows) else height\n            col_start = 0 if j == 0 else separator_cols[j - 1] + 1\n            col_end = separator_cols[j] if j < len(separator_cols) else width\n\n            if row_start < row_end and col_start < col_end:\n                sub_grid_color = np.random.choice(Color.NOT_BLACK)\n                grid[row_start:row_end, col_start:col_end] = sub_grid_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# The input is a grid containing full-length separator rows or columns of a single color that divide the grid into distinct regions.\n# Identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid\n# between consecutive separators, excluding the separators themselves. The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Plan:\n    # 1. Identify the color of the separator lines by checking for rows or columns that are entirely one color.\n    # 2. Use these separators to partition the grid into sub-grids.\n    # 3. Return the list of sub-grids as the output.\n\n    # 1. Identify the separator color\n    separator_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            separator_color = input_grid[i, 0]\n            break\n    if separator_color is None:\n        for j in range(input_grid.shape[1]):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                separator_color = input_grid[0, j]\n                break\n\n    assert separator_color is not None, \"No separator color found\"\n\n    # 2. Find separator positions and partition the grid\n    horizontal_separators = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == separator_color)]\n    vertical_separators = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == separator_color)]\n\n    # Add boundaries for partitioning\n    horizontal_separators = [0] + horizontal_separators + [input_grid.shape[0]]\n    vertical_separators = [0] + vertical_separators + [input_grid.shape[1]]\n\n    sub_grids = []\n\n    # 3. Create sub-grids between separators\n    for h in range(len(horizontal_separators) - 1):\n        for v in range(len(vertical_separators) - 1):\n            top = horizontal_separators[h] + 1\n            bottom = horizontal_separators[h + 1]\n            left = vertical_separators[v] + 1\n            right = vertical_separators[v + 1]\n\n            if top < bottom and left < right:\n                sub_grid = input_grid[top:bottom, left:right]\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate the grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n\n    # Randomly choose a color for the separators\n    separator_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly generate separator positions\n    num_horizontal_separators = np.random.randint(1, 4)\n    num_vertical_separators = np.random.randint(1, 4)\n    horizontal_separators = randomly_spaced_indices(max_len=width, n_indices=num_horizontal_separators, border_size=1, padding=1)\n    vertical_separators = randomly_spaced_indices(max_len=height, n_indices=num_vertical_separators, border_size=1, padding=1)\n\n    # Draw separators on the grid\n    for hs in horizontal_separators:\n        grid[hs, :] = separator_color\n\n    for vs in vertical_separators:\n        grid[:, vs] = separator_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, separator detection, slicing\n\n# description:\n# The input grid contains full-length separator rows or columns of a single color that divide the grid into distinct regions.\n# Identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid\n# between consecutive separators, excluding the separators themselves. The output is a list of these sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Find the color used for separation\n    separator_color = None\n    # Assume the first complete row or column of identical color is the separator\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            separator_color = input_grid[i, 0]\n            break\n    if separator_color is None:\n        for j in range(input_grid.shape[1]):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                separator_color = input_grid[0, j]\n                break\n    \n    assert separator_color is not None, \"No separator color found\"\n\n    # Identify separator indices\n    separator_rows = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == separator_color)]\n    separator_cols = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == separator_color)]\n\n    # Initialize sub-grids list\n    sub_grids = []\n\n    # Create sub-grids by slicing between separators\n    last_row_index = 0\n    for row_index in separator_rows + [input_grid.shape[0]]:\n        last_col_index = 0\n        for col_index in separator_cols + [input_grid.shape[1]]:\n            sub_grid = input_grid[last_row_index:row_index, last_col_index:col_index]\n            if sub_grid.size > 0:\n                sub_grids.append(sub_grid)\n            last_col_index = col_index + 1\n        last_row_index = row_index + 1\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate the grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the number of separators\n    num_h_separators = np.random.randint(1, 3)\n    num_v_separators = np.random.randint(1, 3)\n\n    # Randomly determine separator positions\n    h_separators = randomly_spaced_indices(width, num_h_separators, border_size=1, padding=1)\n    v_separators = randomly_spaced_indices(height, num_v_separators, border_size=1, padding=1)\n\n    # Choose a separator color\n    separator_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw the horizontal separators\n    for x in h_separators:\n        grid[x, :] = separator_color\n\n    # Draw the vertical separators\n    for y in v_separators:\n        grid[:, y] = separator_color\n\n    # Fill the sub-grids with random colors\n    for i in range(len(h_separators) + 1):\n        for j in range(len(v_separators) + 1):\n            x_start = 0 if i == 0 else h_separators[i - 1] + 1\n            x_end = h_separators[i] if i < len(h_separators) else width\n            y_start = 0 if j == 0 else v_separators[j - 1] + 1\n            y_end = v_separators[j] if j < len(v_separators) else height\n\n            color = np.random.choice(Color.NOT_BLACK - {separator_color})\n            grid[x_start:x_end, y_start:y_end] = color\n\n    return grid"], "seeds": ["780d0b14.py", "90c28cc7.py", "00d62c1b.py", "06df4c85.py", "Concepts: \ngrid partitioning, separator detection, slicing\n\nDescription: \nInput is a grid containing full-length separator rows or columns of a single color that divide the grid into distinct regions. Identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid between consecutive separators, excluding the separators themselves. The output is a list of these sub-grids, preserving their original order and content."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.\n# Each sub-grid is bounded by the divider lines and contains no dividers within it. Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Plan:\n    # 1. Identify the color of the divider lines\n    # 2. Determine positions of horizontal and vertical divider lines\n    # 3. Use these dividers to slice the grid into sub-grids\n    # 4. Return the list of sub-grids\n\n    # 1. Identify the divider color by finding any line that extends fully horizontally or vertically\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n    \n    for j in range(input_grid.shape[1]):\n        if np.all(input_grid[:, j] == input_grid[0, j]):\n            divider_color = input_grid[0, j]\n            break\n\n    assert divider_color is not None, \"No divider color found\"\n    \n    # 2. Determine positions of horizontal and vertical divider lines\n    vertical_lines = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n\n    # 3. Use these dividers to slice the grid into sub-grids\n    sub_grids = []\n    previous_vertical = 0\n    for v in vertical_lines + [input_grid.shape[0]]:  # include end of grid\n        previous_horizontal = 0\n        for h in horizontal_lines + [input_grid.shape[1]]:  # include end of grid\n            sub_grid = input_grid[previous_vertical:v, previous_horizontal:h]\n            if sub_grid.size > 0 and np.any(sub_grid != divider_color):\n                sub_grids.append(sub_grid)\n            previous_horizontal = h + 1\n        previous_vertical = v + 1\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Set grid dimensions\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(Color.NOT_BLACK, (width, height), replace=True)\n\n    # Randomly select a color to be the divider\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place horizontal and vertical dividers\n    num_vertical_dividers = np.random.randint(1, 4)\n    num_horizontal_dividers = np.random.randint(1, 4)\n\n    vertical_indices = randomly_spaced_indices(max_len=width, n_indices=num_vertical_dividers, border_size=1, padding=2)\n    horizontal_indices = randomly_spaced_indices(max_len=height, n_indices=num_horizontal_dividers, border_size=1, padding=2)\n\n    for x in vertical_indices:\n        grid[x, :] = divider_color\n\n    for y in horizontal_indices:\n        grid[:, y] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.\n# Each sub-grid is bounded by the divider lines and contains no dividers within it.\n# Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the color of the divider lines\n    # 2. Find the positions of these divider lines in both horizontal and vertical directions\n    # 3. Use these lines to partition the grid into sub-grids\n    # 4. Extract and return the non-empty sub-grids\n\n    # Step 1: Identify the divider color\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i][j]\n            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):\n                divider_color = color\n                break\n        if divider_color:\n            break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Step 2: Find divider line positions\n    horizontal_dividers = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n    vertical_dividers = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n\n    # Ensure grid boundaries are considered as dividers\n    horizontal_dividers = [0] + horizontal_dividers + [input_grid.shape[1]]\n    vertical_dividers = [0] + vertical_dividers + [input_grid.shape[0]]\n\n    # Step 3: Partition the grid into sub-grids\n    sub_grids = []\n    for x1, x2 in zip(vertical_dividers[:-1], vertical_dividers[1:]):\n        for y1, y2 in zip(horizontal_dividers[:-1], horizontal_dividers[1:]):\n            sub_grid = input_grid[x1:x2, y1:y2]\n            if not np.all(sub_grid == divider_color):  # Ignore empty sub-grids\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate grid dimensions\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select a divider color\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place horizontal and vertical dividers\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    horizontal_positions = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=2)\n    vertical_positions = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=2)\n\n    for y in horizontal_positions:\n        draw_line(grid, 0, y, direction=(1, 0), color=divider_color)\n\n    for x in vertical_positions:\n        draw_line(grid, x, 0, direction=(0, 1), color=divider_color)\n\n    # Fill regions with random colors\n    for x1, x2 in zip([0] + vertical_positions, vertical_positions + [width]):\n        for y1, y2 in zip([0] + horizontal_positions, horizontal_positions + [height]):\n            region_color = np.random.choice(Color.NOT_BLACK)\n            if region_color != divider_color:\n                grid[x1:x2, y1:y2] = region_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.\n# Each sub-grid is bounded by the divider lines and contains no dividers within it.\n# Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the color of the divider lines by identifying a line that spans the entire width or height.\n    # 2. Determine the positions of the horizontal and vertical divider lines.\n    # 3. Partition the grid into sub-grids using these divider positions.\n    # 4. Return the list of non-empty sub-grids.\n\n    # 1. Identify divider color\n    divider_color = None\n    width, height = input_grid.shape\n\n    for i in range(width):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n\n    for j in range(height):\n        if np.all(input_grid[:, j] == input_grid[0, j]):\n            divider_color = input_grid[0, j]\n            break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # 2. Determine positions of divider lines\n    horizontal_dividers = [j for j in range(height) if np.all(input_grid[:, j] == divider_color)]\n    vertical_dividers = [i for i in range(width) if np.all(input_grid[i, :] == divider_color)]\n\n    # Add boundaries of the grid as potential dividers\n    horizontal_dividers = [-1] + horizontal_dividers + [height]\n    vertical_dividers = [-1] + vertical_dividers + [width]\n\n    # 3. Partition the grid into sub-grids\n    sub_grids = []\n    for h in range(len(horizontal_dividers) - 1):\n        for v in range(len(vertical_dividers) - 1):\n            x1, x2 = vertical_dividers[v] + 1, vertical_dividers[v + 1]\n            y1, y2 = horizontal_dividers[h] + 1, horizontal_dividers[h + 1]\n\n            sub_grid = input_grid[x1:x2, y1:y2]\n            if sub_grid.size > 0 and not np.all(sub_grid == divider_color):\n                sub_grids.append(sub_grid)\n\n    # 4. Return the list of sub-grids\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(Color.NOT_BLACK, (width, height))\n\n    # Select a random color for dividers\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly decide the number of horizontal and vertical dividers\n    num_horizontal_dividers = np.random.randint(2, 5)\n    num_vertical_dividers = np.random.randint(2, 5)\n\n    # Generate random positions for dividers\n    horizontal_positions = randomly_spaced_indices(max_len=height, n_indices=num_horizontal_dividers, border_size=1, padding=2)\n    vertical_positions = randomly_spaced_indices(max_len=width, n_indices=num_vertical_dividers, border_size=1, padding=2)\n\n    # Draw dividers on the grid\n    for y in horizontal_positions:\n        grid[:, y] = divider_color\n    for x in vertical_positions:\n        grid[x, :] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import List\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.\n# Each sub-grid is bounded by the divider lines and contains no dividers within it. Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Find the color of the divider lines\n    divider_color = None\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x, y]\n            # Check for uninterrupted horizontal or vertical lines\n            if np.all(input_grid[x, :] == color) or np.all(input_grid[:, y] == color):\n                divider_color = color\n                break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Identify the horizontal and vertical lines\n    horizontal_dividers = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n    vertical_dividers = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n\n    # Add borders as dividers to handle edge cases\n    horizontal_dividers = [0] + horizontal_dividers + [input_grid.shape[1]]\n    vertical_dividers = [0] + vertical_dividers + [input_grid.shape[0]]\n\n    sub_grids = []\n\n    # Extract sub-grids based on the divider positions\n    for i in range(len(vertical_dividers) - 1):\n        for j in range(len(horizontal_dividers) - 1):\n            x1, x2 = vertical_dividers[i], vertical_dividers[i + 1]\n            y1, y2 = horizontal_dividers[j], horizontal_dividers[j + 1]\n            sub_grid = input_grid[x1+1:x2, y1+1:y2]\n            if sub_grid.size > 0:\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n\n    # Randomly choose a divider color\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly determine the number and position of dividers\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    horizontal_divider_positions = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=1)\n    vertical_divider_positions = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=1)\n\n    # Draw horizontal dividers\n    for y in horizontal_divider_positions:\n        grid[:, y] = divider_color\n\n    # Draw vertical dividers\n    for x in vertical_divider_positions:\n        grid[x, :] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.\n# Each sub-grid is bounded by the divider lines and contains no dividers within it.\n# Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Determine the divider color by finding a line that runs uninterrupted across the grid\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n    if divider_color is None:\n        for j in range(input_grid.shape[1]):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                divider_color = input_grid[0, j]\n                break\n    assert divider_color is not None, \"No divider color found\"\n\n    # Identify all rows and columns that are completely filled with the divider color\n    horizontal_dividers = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == divider_color)]\n    vertical_dividers = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == divider_color)]\n\n    # Initialize the list of sub-grids\n    sub_grids = []\n\n    # Create the sub-grids based on the identified dividers\n    for start_row, end_row in zip([0] + horizontal_dividers, horizontal_dividers + [input_grid.shape[0]]):\n        for start_col, end_col in zip([0] + vertical_dividers, vertical_dividers + [input_grid.shape[1]]):\n            # Extract the sub-grid\n            sub_grid = input_grid[start_row:end_row, start_col:end_col]\n            # Ensure the sub-grid does not contain the divider color\n            if not np.any(sub_grid == divider_color):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate grid dimensions\n    width, height = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(width, height))\n\n    # Randomly choose a divider color\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Add horizontal dividers\n    num_horizontal_dividers = np.random.randint(1, 5)\n    horizontal_indices = randomly_spaced_indices(width, num_horizontal_dividers, border_size=1, padding=2)\n    for x in horizontal_indices:\n        grid[x, :] = divider_color\n\n    # Add vertical dividers\n    num_vertical_dividers = np.random.randint(1, 5)\n    vertical_indices = randomly_spaced_indices(height, num_vertical_dividers, border_size=1, padding=2)\n    for y in vertical_indices:\n        grid[:, y] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import List, Tuple\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.\n# Each sub-grid is bounded by the divider lines and contains no dividers within it.\n# Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Find the color of the divider lines, which is the most frequent color in the grid\n    unique, counts = np.unique(input_grid, return_counts=True)\n    divider_color = unique[np.argmax(counts)]\n\n    # Get the shape of the input grid\n    width, height = input_grid.shape\n\n    # Find all horizontal and vertical lines\n    vertical_lines = [x for x in range(width) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(height) if np.all(input_grid[:, y] == divider_color)]\n\n    # Add boundaries to the start and end\n    vertical_lines = [0] + vertical_lines + [width]\n    horizontal_lines = [0] + horizontal_lines + [height]\n\n    # Extract sub-grids\n    sub_grids = []\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x1, x2 = vertical_lines[i], vertical_lines[i + 1]\n            y1, y2 = horizontal_lines[j], horizontal_lines[j + 1]\n\n            # Extract sub-grid and check if it's non-empty\n            sub_grid = input_grid[x1:x2, y1:y2]\n            if np.any(sub_grid != divider_color):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(list(Color.ALL_COLORS), (width, height))\n\n    # Randomly select a color for the dividers\n    divider_color = np.random.choice(list(Color.ALL_COLORS))\n    while divider_color == Color.BLACK:\n        divider_color = np.random.choice(list(Color.ALL_COLORS))\n\n    # Randomly select the number of dividers\n    n_vertical_dividers = np.random.randint(2, 5)\n    n_horizontal_dividers = np.random.randint(2, 5)\n\n    # Randomly place vertical and horizontal dividers\n    vertical_positions = randomly_spaced_indices(max_len=width, n_indices=n_vertical_dividers, border_size=1, padding=2)\n    horizontal_positions = randomly_spaced_indices(max_len=height, n_indices=n_horizontal_dividers, border_size=1, padding=2)\n\n    for x in vertical_positions:\n        grid[x, :] = divider_color\n\n    for y in horizontal_positions:\n        grid[:, y] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.\n# Each sub-grid is bounded by the divider lines and contains no dividers within it.\n# Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Find the color of the divider lines\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i][j]\n            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):\n                divider_color = color\n                break\n    \n    assert divider_color is not None, \"No divider color found\"\n\n    # Find vertical and horizontal lines\n    vertical_lines = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n\n    # Add boundaries\n    vertical_lines = [-1] + vertical_lines + [input_grid.shape[0]]\n    horizontal_lines = [-1] + horizontal_lines + [input_grid.shape[1]]\n\n    sub_grids = []\n\n    # Extract sub-grids\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x1, x2 = vertical_lines[i] + 1, vertical_lines[i+1]\n            y1, y2 = horizontal_lines[j] + 1, horizontal_lines[j+1]\n            sub_grid = input_grid[x1:x2, y1:y2]\n            if sub_grid.size > 0:\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the divider color\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly choose the number of vertical and horizontal dividers\n    num_vertical_dividers = np.random.randint(1, 5)\n    num_horizontal_dividers = np.random.randint(1, 5)\n\n    # Place dividers\n    vertical_positions = randomly_spaced_indices(max_len=width, n_indices=num_vertical_dividers, border_size=1, padding=2)\n    horizontal_positions = randomly_spaced_indices(max_len=height, n_indices=num_horizontal_dividers, border_size=1, padding=2)\n\n    for x in vertical_positions:\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=divider_color)\n\n    for y in horizontal_positions:\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=divider_color)\n\n    # Fill each region with random colors\n    for x1, x2 in zip([-1] + vertical_positions, vertical_positions + [width]):\n        for y1, y2 in zip([-1] + horizontal_positions, horizontal_positions + [height]):\n            if x2 - x1 > 1 and y2 - y1 > 1:\n                region_color = np.random.choice(Color.NOT_BLACK)\n                grid[x1 + 1:x2, y1 + 1:y2] = region_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, horizontal/vertical slicing\n\n# description:\n# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.\n# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids. Each sub-grid is bounded \n# by the divider lines and contains no dividers within it. Output is a list of these non-empty sub-grids, preserving their original content.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the color of the divider lines.\n    # 2. Determine the positions of the horizontal and vertical divider lines.\n    # 3. Segment the grid into sub-grids based on these dividers.\n    # 4. Return a list of non-empty sub-grids.\n\n    # 1. Identify the color of the divider lines\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i][j]\n            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):\n                divider_color = color\n                break\n    assert divider_color is not None, \"No divider color found\"\n\n    # 2. Determine the positions of the horizontal and vertical divider lines\n    width, height = input_grid.shape\n    vertical_lines = [x for x in range(width) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(height) if np.all(input_grid[:, y] == divider_color)]\n\n    # Add bounds to the lines list\n    vertical_lines = [0] + vertical_lines + [width]\n    horizontal_lines = [0] + horizontal_lines + [height]\n\n    # 3. Segment the grid into sub-grids based on these dividers\n    sub_grids = []\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x1, x2 = vertical_lines[i], vertical_lines[i + 1]\n            y1, y2 = horizontal_lines[j], horizontal_lines[j + 1]\n            sub_grid = input_grid[x1:x2, y1:y2]\n\n            # 4. Add non-empty sub-grids to the list\n            if np.any(sub_grid != divider_color):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the grid separation\n    num_dividers_horizontal = np.random.randint(1, 4)\n    num_dividers_vertical = np.random.randint(1, 4)\n    horizontal_divider_positions = randomly_spaced_indices(max_len=width, n_indices=num_dividers_horizontal, border_size=1, padding=2)\n    vertical_divider_positions = randomly_spaced_indices(max_len=height, n_indices=num_dividers_vertical, border_size=1, padding=2)\n\n    # Choose a random color for the dividers\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw horizontal and vertical dividers\n    for x in horizontal_divider_positions:\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=divider_color)\n\n    for y in vertical_divider_positions:\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=divider_color)\n\n    # Randomly fill regions with colors\n    for i in range(len(horizontal_divider_positions) + 1):\n        for j in range(len(vertical_divider_positions) + 1):\n            x1 = 0 if i == 0 else horizontal_divider_positions[i - 1] + 1\n            x2 = horizontal_divider_positions[i] if i < len(horizontal_divider_positions) else width\n            y1 = 0 if j == 0 else vertical_divider_positions[j - 1] + 1\n            y2 = vertical_divider_positions[j] if j < len(vertical_divider_positions) else height\n\n            if x1 < x2 and y1 < y2:\n                color = np.random.choice(Color.NOT_BLACK)\n                sprite = np.full((x2 - x1, y2 - y1), color)\n                blit_sprite(grid, sprite, x=x1, y=y1, background=Color.BLACK)\n\n    return grid"], "seeds": ["780d0b14.py", "90c28cc7.py", "06df4c85.py", "941d9a10.py", "Concepts: \ngrid partitioning, divider lines, horizontal/vertical slicing\n\nDescription: \nInput is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions. Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids. Each sub-grid is bounded by the divider lines and contains no dividers within it. Output is a list of these non-empty sub-grids, preserving their original content."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object tracking, linear movement, pattern extrapolation\n\n# description:\n# The input consists of a sequence of grids representing consecutive time steps. Each grid contains one or more colored objects moving linearly.\n# The task is to analyze the sequence to identify the movement pattern of each object and predict the next position of each object.\n\ndef main(input_grids):\n    # We assume input_grids is a list of 2D numpy arrays representing the grids at each time step\n\n    # Extract the number of time steps and the grid dimensions\n    num_steps = len(input_grids)\n    grid_height, grid_width = input_grids[0].shape\n\n    # Create an output grid for the next time step prediction\n    output_grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    # Track each object's movement across the time steps\n    objects_trajectory = {}\n\n    for t, grid in enumerate(input_grids):\n        objects = find_connected_components(grid, monochromatic=True, background=Color.BLACK)\n\n        for obj in objects:\n            color = object_colors(obj)[0]\n            x, y = object_position(obj, background=Color.BLACK)\n\n            if color not in objects_trajectory:\n                objects_trajectory[color] = []\n            \n            objects_trajectory[color].append((x, y))\n\n    # Extrapolate each object's movement to predict the next position\n    for color, trajectory in objects_trajectory.items():\n        if len(trajectory) >= 2:\n            # Calculate movement vector based on last two positions\n            (x1, y1), (x2, y2) = trajectory[-2], trajectory[-1]\n            dx, dy = x2 - x1, y2 - y1\n\n            # Predict the next position\n            next_x, next_y = x2 + dx, y2 + dy\n\n            # Place the object in the predicted position if within grid bounds\n            if 0 <= next_x < grid_width and 0 <= next_y < grid_height:\n                output_grid[next_x, next_y] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a sequence of grids with moving objects\n\n    # Random grid size\n    grid_height, grid_width = np.random.randint(5, 10, size=2)\n\n    # Number of time steps in the sequence\n    num_steps = np.random.randint(3, 5)\n\n    # Create a list to store the sequence of grids\n    input_grids = []\n\n    # Number of objects\n    num_objects = np.random.randint(1, 4)\n\n    # Initialize positions and velocities for each object\n    positions = [np.array([np.random.randint(0, grid_height), np.random.randint(0, grid_width)]) for _ in range(num_objects)]\n    velocities = [np.array([np.random.choice([-1, 0, 1]), np.random.choice([-1, 0, 1])]) for _ in range(num_objects)]\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_objects, replace=False)\n\n    for _ in range(num_steps):\n        # Create a new grid for this time step\n        grid = np.zeros((grid_height, grid_width), dtype=int)\n\n        # Update positions and draw objects\n        for i in range(num_objects):\n            x, y = positions[i]\n            color = colors[i]\n\n            # Place the object\n            grid[x, y] = color\n\n            # Update position for next time step\n            next_x, next_y = positions[i] + velocities[i]\n\n            # Ensure the object stays within bounds, bounce if necessary\n            if not (0 <= next_x < grid_height):\n                velocities[i][0] *= -1\n            if not (0 <= next_y < grid_width):\n                velocities[i][1] *= -1\n            positions[i] = positions[i] + velocities[i]\n\n        input_grids.append(grid)\n\n    return input_grids", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, size transformation, sequence prediction\n\n# description:\n# The input consists of a sequence of grids where a square changes its size in a consistent manner (either increasing or decreasing).\n# The task is to detect the size change pattern and predict the next grid in the sequence by applying the detected size change pattern.\n\ndef main(input_grids):\n    # The input is a list of grids representing consecutive time steps\n    last_grid = input_grids[-1]\n    \n    # Identify the square object in the last grid\n    objects = find_connected_components(last_grid, monochromatic=True, background=Color.BLACK)\n    assert len(objects) == 1, \"exactly one square expected\"\n    square = objects[0]\n\n    # Get the bounding box of the square to determine its size\n    x, y, w, h = bounding_box(square)\n    \n    # Calculate the size change pattern from the sequence\n    size_changes = []\n    for i in range(1, len(input_grids)):\n        prev_grid = input_grids[i - 1]\n        curr_grid = input_grids[i]\n        prev_square = find_connected_components(prev_grid, monochromatic=True, background=Color.BLACK)[0]\n        curr_square = find_connected_components(curr_grid, monochromatic=True, background=Color.BLACK)[0]\n        \n        _, _, prev_w, _ = bounding_box(prev_square)\n        _, _, curr_w, _ = bounding_box(curr_square)\n        \n        size_changes.append(curr_w - prev_w)\n    \n    # Determine the most consistent size change\n    size_change = max(set(size_changes), key=size_changes.count)\n\n    # Predict the size of the square in the next grid\n    new_size = max(1, w + size_change)  # Ensure the new size is at least 1\n\n    # Create the next grid\n    grid_size = last_grid.shape\n    next_grid = np.full(grid_size, Color.BLACK)\n\n    # Draw the new square in the center of the grid\n    start_x = (grid_size[0] - new_size) // 2\n    start_y = (grid_size[1] - new_size) // 2\n    for i in range(new_size):\n        for j in range(new_size):\n            next_grid[start_x + i, start_y + j] = Color.TEAL  # Assume the square is teal\n\n    return next_grid\n\ndef generate_input():\n    # Randomly choose the size of the grid\n    grid_size = np.random.randint(10, 15)\n    \n    # Randomly choose the initial size of the square\n    initial_size = np.random.randint(2, 5)\n    \n    # Randomly choose the size change (positive for growing, negative for shrinking)\n    size_change = np.random.choice([-1, 1])\n    \n    # Determine the number of steps in the sequence\n    num_steps = np.random.randint(3, 6)\n    \n    # Generate a sequence of grids\n    grids = []\n    current_size = initial_size\n    for _ in range(num_steps):\n        grid = np.full((grid_size, grid_size), Color.BLACK)\n        \n        # Calculate the position to center the square\n        start_x = (grid_size - current_size) // 2\n        start_y = (grid_size - current_size) // 2\n        \n        # Draw the square\n        for i in range(current_size):\n            for j in range(current_size):\n                grid[start_x + i, start_y + j] = Color.TEAL  # Assume the square is teal\n\n        grids.append(grid)\n        \n        # Update the size for the next step\n        current_size = max(1, current_size + size_change)  # Ensure size is at least 1\n    \n    return grids", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extrapolation, sequence prediction, feature analysis, progression detection\n\n# description:\n# The input consists of a sequence of grids representing consecutive time steps, where objects exhibit a consistent transformation pattern in terms of position (moving rightward).\n# Analyze the sequence to identify the evolving pattern of linear movement. Extrapolate the identified pattern to predict and generate the next grid in the sequence.\n# The output is a single grid that continues the detected pattern logically from the last input grid.\n\ndef main(input_grids):\n    # Assume input_grids is a list of 2D numpy arrays representing consecutive time steps.\n    num_steps = len(input_grids)\n    last_grid = input_grids[-1]\n    \n    # Get the objects in the last grid\n    objects = find_connected_components(last_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Determine the movement pattern (we assume objects move right by 1 pixel per time step)\n    movement_vector = (0, 1)  # moving right by 1 pixel\n    \n    # Create the next grid by copying the last grid\n    next_grid = np.full_like(last_grid, Color.BLACK)\n    \n    # Move each object according to the detected pattern\n    for obj in objects:\n        obj_color = object_colors(obj)[0]\n        x, y = object_position(obj, background=Color.BLACK)\n        sprite = crop(obj)\n        \n        new_x = x + movement_vector[0]\n        new_y = y + movement_vector[1]\n        \n        # Ensure the new position is within grid bounds\n        if 0 <= new_x < next_grid.shape[0] and 0 <= new_y < next_grid.shape[1]:\n            blit_sprite(next_grid, sprite, new_x, new_y)\n    \n    return next_grid\n\ndef generate_input():\n    num_steps = 3  # Number of steps in the sequence\n    grid_size = (10, 10)  # Size of each grid\n    grids = []\n    \n    # Start with a random grid\n    grid = np.zeros(grid_size, dtype=int)\n    \n    # Randomly place a few monochromatic objects\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        obj_size = np.random.randint(1, 3)  # Small objects\n        sprite = np.full((obj_size, obj_size), obj_color)\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # No space available, skip this object\n            continue\n    \n    # Generate the sequence of grids\n    for _ in range(num_steps):\n        grids.append(grid.copy())\n        next_grid = np.full_like(grid, Color.BLACK)\n        \n        # Move each object right by 1 pixel\n        objects = find_connected_components(grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n        for obj in objects:\n            obj_color = object_colors(obj)[0]\n            x, y = object_position(obj, background=Color.BLACK)\n            sprite = crop(obj)\n            \n            new_x = x\n            new_y = y + 1\n            \n            # Ensure the new position is within grid bounds\n            if new_y < grid.shape[1]:\n                blit_sprite(next_grid, sprite, new_x, new_y)\n        \n        grid = next_grid\n    \n    return grids", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extrapolation, sequence prediction, feature analysis, progression detection\n\n# description:\n# Input consists of a sequence of grids representing consecutive time steps, where objects exhibit a consistent transformation pattern in terms of position, size, or color. \n# Analyze the sequence to identify the evolving pattern, such as linear movement, size change, or color shift. \n# Extrapolate the identified pattern to predict and generate the next grid in the sequence. \n# The output is a single grid that continues the detected pattern logically from the last input grid.\n\ndef main(input_sequence):\n    # Determine the length of the sequence\n    num_steps = len(input_sequence)\n    \n    # Analyze the pattern by comparing the last two grid states\n    last_grid = input_sequence[-1]\n    second_last_grid = input_sequence[-2]\n\n    # Find connected components in the last two grids\n    last_objects = find_connected_components(last_grid, background=Color.BLACK, connectivity=8)\n    second_last_objects = find_connected_components(second_last_grid, background=Color.BLACK, connectivity=8)\n\n    # Initialize the output grid with the same size as the input grids\n    output_grid = np.full_like(last_grid, Color.BLACK)\n\n    # Process each object to detect movement pattern\n    for last_obj, second_last_obj in zip(last_objects, second_last_objects):\n        # Get positions and bounding boxes\n        last_x, last_y = object_position(last_obj, background=Color.BLACK)\n        second_last_x, second_last_y = object_position(second_last_obj, background=Color.BLACK)\n        \n        # Calculate movement vector\n        move_x = last_x - second_last_x\n        move_y = last_y - second_last_y\n\n        # Detect size change, if any\n        last_bb = bounding_box(last_obj)\n        second_last_bb = bounding_box(second_last_obj)\n        size_change_x = last_bb[2] - second_last_bb[2]\n        size_change_y = last_bb[3] - second_last_bb[3]\n\n        # Extrapolate next position and size\n        next_x = last_x + move_x\n        next_y = last_y + move_y\n        next_w = last_bb[2] + size_change_x\n        next_h = last_bb[3] + size_change_y\n\n        # Crop the object to get its sprite\n        sprite = crop(last_obj)\n\n        # Resize the sprite if there was a size change\n        sprite = np.resize(sprite, (next_w, next_h))\n\n        # Blit the sprite at the extrapolated position\n        blit_sprite(output_grid, sprite, x=next_x, y=next_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Grid size\n    grid_size = np.random.randint(10, 15)\n    num_steps = np.random.randint(3, 6)\n    \n    # Initialize sequence of grids\n    input_sequence = [np.full((grid_size, grid_size), Color.BLACK) for _ in range(num_steps)]\n\n    # Randomly create an object at the first time step\n    color = np.random.choice(list(Color.NOT_BLACK))\n    initial_size = np.random.randint(2, 4)\n    sprite = np.full((initial_size, initial_size), color)\n\n    # Choose a random initial position\n    x, y = np.random.randint(0, grid_size - initial_size, 2)\n    blit_sprite(input_sequence[0], sprite, x=x, y=y)\n    \n    # Define movement and size change\n    move_x = np.random.choice([-1, 0, 1])\n    move_y = np.random.choice([-1, 0, 1])\n    size_change_x = np.random.choice([-1, 0, 1])\n    size_change_y = np.random.choice([-1, 0, 1])\n\n    # Generate subsequent steps with consistent pattern\n    for t in range(1, num_steps):\n        prev_grid = input_sequence[t - 1]\n        new_grid = input_sequence[t]\n        \n        # Extract previous object\n        objects = find_connected_components(prev_grid, background=Color.BLACK, connectivity=8)\n        if not objects:\n            continue\n        \n        obj = objects[0]\n        x, y = object_position(obj, background=Color.BLACK)\n        bb = bounding_box(obj)\n        \n        # Update position and size\n        x += move_x\n        y += move_y\n        new_w = bb[2] + size_change_x\n        new_h = bb[3] + size_change_y\n\n        # Ensure new position and size fit within grid\n        x = min(max(0, x), grid_size - new_w)\n        y = min(max(0, y), grid_size - new_h)\n        new_w = min(max(1, new_w), grid_size - x)\n        new_h = min(max(1, new_h), grid_size - y)\n\n        # Crop and resize the object\n        sprite = crop(obj)\n        sprite = np.resize(sprite, (new_w, new_h))\n        \n        # Blit the sprite at the new position\n        blit_sprite(new_grid, sprite, x=x, y=y, background=Color.BLACK)\n\n    return input_sequence", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# dynamic pattern evolution, prediction, sequence analysis\n\n# description:\n# In the input you will see a sequence of grids representing consecutive time steps, \n# where objects exhibit a consistent transformation pattern in terms of position, size, or color.\n# The task is to analyze the sequence to identify the evolving pattern, such as linear movement, size change, or color shift.\n# Extrapolate the identified pattern to predict and generate the next grid in the sequence. The output is a single grid that continues the detected pattern logically from the last input grid.\n\ndef main(input_sequence):\n    # Analyze the input sequence to detect the pattern\n    num_steps = len(input_sequence)\n    last_grid = input_sequence[-1]\n    \n    # Find the connected components (assumed to be moving objects) in the last grid\n    objects = find_connected_components(last_grid, monochromatic=True, connectivity=8, background=Color.BLACK)\n    \n    # Prepare the output grid with the same size as the input grids\n    n, m = last_grid.shape\n    output_grid = np.zeros((n, m), dtype=int)\n    \n    # Process each object to predict its next position\n    for obj in objects:\n        # Get the object's position and color\n        x, y = object_position(obj, background=Color.BLACK)\n        color = object_colors(obj)[0]\n        \n        # Assume a linear movement pattern: calculate the velocity of the object between first and last grid\n        first_obj = find_connected_components(input_sequence[0], monochromatic=True, connectivity=8, background=Color.BLACK)\n        initial_position = None\n        for init_obj in first_obj:\n            if object_colors(init_obj)[0] == color:\n                initial_position = object_position(init_obj, background=Color.BLACK)\n                break\n        \n        dx = (x - initial_position[0]) // (num_steps - 1)\n        dy = (y - initial_position[1]) // (num_steps - 1)\n        \n        # Predict the next position of the object\n        new_x = x + dx\n        new_y = y + dy\n        \n        # Blit the object in the new position on the output grid\n        sprite = crop(obj)\n        if 0 <= new_x < n and 0 <= new_y < m:\n            blit_sprite(output_grid, sprite, x=new_x, y=new_y, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 10, size=2)\n    \n    # Generate a sequence of grids\n    num_steps = np.random.randint(3, 6)\n    sequence = []\n    \n    # Initialize a random starting position and direction for each object\n    num_objects = np.random.randint(1, 4)\n    directions = [(np.random.choice([-1, 0, 1]), np.random.choice([-1, 0, 1])) for _ in range(num_objects)]\n    positions = [random_free_location_for_sprite(np.zeros((n, m), dtype=int), np.array([[Color.BLACK]]), border_size=1) for _ in range(num_objects)]\n    colors = np.random.choice(Color.NOT_BLACK, size=num_objects, replace=False)\n    \n    for step in range(num_steps):\n        grid = np.zeros((n, m), dtype=int)\n        \n        for i, (direction, position, color) in enumerate(zip(directions, positions, colors)):\n            # Calculate the new position\n            new_x = position[0] + direction[0] * step\n            new_y = position[1] + direction[1] * step\n            \n            # Ensure the object stays within the bounds\n            new_x = max(0, min(n - 1, new_x))\n            new_y = max(0, min(m - 1, new_y))\n            \n            # Draw the object at the new position\n            grid[new_x, new_y] = color\n        \n        sequence.append(grid)\n    \n    return sequence", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color gradient transformation, sequence prediction, pattern extrapolation\n\n# description:\n# In the input, you will see a sequence of grids, each representing a time step.\n# Objects in these grids exhibit a pattern of color gradient transformation.\n# Your task is to identify this color gradient transformation pattern and extrapolate it to predict the next grid in the sequence.\n\ndef main(input_grids):\n    last_grid = input_grids[-1]\n    next_grid = last_grid.copy()\n\n    # Analyze color changes over time steps\n    time_steps = len(input_grids)\n    color_changes = {}\n\n    for t in range(1, time_steps):\n        prev_grid = input_grids[t-1]\n        curr_grid = input_grids[t]\n        \n        for obj in find_connected_components(prev_grid, monochromatic=True):\n            x, y = object_position(obj)\n            color_before = prev_grid[x, y]\n            color_after = curr_grid[x, y]\n\n            if color_before != color_after:\n                if color_before not in color_changes:\n                    color_changes[color_before] = []\n                color_changes[color_before].append(color_after)\n\n    # Determine the most common transformation for each color\n    color_transformation = {}\n    for color, transformations in color_changes.items():\n        most_common_transformation = max(set(transformations), key=transformations.count)\n        color_transformation[color] = most_common_transformation\n\n    # Apply the detected transformations to predict the next grid\n    for x in range(next_grid.shape[0]):\n        for y in range(next_grid.shape[1]):\n            current_color = last_grid[x, y]\n            if current_color in color_transformation:\n                next_grid[x, y] = color_transformation[current_color]\n\n    return next_grid\n\n\ndef generate_input():\n    # Randomly determine grid dimensions\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n\n    # Create a sequence of grids\n    sequence_length = np.random.randint(3, 6)\n    grids = [np.full((n, m), Color.BLACK) for _ in range(sequence_length)]\n\n    # Randomly place initial colored pixels\n    num_objects = np.random.randint(3, 6)\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n    initial_colors = colors[:num_objects]\n\n    for color in initial_colors:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grids[0][x, y] = color\n\n    # Define a random color transformation pattern\n    color_transformation = {}\n    remaining_colors = list(Color.NOT_BLACK - set(initial_colors))\n    for color in initial_colors:\n        next_color = np.random.choice(remaining_colors)\n        color_transformation[color] = next_color\n\n    # Apply the transformation over time steps\n    for t in range(1, sequence_length):\n        prev_grid = grids[t-1]\n        curr_grid = grids[t]\n\n        for x in range(n):\n            for y in range(m):\n                current_color = prev_grid[x, y]\n                if current_color in color_transformation:\n                    curr_grid[x, y] = color_transformation[current_color]\n\n    return grids", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extrapolation, sequence prediction, feature analysis, progression detection\n\n# description:\n# Input consists of a sequence of grids representing consecutive time steps, where objects exhibit a consistent transformation pattern \n# in terms of position, size, or color. Analyze the sequence to identify the evolving pattern, such as linear movement, size change, or color shift. \n# Extrapolate the identified pattern to predict and generate the next grid in the sequence. \n# The output is a single grid that continues the detected pattern logically from the last input grid.\n\ndef main(input_grids):\n    # Assume input_grids is a list of grids representing consecutive time steps\n    last_grid = input_grids[-1]\n\n    # Find all objects in the last grid\n    objects = find_connected_components(last_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Create a copy of the last grid to transform\n    output_grid = last_grid.copy()\n    \n    # Analyze each object to determine its transformation pattern\n    for obj in objects:\n        # Get object position, color, and size\n        x, y = object_position(obj, background=Color.BLACK)\n        color = object_colors(obj)[0]\n        width, height = obj.shape\n\n        # Determine the pattern of movement, size, or color change\n        # For simplicity, let's assume objects move linearly in the x direction by a fixed amount\n        # This can be expanded to detect more complex transformations\n\n        # Calculate the new position\n        new_x = x + 1  # Assuming a simple linear movement to the right\n        new_y = y\n\n        # Make sure the new position is within bounds\n        if new_x + width <= output_grid.shape[0]:\n            # Clear the previous position\n            blit_sprite(output_grid, np.full_like(obj, Color.BLACK), x=x, y=y, background=Color.BLACK)\n            # Place the object in its new position\n            blit_sprite(output_grid, obj, x=new_x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a sequence of grids by applying a deterministic transformation\n    num_steps = 3\n    grid_size = (10, 10)\n\n    # Start with an empty grid\n    grids = [np.full(grid_size, Color.BLACK)]\n\n    # Choose a random color for the object\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create an initial object at a random position\n    initial_x = np.random.randint(0, grid_size[0] // 2)\n    initial_y = np.random.randint(0, grid_size[1] // 2)\n    object_size = (2, 2)\n    initial_object = np.full(object_size, color)\n    \n    # Place the initial object on the first grid\n    blit_sprite(grids[0], initial_object, x=initial_x, y=initial_y, background=Color.BLACK)\n\n    # Generate subsequent grids by applying simple linear movement\n    for step in range(1, num_steps):\n        new_grid = grids[step-1].copy()\n        new_x = initial_x + step * 1  # Move to the right\n        new_y = initial_y\n\n        if new_x + object_size[0] <= grid_size[0]:\n            blit_sprite(new_grid, initial_object, x=new_x, y=new_y, background=Color.BLACK)\n\n        grids.append(new_grid)\n\n    return grids", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extrapolation, sequence prediction, shape transformation, color change\n\n# description:\n# Input consists of a sequence of grids representing consecutive time steps, where objects (colored shapes) exhibit a consistent transformation pattern in terms of position, shape, or color. Analyze the sequence to identify the evolving pattern, such as linear movement, rotation, scaling, or color transition. Extrapolate the identified pattern to predict and generate the next grid in the sequence. The output is a single grid that continues the detected pattern logically from the last input grid.\n\ndef main(input_grids: List[np.ndarray]) -> np.ndarray:\n    # Analyze the sequence of input grids to determine the transformation pattern\n    num_grids = len(input_grids)\n    assert num_grids >= 2, \"There should be at least two grids to determine the pattern\"\n\n    # Assume all grids are of the same size\n    grid_shape = input_grids[0].shape\n    output_grid = np.full(grid_shape, Color.BLACK)\n\n    # Extract the objects from the last two grids\n    objects_prev = find_connected_components(input_grids[-2], monochromatic=True, background=Color.BLACK)\n    objects_last = find_connected_components(input_grids[-1], monochromatic=True, background=Color.BLACK)\n\n    # Determine the transformation pattern\n    for obj_prev, obj_last in zip(objects_prev, objects_last):\n        # Get positions and colors\n        x_prev, y_prev = object_position(obj_prev)\n        x_last, y_last = object_position(obj_last)\n        color = object_colors(obj_last)[0]\n        \n        # Calculate the movement vector (dx, dy)\n        dx, dy = x_last - x_prev, y_last - y_prev\n\n        # Extrapolate the next position\n        x_next, y_next = x_last + dx, y_last + dy\n\n        # Ensure the next position is within bounds\n        if 0 <= x_next < grid_shape[0] and 0 <= y_next < grid_shape[1]:\n            # Blit the object to the next position in the output grid\n            blit_sprite(output_grid, obj_last, x=x_next, y=y_next, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -> List[np.ndarray]:\n    # Generate a sequence of grids with a consistent transformation pattern\n    num_grids = np.random.randint(3, 5)\n    grid_shape = (10, 10)\n    grids = [np.full(grid_shape, Color.BLACK) for _ in range(num_grids)]\n\n    # Randomly choose the number and color of objects\n    num_objects = np.random.randint(1, 4)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_objects, replace=False)\n\n    for i in range(num_objects):\n        # Randomly initialize the shape and position of the object\n        size = np.random.randint(1, 3)\n        sprite = np.full((size, size), colors[i])\n        x, y = np.random.randint(0, grid_shape[0] - size), np.random.randint(0, grid_shape[1] - size)\n        \n        # Apply a consistent transformation across grids\n        dx, dy = np.random.choice([-1, 0, 1], size=2)  # Movement vector\n\n        for t in range(num_grids):\n            # Place the object on the grid\n            grids[t] = blit_sprite(grids[t], sprite, x=x + t*dx, y=y + t*dy, background=Color.BLACK)\n\n    return grids"], "seeds": ["bc1d5164.py", "e21d9049.py", "995c5fa3.py", "3ac3eb23.py", "Concepts: \npattern extrapolation, sequence prediction, feature analysis, progression detection\n\nDescription: \nInput consists of a sequence of grids representing consecutive time steps, where objects exhibit a consistent transformation pattern in terms of position, size, or color. Analyze the sequence to identify the evolving pattern, such as linear movement, size change, or color shift. Extrapolate the identified pattern to predict and generate the next grid in the sequence. The output is a single grid that continues the detected pattern logically from the last input grid."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# Identify a single object within the grid and a target position. Remove the object from its original location by erasing its pixels.\n# Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels. \n# The grid is updated to reflect the object's new position, with all other elements unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the objects in the input grid.\n    # 2. Select one object to move.\n    # 3. Determine a new target position for the object that does not overlap with other objects.\n    # 4. Erase the object from its current location and redraw it at the target location.\n\n    # Detect all objects in the grid, assuming they are monochromatic (single-colored).\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Select the first object to move (for simplicity in this example).\n    obj_to_move = objects[0]\n\n    # Get the object's current position.\n    x, y = object_position(obj_to_move, background=Color.BLACK)\n\n    # Crop the object to work with it as a sprite.\n    sprite = crop(obj_to_move, background=Color.BLACK)\n\n    # Create a copy of the input grid to modify it.\n    output_grid = np.copy(input_grid)\n\n    # Erase the object from its current position in the grid.\n    blit_sprite(output_grid, np.full(sprite.shape, Color.BLACK), x, y, background=Color.BLACK)\n\n    # Determine a random new position for the object that is free.\n    new_x, new_y = random_free_location_for_sprite(output_grid, sprite, background=Color.BLACK, padding=1)\n\n    # Draw the object at the new position.\n    blit_sprite(output_grid, sprite, new_x, new_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of random dimensions between 10x10 and 15x15.\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a few objects to place on the grid.\n    num_objects = np.random.randint(3, 5)\n    for _ in range(num_objects):\n        # Generate an object with random size and color.\n        obj_width, obj_height = np.random.randint(2, 4), np.random.randint(2, 4)\n        color = random.choice(Color.NOT_BLACK)\n        obj_sprite = np.full((obj_width, obj_height), color)\n        \n        # Find a free location in the grid for this object.\n        x, y = random_free_location_for_sprite(grid, obj_sprite, background=Color.BLACK, padding=1)\n        \n        # Place the object on the grid.\n        blit_sprite(grid, obj_sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# In the input, you will see a grid with several objects of different colors against a black background. One of the objects is marked with a unique color (e.g., BLUE).\n# To make the output, identify the object with the unique color, erase it from its original position, and move it to a target position on the grid.\n# The target position is marked by a distinct color (e.g., MAROON) and does not overlap with any other objects.\n# The output grid will have the object at its new position with all other elements unchanged.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Plan:\n    # 1. Identify the object to move using the unique color.\n    # 2. Find the target position marked by the distinct color.\n    # 3. Check for collisions at the target position.\n    # 4. Erase the object from its original position and redraw it at the target position.\n\n    # Identify the object to move\n    objects = detect_objects(input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=8)\n    assert len(objects) == 1\n    object_to_move = objects[0]\n\n    # Find the target position marked by the distinct color\n    target_x, target_y = np.argwhere(input_grid == Color.MAROON)[0]\n\n    # Check for collision at the target position\n    sprite = crop(object_to_move, background=Color.BLACK)\n    if not collision(object1=input_grid, object2=sprite, x2=target_x, y2=target_y):\n        # Create a copy of the input grid to modify\n        output_grid = np.copy(input_grid)\n\n        # Erase the object from its original position\n        x, y = object_position(object_to_move, background=Color.BLACK)\n        blit_sprite(output_grid, np.full(sprite.shape, Color.BLACK), x, y)\n\n        # Redraw the object at the target position\n        blit_sprite(output_grid, sprite, target_x, target_y, background=Color.BLACK)\n        return output_grid\n\n    # If collision occurs, return the original grid\n    return input_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Create a grid with random dimensions\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate the object to move\n    object_color = Color.BLUE\n    object_width, object_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    object_sprite = random_sprite(object_width, object_height, color_palette=[object_color], background=Color.BLACK)\n\n    # Place the object randomly on the grid\n    x, y = random_free_location_for_sprite(grid, object_sprite, border_size=1, padding=1, background=Color.BLACK)\n    blit_sprite(grid, object_sprite, x, y)\n\n    # Place a target position marked by a distinct color\n    target_color = Color.MAROON\n    target_x, target_y = random_free_location_for_sprite(grid, np.full(object_sprite.shape, Color.BLACK), border_size=1, padding=1, background=Color.BLACK)\n    grid[target_x, target_y] = target_color\n\n    # Add some additional random objects for complexity\n    num_additional_objects = np.random.randint(2, 5)\n    for _ in range(num_additional_objects):\n        other_color = random.choice([c for c in Color.NOT_BLACK if c not in [object_color, target_color]])\n        object_width, object_height = np.random.randint(2, 4), np.random.randint(2, 4)\n        other_sprite = random_sprite(object_width, object_height, color_palette=[other_color], background=Color.BLACK)\n\n        try:\n            x, y = random_free_location_for_sprite(grid, other_sprite, border_size=1, padding=1, background=Color.BLACK)\n            blit_sprite(grid, other_sprite, x, y)\n        except ValueError:\n            # Skip if no space is found\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# In the input, you will see a grid with multiple objects of different colors on a black background. \n# A target position is also provided in the form of a special colored pixel (e.g., PINK).\n# To make the output, identify and move the object containing this target pixel to a new location specified by the target position.\n# Ensure the object does not overlap with any existing non-background pixels when redrawn.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all objects in the grid, including the target object marked by a PINK pixel.\n    # 2. Determine the target position from the PINK pixel.\n    # 3. Remove the target object from its initial position by setting its pixels to black.\n    # 4. Translate and redraw the object at the target position, ensuring no overlap.\n\n    # Extract all objects\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Find the target object containing the PINK pixel\n    target_object = next((obj for obj in objects if np.any(obj == Color.PINK)), None)\n    assert target_object is not None, \"No target object with a PINK pixel found.\"\n\n    # Determine the target position from the pink pixel\n    target_x, target_y = np.argwhere(target_object == Color.PINK)[0]\n\n    # Find new target position for the entire object using the PINK pixel's current position\n    new_x, new_y = target_x, target_y\n\n    # Create an output grid initialized as input grid\n    output_grid = np.copy(input_grid)\n\n    # Remove the target object from its original position\n    target_object_area = (target_object != Color.BLACK)\n    output_grid[target_object_area] = Color.BLACK\n\n    # Translate the target object to the new position\n    translated_object = translate(target_object, new_x - target_x, new_y - target_y)\n\n    # Ensure no overlapping occurs when drawing\n    if not collision(object1=output_grid, object2=translated_object, x2=new_x, y2=new_y):\n        blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of objects (2 to 5)\n    num_objects = np.random.randint(2, 6)\n\n    # Add objects to the grid\n    for _ in range(num_objects):\n        # Create a random sprite of size between 3x3 to 5x5\n        sprite_size = np.random.randint(3, 6)\n        sprite = random_sprite(sprite_size, sprite_size, color_palette=Color.NOT_BLACK)\n\n        # Find a random free location for the sprite and place it on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue  # If no space is available, skip this sprite placement\n\n    # Choose a random object to be the target object\n    objects = find_connected_components(grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    target_object = random.choice(objects)\n\n    # Select a random pixel within the target object to mark it with PINK as the target position\n    target_x, target_y = np.argwhere(target_object != Color.BLACK)[0]\n    grid[target_x, target_y] = Color.PINK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# Identify a single object within the grid and a target position. Remove the object from its original location by erasing its pixels.\n# Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels.\n# The grid is updated to reflect the object's new position, with all other elements unchanged.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Plan:\n    # 1. Extract the objects from the input grid.\n    # 2. Identify the object to be moved and the target position.\n    # 3. Check for possible collisions at the target position.\n    # 4. Erase the object from its original location and redraw it at the target position.\n\n    # Extract the objects from the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    \n    # Assume the first object is the one to be moved (for simplicity)\n    object_to_move = objects[0]\n    \n    # Get the sprite of the object to move\n    sprite = crop(object_to_move, background=Color.BLACK)\n    \n    # Identify the target position (for simplicity, choose a random free location)\n    target_x, target_y = random_free_location_for_sprite(input_grid, sprite, background=Color.BLACK, padding=1)\n\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Erase the object from its original position\n    x, y = object_position(object_to_move, background=Color.BLACK)\n    original_shape = object_to_move.shape\n    output_grid[x:x+original_shape[0], y:y+original_shape[1]] = Color.BLACK\n\n    # Redraw the object at the target position\n    blit_sprite(output_grid, sprite, target_x, target_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random sprite and place it in the grid\n    sprite_size = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite = random_sprite(*sprite_size, color_palette=Color.NOT_BLACK, connectivity=8)\n\n    # Find a random free location to place the sprite\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n\n    # Place the sprite in the grid\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# Identify a single object within the grid and a target position. Remove the object from its original location by erasing its pixels. \n# Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels.\n# The grid is updated to reflect the object's new position, with all other elements unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the object in the grid\n    # 2. Determine the target position for the object\n    # 3. Remove the object from its original position\n    # 4. Place the object at the target position if there is no collision\n\n    # Step 1: Detect the object\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False, connectivity=8)\n    assert len(objects) == 1, \"There should be exactly one object in the input grid.\"\n    obj = objects[0]\n\n    # Step 2: Determine the target position for the object\n    # For demonstration, let's assume the target position is given by the target_coordinates variable.\n    target_coordinates = (3, 3)  # This could be dynamically determined or passed as an argument\n\n    # Step 3: Remove the object from its original position\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    obj_x, obj_y = object_position(obj, background=Color.BLACK)\n    sprite = crop(obj, background=Color.BLACK)\n    \n    # Erase the object from its original position\n    output_grid[obj_x:obj_x+sprite.shape[0], obj_y:obj_y+sprite.shape[1]] = Color.BLACK\n\n    # Step 4: Place the object at the target position if there is no collision\n    target_x, target_y = target_coordinates\n    if not collision(object1=output_grid, object2=sprite, x2=target_x, y2=target_y):\n        blit_sprite(output_grid, sprite, target_x, target_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random non-background elements and a single object\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Add a single object\n    object_size = np.random.randint(2, 4)\n    object_sprite = random_sprite(object_size, object_size, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n\n    # Find a random free location for the object sprite\n    x, y = random_free_location_for_sprite(grid, object_sprite, padding=1, border_size=1)\n    blit_sprite(grid, object_sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# In the input grid, there is a single object represented by connected pixels of the same color.\n# A target position is marked by a unique color (not black or the object's color).\n# The task is to remove the object from its original location and redraw it at the target position, ensuring no overlap with existing non-background pixels.\n# The output grid should reflect the object's new position, with all other elements unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the object from the input grid.\n    # 2. Identify the target position using the unique color.\n    # 3. Check if moving the object to the target position would cause any overlap.\n    # 4. If no overlap, move the object to the target position.\n    # 5. Return the updated grid.\n\n    # Step 1: Extract the object from the input grid.\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one object in the input grid.\"\n    original_object = objects[0]\n\n    # Step 2: Identify the target position using the unique color.\n    # The unique color is not black and not the object's color.\n    unique_colors = [color for color in Color.NOT_BLACK if np.count_nonzero(input_grid == color) == 1]\n    assert len(unique_colors) == 1, \"There should be exactly one unique color in the input grid.\"\n    target_color = unique_colors[0]\n    target_x, target_y = np.argwhere(input_grid == target_color)[0]\n\n    # Step 3: Check if moving the object to the target position would cause any overlap.\n    sprite = crop(original_object, background=Color.BLACK)\n    sprite_height, sprite_width = sprite.shape\n    destination_x = target_x - sprite_height // 2\n    destination_y = target_y - sprite_width // 2\n\n    if collision(object1=input_grid, object2=sprite, x2=destination_x, y2=destination_y):\n        raise ValueError(\"Moving the object to the target position would cause overlap.\")\n\n    # Step 4: Move the object to the target position.\n    output_grid = np.copy(input_grid)\n    output_grid[output_grid == target_color] = Color.BLACK  # Clear the target mark\n    blit_sprite(output_grid, sprite, destination_x, destination_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a medium-sized grid (e.g., 10x10) with a black background.\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate an object as a sprite.\n    obj_width, obj_height = np.random.randint(2, 4), np.random.randint(2, 4)\n    object_color = random.choice(Color.NOT_BLACK)\n    object_sprite = random_sprite(obj_height, obj_width, color_palette=[object_color], background=Color.BLACK)\n\n    # Find a random free location for the object sprite and place it on the grid.\n    x, y = random_free_location_for_sprite(grid, object_sprite, padding=1, background=Color.BLACK)\n    blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n\n    # Place a unique color on the grid to mark the target position.\n    target_color = random.choice([color for color in Color.NOT_BLACK if color != object_color])\n    target_x, target_y = np.random.randint(0, n), np.random.randint(0, m)\n    while grid[target_x, target_y] != Color.BLACK:\n        target_x, target_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[target_x, target_y] = target_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# Identify a single object within the grid and a target position.\n# Remove the object from its original location by erasing its pixels.\n# Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels.\n# The grid is updated to reflect the object's new position, with all other elements unchanged.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Plan:\n    # 1. Detect all objects in the grid.\n    # 2. Choose an object to move (for simplicity, we'll choose the first one).\n    # 3. Determine a random target position that does not cause the object to overlap with other objects.\n    # 4. Erase the object from its original position.\n    # 5. Redraw the object at the new position.\n\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Assume we move the first object\n    object_to_move = objects[0]\n\n    # Determine original position of the object\n    original_x, original_y = object_position(object_to_move, background=Color.BLACK)\n    \n    # Generate a sprite from the object\n    sprite = crop(object_to_move, background=Color.BLACK)\n    \n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Erase the object from its original position\n    for x, y in np.argwhere(object_to_move != Color.BLACK):\n        output_grid[original_x + x, original_y + y] = Color.BLACK\n\n    # Find a random free location for the sprite\n    new_x, new_y = random_free_location_for_sprite(output_grid, sprite, background=Color.BLACK, padding=0)\n    \n    # Redraw the object at the new position\n    blit_sprite(output_grid, sprite, new_x, new_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Create a grid with random objects scattered around\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Create a random object (sprite)\n        sprite_height, sprite_width = np.random.randint(2, 4), np.random.randint(2, 4)\n        sprite = random_sprite(sprite_height, sprite_width, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n\n        # Find a free location for this sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no space is found, skip this object\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, grid update, erase and redraw\n\n# description:\n# Identify a single object within the grid and a target position. Remove the object from its original location by erasing its pixels.\n# Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels.\n# The grid is updated to reflect the object's new position, with all other elements unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all objects in the input grid.\n    # 2. Choose one object to move and determine its current position.\n    # 3. Determine a random free target position on the grid for the object.\n    # 4. Erase the object from its current position.\n    # 5. Redraw the object at the target position, ensuring no overlap with existing objects.\n\n    # Step 1: Detect objects\n    objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=False, connectivity=8)\n\n    # Assume we are moving the first detected object for simplicity\n    object_to_move = objects[0]\n\n    # Step 2: Determine current position\n    x_current, y_current = object_position(object_to_move, background=Color.BLACK)\n\n    # Step 3: Determine a random free target position\n    sprite = crop(object_to_move, background=Color.BLACK)\n    x_target, y_target = random_free_location_for_sprite(input_grid, sprite, padding=0, background=Color.BLACK)\n\n    # Step 4: Erase the object from its current position\n    # Create a copy of the grid to work on\n    output_grid = np.copy(input_grid)\n    for x, y in np.argwhere(object_to_move != Color.BLACK):\n        output_grid[x + x_current, y + y_current] = Color.BLACK\n\n    # Step 5: Redraw the object at the target position\n    blit_sprite(output_grid, sprite, x_target, y_target, background=Color.BLACK)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid with a few non-overlapping objects\n    n, m = 15, 15  # grid size\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate a random number of objects\n    num_objects = np.random.randint(2, 5)\n    \n    for _ in range(num_objects):\n        # Generate a random object (sprite)\n        sprite_size = np.random.randint(3, 6)\n        sprite = random_sprite(sprite_size, sprite_size, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n        \n        # Place the sprite on the grid, ensuring it doesn't overlap with existing objects\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, background=Color.BLACK)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no space is found, try creating a smaller object\n            continue\n\n    return grid"], "seeds": ["137eaa0f.py", "1f642eb9.py", "31aa019c.py", "44d8ac46.py", "Concepts: \nobject movement, grid update, erase and redraw\n\nDescription: \nIdentify a single object within the grid and a target position. Remove the object from its original location by erasing its pixels. Redraw the object at the specified target position, ensuring no overlap with existing non-background pixels. The grid is updated to reflect the object's new position, with all other elements unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, recoloring, color scheme\n\n# description:\n# In the input grid, you will find various connected objects of different colors.\n# To create the output grid, select the largest connected object and apply a color gradient to it.\n# The gradient will transition from one color to another (e.g., from red to blue) based on the position of each pixel within the object.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the grid, considering all colors except black as part of objects\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Identify the largest connected object\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Define a color gradient from red to blue\n    start_color = Color.RED\n    end_color = Color.BLUE\n\n    # Calculate the dimensions of the largest object\n    x_min, y_min, x_max, y_max = bounding_box(largest_object, background=Color.BLACK)\n    width = x_max - x_min + 1\n    height = y_max - y_min + 1\n\n    # Apply the color gradient to the largest object\n    for x in range(width):\n        for y in range(height):\n            if largest_object[x + x_min, y + y_min] != Color.BLACK:\n                # Calculate the gradient color based on position\n                ratio = (x / width + y / height) / 2\n                new_color = blend_colors(start_color, end_color, ratio)\n                largest_object[x + x_min, y + y_min] = new_color\n\n    # Create the output grid, blitting the recolored largest object back in place\n    output_grid = input_grid.copy()\n    blit_object(output_grid, largest_object, background=Color.BLACK)\n\n    return output_grid\n\ndef blend_colors(start, end, ratio):\n    # Blend two colors by a ratio between 0 and 1\n    # This is a simplified function that assumes colors are represented as RGB tuples\n    start_rgb = (255, 0, 0)  # Red\n    end_rgb = (0, 0, 255)    # Blue\n\n    blended_rgb = tuple(int(start_rgb[i] + (end_rgb[i] - start_rgb[i]) * ratio) for i in range(3))\n    return blended_rgb\n\ndef generate_input():\n    # Create a grid of size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Add random objects with random colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj = random_sprite(list(range(3, 6)), list(range(3, 6)), color_palette=Color.NOT_BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# In the input grid, you will find several connected objects of various colors. One of these objects will be marked with a special color.\n# The task is to recolor the entire marked object using a specific color scheme: alternating colors in a checkerboard pattern. \n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all the objects in the grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # Identify the marked object\n    marked_color = Color.MAROON  # Assume MAROON is the special color marking the object\n    marked_object = None\n    for obj in objects:\n        if np.any(obj == marked_color):\n            marked_object = obj\n            break\n\n    # Apply checkerboard pattern to the marked object\n    output_grid = input_grid.copy()\n    if marked_object is not None:\n        x, y, w, h = bounding_box(marked_object, background=Color.BLACK)\n        for i in range(x, x + w):\n            for j in range(y, y + h):\n                if marked_object[i - x, j - y] != Color.BLACK:\n                    if (i + j) % 2 == 0:\n                        output_grid[i, j] = Color.RED  # First color of the checkerboard pattern\n                    else:\n                        output_grid[i, j] = Color.BLUE  # Second color of the checkerboard pattern\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random objects\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create several random objects\n    num_objects = np.random.randint(2, 5)\n    for _ in range(num_objects):\n        obj = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=Color.NOT_BLACK)\n        x, y = random_free_location_for_sprite(grid, obj, padding=1)\n        blit_sprite(grid, obj, x, y)\n\n    # Mark one object with the special color\n    objects = find_connected_components(grid, connectivity=8)\n    marked_obj = np.random.choice(objects)\n    for i in range(marked_obj.shape[0]):\n        for j in range(marked_obj.shape[1]):\n            if marked_obj[i, j] != Color.BLACK:\n                marked_obj[i, j] = Color.MAROON\n\n    # Blit the marked object back into the grid\n    x, y, _, _ = bounding_box(marked_obj, background=Color.BLACK)\n    blit_object(grid, marked_obj, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, recoloring, gradient color scheme\n\n# description:\n# Identify a single connected object in the input grid. Recolor the object using a gradient color scheme starting from the top-left corner of its bounding box, fading towards the bottom-right. The gradient should transition from one color to another, e.g., from blue to green. The rest of the grid should remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # Select the largest object to apply the gradient recolor\n    selected_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Get the bounding box coordinates of the selected object\n    x, y, width, height = bounding_box(selected_object)\n    \n    # Create a gradient color map from blue to green\n    gradient_colors = [Color.BLUE, Color.GREEN]\n    gradient = np.linspace(0, 1, max(width, height))\n    \n    # Create a copy of the input grid for transformation\n    output_grid = input_grid.copy()\n\n    # Apply the gradient color transformation\n    for i in range(width):\n        for j in range(height):\n            if selected_object[i + x, j + y] != Color.BLACK:\n                blend_ratio = (i + j) / (width + height - 2)\n                color_index = int(blend_ratio * (len(gradient_colors) - 1))\n                output_grid[i + x, j + y] = gradient_colors[color_index]\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random size and a single connected object\n    n = np.random.randint(10, 15)\n    input_grid = np.full((n, n), Color.BLACK)\n    \n    # Generate a random sprite with a random color\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n    sprite = random_sprite(n//2, n//2, color_palette=[sprite_color], connectivity=8)\n    \n    # Place the sprite in the grid\n    x, y = random_free_location_for_sprite(input_grid, sprite, border_size=1)\n    blit_sprite(input_grid, sprite, x, y)\n    \n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, recolor, color scheme\n\n# description:\n# In the input grid, detect a single connected object and apply a color scheme to recolor the entire object.\n# The color scheme may be a single color applied uniformly or a logic that determines the color for each part of the object.\n# All other grid elements remain unchanged.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Find the largest connected component in the grid\n    components = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n    largest_component = max(components, key=lambda comp: np.sum(comp != Color.BLACK))\n\n    # Define a color scheme (e.g., a gradient or a single color)\n    color_scheme = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.ORANGE]\n\n    # Apply the color scheme to the largest component\n    component_size = np.sum(largest_component != Color.BLACK)\n    step = max(1, component_size // len(color_scheme))\n    \n    output_grid = input_grid.copy()\n    indices = np.argwhere(largest_component != Color.BLACK)\n    \n    for idx, (x, y) in enumerate(indices):\n        color_index = min(idx // step, len(color_scheme) - 1)\n        output_grid[x, y] = color_scheme[color_index]\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Create a grid of a random size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random connected object\n    object_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(n=[3, 4, 5], m=[3, 4, 5], color_palette=[object_color], connectivity=8)\n    \n    # Place the object in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, sprite, x=x, y=y)\n\n    # Optionally add some noise or other objects\n    noise_density = 0.1\n    for _ in range(int(noise_density * n * m)):\n        nx, ny = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[nx, ny] == Color.BLACK:\n            grid[nx, ny] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, recoloring, color scheme\n\n# description:\n# In the input grid, you will see multiple colored objects.\n# Identify one single connected object and recolor it with a randomly selected single color from the available color palette.\n# All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8)\n    \n    # Choose a single object to recolor\n    selected_object = objects[0]  # Select the first object for simplicity\n    \n    # Choose a new color from the available palette, excluding black\n    new_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Recolor the entire object with the new color\n    selected_object[selected_object != Color.BLACK] = new_color\n    \n    # Create a copy of the input grid to form the output\n    output_grid = input_grid.copy()\n    \n    # Apply the recolored object back onto the grid\n    blit_object(output_grid, selected_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate random objects with random colors\n    num_objects = np.random.randint(3, 6)\n    \n    for _ in range(num_objects):\n        # Generate a random sprite with random color\n        sprite_size = np.random.randint(3, 5)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(sprite_size, sprite_size, color_palette=[color], connectivity=8)\n        \n        # Place the sprite in a random location on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If unable to place the sprite, retry\n            return generate_input()\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# In the input grid, you will see several objects of various colors.\n# Identify the single largest connected object and recolor it based on its size.\n# Use a gradient of colors (light to dark) based on predefined size ranges.\n# All other elements in the grid remain unchanged.\n\ndef main(input_grid):\n    # Find all connected components\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Determine the largest object by area\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Define size ranges and corresponding colors\n    size_colors = [\n        (0, 10, Color.GREY),   # small objects\n        (11, 20, Color.BLUE),  # medium objects\n        (21, np.inf, Color.MAROON)  # large objects\n    ]\n\n    # Determine the size of the largest object\n    largest_object_size = np.sum(largest_object != Color.BLACK)\n\n    # Find the appropriate color based on the object's size\n    for (min_size, max_size, color) in size_colors:\n        if min_size <= largest_object_size <= max_size:\n            largest_object[largest_object != Color.BLACK] = color\n            break\n\n    # Create the output grid and place the recolored object back\n    output_grid = input_grid.copy()\n    blit_object(output_grid, largest_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Randomly determine grid size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Populate the grid with randomly sized and colored objects\n    for _ in range(np.random.randint(3, 6)):  # random number of objects\n        obj = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=Color.NOT_BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1, border_size=1)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no place can be found, break the loop\n            break\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# The input grid will contain multiple colored objects. The task is to identify a single connected object randomly and apply a color scheme to recolor the entire object.\n# The color scheme may be a single color applied uniformly or a pattern based on the position within the object.\n# All other grid elements remain unchanged.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Select a single object to apply the color scheme\n    chosen_object = random.choice(objects)\n    x, y, width, height = bounding_box(chosen_object)\n\n    # Create a color scheme function, for example, a gradient based on the x coordinate\n    color_scheme = lambda pos: Color.ALL_COLORS[(pos[0] + pos[1]) % len(Color.ALL_COLORS)]\n\n    # Apply the color scheme to the chosen object\n    for x_offset, y_offset in np.argwhere(chosen_object != Color.BLACK):\n        chosen_object[x_offset, y_offset] = color_scheme((x_offset, y_offset))\n\n    # Create the output grid and blit the recolored object onto it\n    output_grid = input_grid.copy()\n    blit_object(output_grid, chosen_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Define the size of the grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate and place multiple objects in the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=Color.NOT_BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1, padding_connectivity=8)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            # If unable to place the object, continue to the next\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recolor, connected components, color scheme\n\n# description:\n# Identify a single connected object in the input grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color applied uniformly or a logic that determines the color for each part of the object. All other grid elements remain unchanged.\n\ndef main(input_grid):\n    # Detect all the connected components in the grid\n    components = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n\n    # For simplicity, apply the color scheme to the first detected object\n    target_object = components[0]\n\n    # Define a color scheme: cycle through a subset of colors\n    color_scheme = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]\n\n    # Apply the color scheme to the target object\n    output_grid = input_grid.copy()\n    for idx, (x, y) in enumerate(zip(*np.where(target_object != Color.BLACK))):\n        output_grid[x, y] = color_scheme[idx % len(color_scheme)]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random connected object\n    sprite_size = np.random.randint(4, min(n, m) // 2)\n    sprite = random_sprite(sprite_size, sprite_size, color_palette=Color.NOT_BLACK, connectivity=8)\n\n    # Place the sprite in the grid at a random location\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid"], "seeds": ["aedd82e4.py", "810b9b61.py", "06df4c85.py", "d2abd087.py", "Concepts: \nrecolor, connected components, color scheme\n\nDescription: \nIdentify a single connected object in the input grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color applied uniformly or a logic that determines the color for each part of the object. All other grid elements remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors that do not appear in other regions.\n# The task is to identify these regions and treat them as separate entities for further processing. The output maintains the structure of these regions without altering the internal arrangement of pixels within each region.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the divider lines to determine the distinct regions\n    # 2. Extract each region based on the divider lines\n    # 3. Assemble the output grid maintaining the internal arrangement of each region\n\n    # 1. Identify divider lines (assumed to be black lines in this case)\n    width, height = input_grid.shape\n    background = Color.BLACK\n\n    # Find all vertical and horizontal divider lines\n    vertical_lines = [x for x in range(width) if np.all(input_grid[x, :] == background)]\n    horizontal_lines = [y for y in range(height) if np.all(input_grid[:, y] == background)]\n\n    # Start from (0, 0)\n    vertical_lines = [0] + vertical_lines + [width]\n    horizontal_lines = [0] + horizontal_lines + [height]\n\n    # 2. Extract each region based on divider lines\n    regions = []\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x1, x2 = vertical_lines[i], vertical_lines[i + 1]\n            y1, y2 = horizontal_lines[j], horizontal_lines[j + 1]\n            region = input_grid[x1:x2, y1:y2]\n            regions.append(region)\n\n    # 3. Assemble the output grid maintaining the structure of regions\n    # Output grid will have the same size as input grid\n    output_grid = np.full(input_grid.shape, background)\n\n    # Place each region in its original position\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x1, x2 = vertical_lines[i], vertical_lines[i + 1]\n            y1, y2 = horizontal_lines[j], horizontal_lines[j + 1]\n            output_grid[x1:x2, y1:y2] = regions[i * (len(horizontal_lines) - 1) + j]\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the number of regions\n    n_regions_horizontal, n_regions_vertical = np.random.randint(2, 5), np.random.randint(2, 5)\n\n    # Randomly space indices for divider lines\n    horizontal_dividers = randomly_spaced_indices(max_len=width, n_indices=n_regions_horizontal - 1, border_size=1, padding=2)\n    vertical_dividers = randomly_spaced_indices(max_len=height, n_indices=n_regions_vertical - 1, border_size=1, padding=2)\n\n    # Draw divider lines\n    # Draw vertical divider lines\n    for x in horizontal_dividers:\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=Color.BLACK)\n\n    # Draw horizontal divider lines\n    for y in vertical_dividers:\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=Color.BLACK)\n\n    # Fill regions with unique colors\n    colors = np.random.choice(Color.NOT_BLACK, (n_regions_horizontal, n_regions_vertical), replace=False)\n\n    for X in range(n_regions_horizontal):\n        for Y in range(n_regions_vertical):\n            # Get the region boundary\n            x1 = 0 if X == 0 else horizontal_dividers[X-1]\n            x2 = horizontal_dividers[X] if X < len(horizontal_dividers) else width\n            y1 = 0 if Y == 0 else vertical_dividers[Y-1]\n            y2 = vertical_dividers[Y] if Y < len(vertical_dividers) else height\n\n            # Fill the region with a specific color\n            region = grid[x1:x2, y1:y2]\n            region.fill(colors[X, Y])\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors that do not appear in other regions.\n# The task is to identify these regions and treat them as separate entities for further processing. The output maintains the structure of these regions without altering the internal arrangement of pixels within each region.\n# Specifically, the output should highlight the boundaries of each region by coloring them with a specific boundary color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the regions separated by the divider lines.\n    # 2. For each region, detect its boundary.\n    # 3. Create an output grid where each region's boundary is highlighted with a specific color, leaving the internal arrangement of pixels unchanged.\n\n    # Identify the divider color, which is the most frequent non-background color\n    divider_color = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n\n    # Find all the regions separated by the divider color\n    regions = find_connected_components(input_grid, background=divider_color, connectivity=4, monochromatic=False)\n\n    # Create an output grid initialized as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Define a boundary color\n    boundary_color = Color.GREY\n\n    # Process each region\n    for region in regions:\n        # Find the boundary of the region\n        region_boundary = object_boundary(region, background=divider_color)\n\n        # Highlight the boundary in the output grid\n        for x, y in np.argwhere(region_boundary):\n            output_grid[x, y] = boundary_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of arbitrary size with a black background\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a color for dividers\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly generate divider lines\n    num_dividers = np.random.randint(2, 5)\n    x_indices = randomly_spaced_indices(n, num_dividers, border_size=1, padding=2)\n    y_indices = randomly_spaced_indices(m, num_dividers, border_size=1, padding=2)\n\n    # Draw vertical and horizontal dividers\n    for x in x_indices:\n        draw_line(grid, x, 0, direction=(0, 1), color=divider_color)\n    for y in y_indices:\n        draw_line(grid, 0, y, direction=(1, 0), color=divider_color)\n\n    # Fill each region with a random color\n    regions = find_connected_components(grid=grid, background=divider_color, connectivity=4, monochromatic=True)\n    for region in regions:\n        color = np.random.choice(list(Color.NOT_BLACK - {divider_color}))\n        region_interior = object_interior(region, background=divider_color)\n        for x, y in np.argwhere(region_interior):\n            grid[x, y] = color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors that do not appear in other regions.\n# The task is to identify these regions and treat them as separate entities for further processing. The output maintains the structure of these regions without altering the internal arrangement of pixels within each region.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the divider lines and the regions they create\n    # 2. Ensure each region has unique colors not appearing in other regions\n    # 3. Return the grid with the same structure, maintaining the regions\n\n    # Assuming the divider lines are black\n    divider_color = Color.BLACK\n    \n    # Find all connected components that are not the divider lines\n    regions = find_connected_components(input_grid, background=divider_color, connectivity=4, monochromatic=False)\n    \n    # Create the output grid with the same structure\n    output_grid = input_grid.copy()\n\n    # For each region, maintain its structure\n    for region in regions:\n        # Find the bounding box of the region\n        x, y, w, h = bounding_box(region, background=divider_color)\n        \n        # Maintain the internal arrangement within the region\n        output_grid[x:x+w, y:y+h] = region[x:x+w, y:y+h]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly decide the number of regions\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    # Randomly place divider lines\n    horizontal_lines = randomly_spaced_indices(max_len=height, n_indices=num_horizontal_dividers, border_size=1, padding=2)\n    vertical_lines = randomly_spaced_indices(max_len=width, n_indices=num_vertical_dividers, border_size=1, padding=2)\n\n    # Draw horizontal and vertical divider lines\n    for y in horizontal_lines:\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=Color.BLACK)\n    for x in vertical_lines:\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=Color.BLACK)\n\n    # Define regions by finding areas between the dividers\n    x_endpoints = [0] + vertical_lines + [width]\n    y_endpoints = [0] + horizontal_lines + [height]\n\n    # Randomly color each region with a unique color\n    for i in range(len(x_endpoints) - 1):\n        for j in range(len(y_endpoints) - 1):\n            region_color = np.random.choice(list(Color.NOT_BLACK))\n            x1, x2 = x_endpoints[i], x_endpoints[i+1]\n            y1, y2 = y_endpoints[j], y_endpoints[j+1]\n            grid[x1:x2, y1:y2] = region_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors \n# that do not appear in other regions. The task is to identify these regions and treat them as separate entities for further processing.\n# The output maintains the structure of these regions without altering the internal arrangement of pixels within each region.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the divider lines in the input grid to determine the regions.\n    # 2. Extract each region based on the divider lines.\n    # 3. Create an output grid that maintains the structure of these regions without altering their internal arrangement.\n\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Step 1: Identify divider lines\n    width, height = input_grid.shape\n    divider_color = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n    \n    # Identify vertical and horizontal lines\n    vertical_lines = [x for x in range(width) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(height) if np.all(input_grid[:, y] == divider_color)]\n\n    # Include the boundaries of the grid as potential dividers\n    vertical_lines = [0] + vertical_lines + [width]\n    horizontal_lines = [0] + horizontal_lines + [height]\n\n    # Step 2: Extract each region based on the divider lines\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x1, x2 = vertical_lines[i], vertical_lines[i+1]\n            y1, y2 = horizontal_lines[j], horizontal_lines[j+1]\n\n            # Extract region\n            region = input_grid[x1:x2, y1:y2]\n\n            # Step 3: Maintain the structure of the region\n            # Simply blit the region back onto the output grid\n            output_grid[x1:x2, y1:y2] = region\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the grid separation\n    n_region_horizontal, n_region_vertical = np.random.randint(2, 5), np.random.randint(2, 5)\n    horizontal_boundaries = randomly_spaced_indices(max_len=width, n_indices=n_region_horizontal - 1, border_size=1, padding=2)\n    vertical_boundaries = randomly_spaced_indices(max_len=height, n_indices=n_region_vertical - 1, border_size=1, padding=2)\n\n    # Randomly select the colors to fill each region\n    colors = np.random.choice(Color.NOT_BLACK, (n_region_horizontal, n_region_vertical), replace=True)\n\n    # Assign the colors to each region\n    for X in range(n_region_horizontal):\n        for Y in range(n_region_vertical):\n            x1 = 0 if X == 0 else horizontal_boundaries[X-1]\n            x2 = horizontal_boundaries[X] if X < len(horizontal_boundaries) else width\n            y1 = 0 if Y == 0 else vertical_boundaries[Y-1]\n            y2 = vertical_boundaries[Y] if Y < len(vertical_boundaries) else height\n\n            grid[x1:x2, y1:y2] = colors[X, Y]\n    \n    # Draw black lines to separate the regions\n    divider_color = np.random.choice(Color.NOT_BLACK)\n    for x in horizontal_boundaries:\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=divider_color)\n    for y in vertical_boundaries:\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=divider_color)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors that do not appear in other regions.\n# The task is to identify these regions and treat them as separate entities for further processing. The output maintains the structure of these regions without altering the internal arrangement of pixels within each region.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the dividers and regions in the grid.\n    # 2. Extract each region based on unique colors.\n    # 3. Ensure the output grid mimics the structure of regions without altering their internal arrangements.\n\n    # Identify the background (divider) color as the most frequent non-black color\n    divider_color = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n    \n    # Find all dividers, which are lines of the divider color\n    vertical_dividers = np.all(input_grid == divider_color, axis=1)\n    horizontal_dividers = np.all(input_grid == divider_color, axis=0)\n\n    # Calculate x and y positions where dividers exist\n    vertical_indices = np.where(vertical_dividers)[0]\n    horizontal_indices = np.where(horizontal_dividers)[0]\n\n    # Include grid boundaries as potential dividers\n    vertical_indices = np.insert(vertical_indices, [0, len(vertical_indices)], [0, input_grid.shape[0]])\n    horizontal_indices = np.insert(horizontal_indices, [0, len(horizontal_indices)], [0, input_grid.shape[1]])\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Iterate over each possible region defined by the dividers\n    for i in range(len(vertical_indices) - 1):\n        for j in range(len(horizontal_indices) - 1):\n            x1, x2 = vertical_indices[i], vertical_indices[i+1]\n            y1, y2 = horizontal_indices[j], horizontal_indices[j+1]\n\n            # Extract the region\n            region = input_grid[x1:x2, y1:y2]\n            \n            # Find the unique color in the region (excluding the divider color)\n            unique_colors = set(np.unique(region)) - {divider_color, Color.BLACK}\n            \n            # If there is exactly one unique color, fill output with that color\n            if len(unique_colors) == 1:\n                color = unique_colors.pop()\n                output_grid[x1:x2, y1:y2] = region\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid size\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly choose a divider color\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Define vertical and horizontal dividers\n    num_vertical_dividers = np.random.randint(1, 4)\n    num_horizontal_dividers = np.random.randint(1, 4)\n\n    vertical_divider_positions = randomly_spaced_indices(grid_size, num_vertical_dividers, border_size=1, padding=2)\n    horizontal_divider_positions = randomly_spaced_indices(grid_size, num_horizontal_dividers, border_size=1, padding=2)\n\n    # Draw dividers on the grid\n    for x in vertical_divider_positions:\n        draw_line(grid, x, 0, direction=(0, 1), color=divider_color)\n    for y in horizontal_divider_positions:\n        draw_line(grid, 0, y, direction=(1, 0), color=divider_color)\n\n    # Fill regions with unique colors\n    for i in range(len(vertical_divider_positions) - 1):\n        for j in range(len(horizontal_divider_positions) - 1):\n            x1, x2 = vertical_divider_positions[i], vertical_divider_positions[i+1]\n            y1, y2 = horizontal_divider_positions[j], horizontal_divider_positions[j+1]\n\n            region_color = np.random.choice(list(Color.NOT_BLACK - {divider_color}))\n            grid[x1+1:x2, y1+1:y2] = region_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines that span the grid.\n# Each region contains pixels of specific colors that do not appear in other regions.\n# The task is to identify these regions and treat them as separate entities for further processing.\n# The output maintains the structure of these regions without altering the internal arrangement of pixels within each region.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the divider lines to separate regions.\n    # 2. Find the regions between the divider lines.\n    # 3. Maintain the regions in the output grid as they are in the input.\n\n    # 1. Identify the divider lines\n    divider_color = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n    vertical_lines = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n\n    # Ensure to include the boundaries of the grid\n    vertical_lines = [0] + vertical_lines + [input_grid.shape[0]]\n    horizontal_lines = [0] + horizontal_lines + [input_grid.shape[1]]\n\n    # 2. Find regions between divider lines\n    regions = []\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x_start, x_end = vertical_lines[i], vertical_lines[i+1]\n            y_start, y_end = horizontal_lines[j], horizontal_lines[j+1]\n            region = input_grid[x_start:x_end, y_start:y_end]\n            regions.append(region)\n\n    # 3. Maintain the regions in the output grid\n    output_grid = np.full_like(input_grid, fill_value=Color.BLACK)\n    for i, region in enumerate(regions):\n        x_start, x_end = vertical_lines[i // len(horizontal_lines)], vertical_lines[i // len(horizontal_lines) + 1]\n        y_start, y_end = horizontal_lines[i % len(horizontal_lines)], horizontal_lines[i % len(horizontal_lines) + 1]\n        output_grid[x_start:x_end, y_start:y_end] = region\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a divider color\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw vertical and horizontal divider lines\n    num_vertical_dividers = np.random.randint(2, 5)\n    num_horizontal_dividers = np.random.randint(2, 5)\n    vertical_lines = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=2)\n    horizontal_lines = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=2)\n\n    for x in vertical_lines:\n        grid[x, :] = divider_color\n    for y in horizontal_lines:\n        grid[:, y] = divider_color\n\n    # Fill each region with a unique color\n    colors = set(Color.NOT_BLACK) - {divider_color}\n    for i in range(len(vertical_lines) + 1):\n        for j in range(len(horizontal_lines) + 1):\n            x_start = 0 if i == 0 else vertical_lines[i-1] + 1\n            x_end = vertical_lines[i] if i < len(vertical_lines) else width\n            y_start = 0 if j == 0 else horizontal_lines[j-1] + 1\n            y_end = horizontal_lines[j] if j < len(horizontal_lines) else height\n\n            region_color = np.random.choice(list(colors))\n            grid[x_start:x_end, y_start:y_end] = region_color\n            colors -= {region_color}\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines, which are solid black lines that span the grid.\n# Each region is filled with pixels of a specific color that do not appear in other regions. The task is to identify these regions and treat them as separate entities.\n# The output grid should represent each region with a single pixel of the predominant color within that region.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify divider lines to isolate regions.\n    # 2. Determine the predominant color within each region.\n    # 3. Create an output grid with one pixel per region, using the region's predominant color.\n\n    # 1. Identify divider lines\n    # Find horizontal and vertical black lines that divide the regions\n    vertical_dividers = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == Color.BLACK)]\n    horizontal_dividers = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == Color.BLACK)]\n\n    # Add edges as dividers\n    vertical_dividers = [0] + vertical_dividers + [input_grid.shape[0]]\n    horizontal_dividers = [0] + horizontal_dividers + [input_grid.shape[1]]\n\n    # 2. Determine the predominant color within each region\n    regions_colors = []\n    for i in range(len(vertical_dividers) - 1):\n        for j in range(len(horizontal_dividers) - 1):\n            # Extract the region\n            region = input_grid[vertical_dividers[i]:vertical_dividers[i+1], horizontal_dividers[j]:horizontal_dividers[j+1]]\n\n            # Find the predominant color in the region (ignoring black)\n            unique, counts = np.unique(region[region != Color.BLACK], return_counts=True)\n            if len(unique) > 0:\n                predominant_color = unique[np.argmax(counts)]\n            else:\n                predominant_color = Color.BLACK\n\n            regions_colors.append(predominant_color)\n\n    # 3. Create an output grid with one pixel per region\n    output_grid = np.array(regions_colors).reshape((len(vertical_dividers) - 1, len(horizontal_dividers) - 1))\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size with divider lines and distinct color regions\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly decide the number of vertical and horizontal regions\n    num_vertical_regions = np.random.randint(2, 5)\n    num_horizontal_regions = np.random.randint(2, 5)\n\n    # Generate random dividers\n    vertical_dividers = randomly_spaced_indices(width, num_vertical_regions - 1, border_size=1, padding=2)\n    horizontal_dividers = randomly_spaced_indices(height, num_horizontal_regions - 1, border_size=1, padding=2)\n\n    # Fill each region with a distinct color\n    colors = np.random.choice(list(Color.NOT_BLACK), (num_vertical_regions, num_horizontal_regions), replace=True)\n    for i, x in enumerate(vertical_dividers + [width]):\n        for j, y in enumerate(horizontal_dividers + [height]):\n            if i > 0 and j > 0:\n                region_color = colors[i-1, j-1]\n                for rx in range(vertical_dividers[i-1], x):\n                    for ry in range(horizontal_dividers[j-1], y):\n                        grid[rx, ry] = region_color\n\n    # Draw divider lines\n    for x in vertical_dividers:\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=Color.BLACK)\n    for y in horizontal_dividers:\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, divider lines, color-based regions\n\n# description:\n# The input grid is divided into distinct regions by divider lines of a specific color that span the grid vertically or horizontally. \n# Each region is filled with a unique color that does not appear in other regions. \n# The task is to identify these regions and output a grid where each region is represented by a single pixel of that region's color.\n\ndef main(input_grid):\n    # 1. Identify the divider lines and use them to partition the grid into regions.\n    # 2. Determine the color of each region.\n    # 3. Create an output grid where each region is represented by a single pixel with the region's color.\n\n    # Assume the divider lines are the most frequent non-background color.\n    divider_color = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n\n    # Find all connected components separated by the divider color\n    regions = find_connected_components(input_grid, background=divider_color, connectivity=4, monochromatic=True)\n    \n    # Determine the color of each region\n    region_colors = [object_colors(region, background=divider_color)[0] for region in regions]\n\n    # Create output grid, where each region is represented by a single pixel\n    output_width = len(set(object_position(region)[0] for region in regions))\n    output_height = len(set(object_position(region)[1] for region in regions))\n    output_grid = np.full((output_width, output_height), Color.BLACK)\n\n    for region, color in zip(regions, region_colors):\n        x, y = object_position(region, background=divider_color)\n        output_grid[x, y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a divider color\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create random dividers to partition the grid into regions\n    num_vertical_dividers = np.random.randint(1, 4)\n    num_horizontal_dividers = np.random.randint(1, 4)\n    \n    vertical_dividers = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=2)\n    horizontal_dividers = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=2)\n\n    for x in vertical_dividers:\n        draw_line(grid, x=x, y=0, direction=(0, 1), color=divider_color)\n\n    for y in horizontal_dividers:\n        draw_line(grid, x=0, y=y, direction=(1, 0), color=divider_color)\n\n    # Fill each region with a unique color\n    regions = find_connected_components(grid, background=divider_color, connectivity=4, monochromatic=True)\n    available_colors = list(Color.NOT_BLACK - {divider_color})\n    np.random.shuffle(available_colors)\n\n    for region in regions:\n        color = available_colors.pop()\n        interior_mask = object_interior(region, background=divider_color)\n        for x, y in np.argwhere(interior_mask):\n            grid[x, y] = color\n    \n    return grid"], "seeds": ["00d62c1b.py", "7837ac64.py", "780d0b14.py", "90c28cc7.py", "Concepts: \ngrid partitioning, divider lines, color-based regions\n\nDescription: \nThe input grid is divided into distinct regions by divider lines that span the grid. Each region contains pixels of specific colors that do not appear in other regions. The task is to identify these regions and treat them as separate entities for further processing. The output maintains the structure of these regions without altering the internal arrangement of pixels within each region."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# The input is a grid potentially divided into distinct regions by horizontal or vertical lines of a specific color.\n# Identify these divider lines and use them to segment the grid into separate regions.\n# Each region is extracted as a subgrid, excluding the divider lines themselves.\n# The output is a list of these subgrids, preserving their original content and relative order.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Find the divider color, which is the color that forms complete horizontal or vertical lines\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i, j]\n            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):\n                divider_color = color\n                break\n    assert divider_color is not None, \"No divider color found\"\n\n    # Find the indices of the horizontal and vertical divider lines\n    horizontal_dividers = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n    vertical_dividers = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n\n    # Add boundaries for easier slicing\n    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[1]]\n    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[0]]\n\n    # Extract subgrids excluding divider lines\n    subgrids = []\n    for i in range(len(vertical_dividers) - 1):\n        for j in range(len(horizontal_dividers) - 1):\n            x1, x2 = vertical_dividers[i] + 1, vertical_dividers[i + 1]\n            y1, y2 = horizontal_dividers[j] + 1, horizontal_dividers[j + 1]\n            subgrid = input_grid[x1:x2, y1:y2]\n            if subgrid.size > 0:\n                subgrids.append(subgrid)\n\n    return subgrids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate the grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(width, height))\n\n    # Randomly select a color to be the divider color\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly decide the number of horizontal and vertical dividers\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    # Place the horizontal and vertical dividers\n    horizontal_indices = randomly_spaced_indices(max_len=height, n_indices=num_horizontal_dividers, border_size=1, padding=1)\n    vertical_indices = randomly_spaced_indices(max_len=width, n_indices=num_vertical_dividers, border_size=1, padding=1)\n\n    for y in horizontal_indices:\n        grid[:, y] = divider_color\n    for x in vertical_indices:\n        grid[x, :] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# The input is a grid which may be divided into distinct regions by horizontal or vertical lines of a specific color.\n# The task is to identify these divider lines and use them to segment the grid into separate regions.\n# Each region is extracted as a subgrid, excluding the divider lines themselves.\n# The output is a list of these subgrids, preserving their original content and relative order.\n\ndef main(input_grid):\n    # Identify the divider color by finding a line that spans the whole width or height\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n    if divider_color is None:\n        for j in range(input_grid.shape[1]):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                divider_color = input_grid[0, j]\n                break\n    assert divider_color is not None, \"No divider color found\"\n\n    # Find all horizontal and vertical lines of the divider color\n    vertical_lines = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n\n    # Add borders to the lists to handle edge cases\n    vertical_lines = [0] + vertical_lines + [input_grid.shape[0]]\n    horizontal_lines = [0] + horizontal_lines + [input_grid.shape[1]]\n\n    # Extract subgrids based on the lines identified\n    subgrids = []\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x_start = vertical_lines[i] + 1\n            x_end = vertical_lines[i + 1]\n            y_start = horizontal_lines[j] + 1\n            y_end = horizontal_lines[j + 1]\n            subgrid = input_grid[x_start:x_end, y_start:y_end]\n            subgrids.append(subgrid)\n\n    return subgrids\n\ndef generate_input():\n    # Define grid dimensions\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Choose a color for the dividers\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly determine the number of vertical and horizontal dividers\n    num_vertical_dividers = np.random.randint(1, 4)\n    num_horizontal_dividers = np.random.randint(1, 4)\n\n    # Generate random positions for dividers ensuring they are not adjacent and have padding\n    vertical_positions = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=2)\n    horizontal_positions = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=2)\n\n    # Draw the vertical and horizontal dividers\n    for pos in vertical_positions:\n        grid[pos, :] = divider_color\n    for pos in horizontal_positions:\n        grid[:, pos] = divider_color\n\n    # Fill each region with a random color\n    for i in range(len(vertical_positions) + 1):\n        for j in range(len(horizontal_positions) + 1):\n            x_start = 0 if i == 0 else vertical_positions[i - 1] + 1\n            x_end = vertical_positions[i] if i < len(vertical_positions) else width\n            y_start = 0 if j == 0 else horizontal_positions[j - 1] + 1\n            y_end = horizontal_positions[j] if j < len(horizontal_positions) else height\n\n            # Choose a random color different from the divider\n            region_color = np.random.choice([color for color in Color.NOT_BLACK if color != divider_color])\n            grid[x_start:x_end, y_start:y_end] = region_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# The input grid may contain horizontal or vertical divider lines of a specific color. These lines divide the grid into distinct regions.\n# The task is to identify these lines and extract each region as a separate subgrid, excluding the divider lines themselves.\n# The output is a list of these subgrids, preserving their original content and relative order.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Find the divider color, which is the color that forms complete horizontal or vertical lines\n    divider_color_candidates = set(input_grid.flatten())\n    divider_color = None\n    for color in divider_color_candidates:\n        if any(np.all(input_grid[:, col] == color) for col in range(input_grid.shape[1])) or \\\n           any(np.all(input_grid[row, :] == color) for row in range(input_grid.shape[0])):\n            divider_color = color\n            break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Identify horizontal and vertical divider lines\n    horizontal_dividers = [row for row in range(input_grid.shape[0]) if np.all(input_grid[row, :] == divider_color)]\n    vertical_dividers = [col for col in range(input_grid.shape[1]) if np.all(input_grid[:, col] == divider_color)]\n\n    # Add borders as dividers to simplify region extraction\n    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[0]]\n    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[1]]\n\n    # Extract regions as subgrids\n    regions = []\n    for i in range(len(horizontal_dividers) - 1):\n        for j in range(len(vertical_dividers) - 1):\n            top = horizontal_dividers[i] + 1\n            bottom = horizontal_dividers[i + 1]\n            left = vertical_dividers[j] + 1\n            right = vertical_dividers[j + 1]\n            if top < bottom and left < right:\n                region = input_grid[top:bottom, left:right]\n                regions.append(region)\n\n    return regions\n\ndef generate_input() -> np.ndarray:\n    # Define grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.ALL_COLORS - {Color.BLACK}), (width, height))\n\n    # Choose a random color for the divider lines\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly decide the number of horizontal and vertical divider lines\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    # Generate positions for divider lines\n    horizontal_positions = randomly_spaced_indices(width, num_horizontal_dividers, border_size=1, padding=1)\n    vertical_positions = randomly_spaced_indices(height, num_vertical_dividers, border_size=1, padding=1)\n\n    # Draw horizontal divider lines\n    for row in horizontal_positions:\n        grid[row, :] = divider_color\n\n    # Draw vertical divider lines\n    for col in vertical_positions:\n        grid[:, col] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# Input is a grid potentially divided into distinct regions by horizontal or vertical lines of a specific color. \n# Identify these divider lines and use them to segment the grid into separate regions. Each region is extracted as a subgrid, \n# excluding the divider lines themselves. Output is a list of these subgrids, preserving their original content and relative order.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Identify the divider color as any line that extends completely horizontally or vertically\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n    \n    assert divider_color is not None, \"No divider color found\"\n\n    # Find the horizontal and vertical divider lines\n    horizontal_dividers = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == divider_color)]\n    vertical_dividers = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == divider_color)]\n\n    # Initialize list to store subgrids\n    subgrids = []\n\n    # Create subgrids by slicing between dividers\n    row_start = 0\n    for row_end in horizontal_dividers + [input_grid.shape[0]]:\n        col_start = 0\n        for col_end in vertical_dividers + [input_grid.shape[1]]:\n            if row_start < row_end and col_start < col_end:\n                subgrid = input_grid[row_start:row_end, col_start:col_end]\n                # Ignore subgrids that are pure dividers\n                if not (np.all(subgrid == divider_color)):\n                    subgrids.append(subgrid)\n            col_start = col_end + 1\n        row_start = row_end + 1\n\n    return subgrids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate the grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n\n    # Randomly select a divider color\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly determine positions for horizontal and vertical dividers\n    num_horizontal_dividers = np.random.randint(1, min(width // 3, 5))\n    num_vertical_dividers = np.random.randint(1, min(height // 3, 5))\n\n    horizontal_divider_positions = randomly_spaced_indices(width, num_horizontal_dividers, border_size=1, padding=1)\n    vertical_divider_positions = randomly_spaced_indices(height, num_vertical_dividers, border_size=1, padding=1)\n\n    # Draw horizontal dividers\n    for row in horizontal_divider_positions:\n        grid[row, :] = divider_color\n\n    # Draw vertical dividers\n    for col in vertical_divider_positions:\n        grid[:, col] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# Input is a grid potentially divided into distinct regions by horizontal or vertical lines of a specific color.\n# Identify these divider lines and use them to segment the grid into separate regions. Each region is extracted as a subgrid, excluding the divider lines themselves.\n# Output is a list of these subgrids, preserving their original content and relative order.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the divider color by finding a line that extends completely in either direction.\n    # 2. Use the divider lines to segment the grid into regions, excluding the lines themselves.\n    # 3. Extract each region as a subgrid and return a list of these subgrids.\n\n    # Find divider color\n    divider_color = None\n    for x in range(input_grid.shape[0]):\n        if np.all(input_grid[x, :] == input_grid[x, 0]):\n            divider_color = input_grid[x, 0]\n            break\n    for y in range(input_grid.shape[1]):\n        if np.all(input_grid[:, y] == input_grid[0, y]) and (divider_color is None or input_grid[0, y] == divider_color):\n            divider_color = input_grid[0, y]\n            break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Find positions of divider lines\n    vertical_lines = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_lines = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n\n    # Add the start and end of the grid to the lines for easier slicing\n    vertical_lines = [0] + vertical_lines + [input_grid.shape[0]]\n    horizontal_lines = [0] + horizontal_lines + [input_grid.shape[1]]\n\n    regions = []\n    # Extract regions as subgrids\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            x1 = vertical_lines[i]\n            x2 = vertical_lines[i+1]\n            y1 = horizontal_lines[j]\n            y2 = horizontal_lines[j+1]\n            region = input_grid[x1+1:x2, y1+1:y2]  # Exclude the lines\n            if region.size > 0:  # Exclude empty regions\n                regions.append(region)\n\n    return regions\n\n\ndef generate_input():\n    # Randomly generate a grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(Color.NOT_BLACK, (width, height))\n\n    # Randomly select a divider color\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Decide how many horizontal and vertical dividers to create\n    num_horizontal_dividers = np.random.randint(1, 3)\n    num_vertical_dividers = np.random.randint(1, 3)\n\n    # Generate divider positions\n    horizontal_positions = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=1)\n    vertical_positions = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=1)\n\n    # Apply the dividers to the grid\n    for x in vertical_positions:\n        grid[x, :] = divider_color\n    for y in horizontal_positions:\n        grid[:, y] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# The input grid is a 2D array where certain rows or columns are entirely filled with a specific color, acting as dividers.\n# These dividers segment the grid into separate regions. The task is to identify these divider lines, \n# segment the grid into distinct subgrids, and return these subgrids as a list, excluding the dividers themselves.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify horizontal and vertical divider lines\n    # 2. Use these lines to segment the grid into separate regions\n    # 3. Extract and return these regions as subgrids, excluding the dividers\n\n    width, height = input_grid.shape\n    # Assume the divider color is the most frequent color in the grid\n    unique, counts = np.unique(input_grid, return_counts=True)\n    divider_color = unique[np.argmax(counts)]\n\n    # Identify horizontal and vertical divider lines\n    horizontal_dividers = [y for y in range(height) if np.all(input_grid[:, y] == divider_color)]\n    vertical_dividers = [x for x in range(width) if np.all(input_grid[x, :] == divider_color)]\n\n    # Add grid boundaries as implied dividers\n    horizontal_dividers = [0] + horizontal_dividers + [height]\n    vertical_dividers = [0] + vertical_dividers + [width]\n\n    # Extract subgrids\n    subgrids = []\n    for i in range(len(vertical_dividers) - 1):\n        for j in range(len(horizontal_dividers) - 1):\n            x1, x2 = vertical_dividers[i] + 1, vertical_dividers[i + 1]\n            y1, y2 = horizontal_dividers[j] + 1, horizontal_dividers[j + 1]\n            subgrid = input_grid[x1:x2, y1:y2]\n            subgrids.append(subgrid)\n\n    return subgrids\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(Color.ALL_COLORS, (width, height), replace=True)\n\n    # Choose a random color for the divider\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly determine the number of dividers\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    # Generate divider lines\n    horizontal_divider_indices = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=1)\n    vertical_divider_indices = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=1)\n\n    # Apply divider lines to the grid\n    for y in horizontal_divider_indices:\n        grid[:, y] = divider_color\n\n    for x in vertical_divider_indices:\n        grid[x, :] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# Input is a grid potentially divided into distinct regions by horizontal or vertical lines of a specific color.\n# Identify these divider lines and use them to segment the grid into separate regions.\n# Each region is extracted as a subgrid, excluding the divider lines themselves.\n# Output is a list of these subgrids, preserving their original content and relative order.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Determine the color of the divider lines by finding lines that extend fully across rows or columns\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n    if divider_color is None:\n        for j in range(input_grid.shape[1]):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                divider_color = input_grid[0, j]\n                break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Identify horizontal and vertical divider lines\n    vertical_dividers = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n    horizontal_dividers = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n\n    # Add grid boundaries to the divider lists\n    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[0]]\n    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[1]]\n\n    # Extract each region as a subgrid\n    subgrids = []\n    for i in range(len(vertical_dividers) - 1):\n        for j in range(len(horizontal_dividers) - 1):\n            x1, x2 = vertical_dividers[i] + 1, vertical_dividers[i + 1]\n            y1, y2 = horizontal_dividers[j] + 1, horizontal_dividers[j + 1]\n            subgrid = input_grid[x1:x2, y1:y2]\n            if subgrid.size > 0:\n                subgrids.append(subgrid)\n\n    return subgrids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate grid dimensions\n    width, height = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height), replace=True)\n\n    # Select a random color for divider lines\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly choose number of dividers and their positions\n    num_vertical_dividers = np.random.randint(1, 4)\n    num_horizontal_dividers = np.random.randint(1, 4)\n    vertical_positions = randomly_spaced_indices(max_len=width, n_indices=num_vertical_dividers, border_size=1, padding=2)\n    horizontal_positions = randomly_spaced_indices(max_len=height, n_indices=num_horizontal_dividers, border_size=1, padding=2)\n\n    # Draw the divider lines on the grid\n    for x in vertical_positions:\n        grid[x, :] = divider_color\n    for y in horizontal_positions:\n        grid[:, y] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider lines, region extraction, array slicing\n\n# description:\n# The input grid is potentially divided into distinct regions by horizontal or vertical lines of a specific color.\n# Identify these divider lines and use them to segment the grid into separate regions.\n# Each region is extracted as a subgrid, excluding the divider lines themselves. \n# Output is a list of these subgrids, preserving their original content and relative order.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Determine the divider color, assuming it's the color of any complete horizontal or vertical line\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n    \n    assert divider_color is not None, \"No divider color found\"\n    \n    # Identify horizontal and vertical divider lines\n    horizontal_dividers = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == divider_color)]\n    vertical_dividers = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == divider_color)]\n    \n    # Add boundaries to the list of dividers\n    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[0]]\n    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[1]]\n\n    subgrids = []\n    \n    # Extract subgrids defined by the divider lines\n    for i in range(len(horizontal_dividers) - 1):\n        for j in range(len(vertical_dividers) - 1):\n            x1, x2 = horizontal_dividers[i] + 1, horizontal_dividers[i + 1]\n            y1, y2 = vertical_dividers[j] + 1, vertical_dividers[j + 1]\n            if x1 < x2 and y1 < y2:\n                subgrid = input_grid[x1:x2, y1:y2]\n                subgrids.append(subgrid)\n    \n    return subgrids\n\ndef generate_input() -> np.ndarray:\n    # Define grid dimensions\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n    \n    # Randomly choose a color to be the divider\n    divider_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Determine number of horizontal and vertical dividers\n    num_h_dividers = np.random.randint(1, 4)\n    num_v_dividers = np.random.randint(1, 4)\n    \n    # Randomly place divider lines, ensuring they do not overlap\n    h_indices = randomly_spaced_indices(width, num_h_dividers, border_size=1, padding=1)\n    v_indices = randomly_spaced_indices(height, num_v_dividers, border_size=1, padding=1)\n    \n    # Draw the divider lines on the grid\n    for h in h_indices:\n        grid[h, :] = divider_color\n    for v in v_indices:\n        grid[:, v] = divider_color\n    \n    return grid"], "seeds": ["780d0b14.py", "06df4c85.py", "941d9a10.py", "00d62c1b.py", "Concepts: \ndivider lines, region extraction, array slicing\n\nDescription: \nInput is a grid potentially divided into distinct regions by horizontal or vertical lines of a specific color. Identify these divider lines and use them to segment the grid into separate regions. Each region is extracted as a subgrid, excluding the divider lines themselves. Output is a list of these subgrids, preserving their original content and relative order."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# In the input grid, you will see two distinct objects of different colors on a black background. One object is designated as the reference, and the other as the target.\n# The task is to translate the target object to touch a specified side (up, down, left, right) of the reference object. Align the nearest edge of the target to the contact edge of the reference without overlap.\n# Merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the two objects in the grid\n    # 2. Determine which is the reference and which is the target (you can assume the reference is the first object found)\n    # 3. Translate the target to touch the reference on the specified side\n    # 4. Merge the target into the reference without overlapping existing pixels\n\n    output_grid = np.copy(input_grid)\n\n    # Detect the objects in the input grid\n    objects = find_connected_components(grid=input_grid, connectivity=4, monochromatic=True)\n    assert len(objects) == 2, \"There should be exactly two objects.\"\n\n    # Assume the first object is the reference and the second is the target\n    reference_object, target_object = objects\n\n    # Define a direction for the target to align to the reference\n    direction = random.choice(['up', 'down', 'left', 'right'])\n\n    # Get the bounding box for both objects\n    ref_bbox = crop(reference_object)\n    tgt_bbox = crop(target_object)\n\n    # Calculate the translation needed to touch the specified side\n    if direction == 'up':\n        dx, dy = 0, -(tgt_bbox.shape[0])\n    elif direction == 'down':\n        dx, dy = 0, ref_bbox.shape[0]\n    elif direction == 'left':\n        dx, dy = -(tgt_bbox.shape[1]), 0\n    elif direction == 'right':\n        dx, dy = ref_bbox.shape[1], 0\n\n    # Translate the target object\n    translated_target = translate(target_object, dx, dy, background=Color.BLACK)\n\n    # Ensure the target aligns correctly without overlapping the reference\n    while not contact(object1=reference_object, object2=translated_target, connectivity=4):\n        if direction in ['up', 'down']:\n            dy += 1 if direction == 'up' else -1\n        else:\n            dx += 1 if direction == 'left' else -1\n        translated_target = translate(target_object, dx, dy, background=Color.BLACK)\n\n    # Merge target into reference by painting target pixels into the grid\n    blit_object(output_grid, translated_target, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    n, m = 15, 15\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Generate a reference object\n    ref_color = random.choice(list(Color.NOT_BLACK))\n    ref_sprite = random_sprite(n=3, m=3, color_palette=[ref_color], density=0.5)\n    x, y = random_free_location_for_sprite(grid, ref_sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, ref_sprite, x, y, background=Color.BLACK)\n\n    # Generate a target object with a different color\n    tgt_color = random.choice([c for c in Color.NOT_BLACK if c != ref_color])\n    tgt_sprite = random_sprite(n=2, m=2, color_palette=[tgt_color], density=0.5)\n    x, y = random_free_location_for_sprite(grid, tgt_sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, tgt_sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# In the input grid, you will see a reference object and a target object, each with distinct colors. The task is to translate the target object so that it touches the reference object on a specified side (up, down, left, or right) without overlap.\n# Then, align the nearest edge of the target to the contact edge of the reference, and merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels.\n# The output grid shows the target object aligned and merged with the reference object on the specified side.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the reference and target objects.\n    # 2. Determine the contact side for alignment.\n    # 3. Translate the target object to touch the reference object on the specified side.\n    # 4. Merge the target into the reference.\n    \n    output_grid = np.copy(input_grid)\n\n    # Detect objects in the input grid (assuming two objects with distinct colors)\n    objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=4)\n\n    # Assume the first object is the reference and the second is the target\n    reference_object, target_object = objects[0], objects[1]\n\n    # For simplification, let's assume the contact side is 'right' (this could be parameterized)\n    contact_side = 'right'\n\n    # Get bounding boxes for the reference and target\n    ref_bbox = crop(reference_object)\n    tgt_bbox = crop(target_object)\n\n    # Determine translation vector based on the contact side\n    if contact_side == 'right':\n        translate_x = ref_bbox.shape[1]\n        translate_y = 0\n\n    elif contact_side == 'left':\n        translate_x = -tgt_bbox.shape[1]\n        translate_y = 0\n\n    elif contact_side == 'up':\n        translate_x = 0\n        translate_y = -tgt_bbox.shape[0]\n\n    elif contact_side == 'down':\n        translate_x = 0\n        translate_y = ref_bbox.shape[0]\n\n    # Translate the target object\n    translated_target = translate(target_object, translate_x, translate_y)\n\n    # Ensure there is no collision\n    assert not collision(object1=reference_object, object2=translated_target)\n\n    # Merge the target into the reference\n    blit_object(output_grid, translated_target, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a 10x10 grid with two objects\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select distinct colors for reference and target objects\n    ref_color, tgt_color = np.random.choice(Color.NOT_BLACK, 2, replace=False)\n\n    # Create random sprites for reference and target\n    ref_sprite = random_sprite(n=[2, 3], m=[2, 3], color_palette=[ref_color], density=0.7)\n    tgt_sprite = random_sprite(n=[2, 3], m=[2, 3], color_palette=[tgt_color], density=0.7)\n\n    # Place the reference object in the grid\n    ref_x, ref_y = random_free_location_for_sprite(grid, ref_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, ref_sprite, ref_x, ref_y)\n\n    # Place the target object in the grid\n    tgt_x, tgt_y = random_free_location_for_sprite(grid, tgt_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, tgt_sprite, tgt_x, tgt_y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# In the input, a grid contains two distinct objects: a reference object and a target object.\n# A direction is specified (up, down, left, or right) indicating where the target should be translated.\n# The goal is to translate the target object until it touches the reference object on the specified side.\n# After aligning, merge the target object into the reference object by painting target pixels into the grid,\n# preserving existing reference pixels. The output grid shows the target object aligned and merged with the reference object.\n\ndef main(input_grid, direction):\n    # Find the connected components in the grid, assuming black is the background\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Assume the first object is the reference and the second is the target\n    reference = components[0]\n    target = components[1]\n\n    # Create a copy of the input grid to prepare the output grid\n    output_grid = np.copy(input_grid)\n\n    # Determine the translation vector based on the specified direction\n    translation_vector = {\n        \"up\": (0, -1),\n        \"down\": (0, 1),\n        \"left\": (-1, 0),\n        \"right\": (1, 0),\n    }[direction]\n\n    # Translate the target until it touches the reference on the specified side\n    while not contact(object1=reference, object2=target):\n        target = translate(target, *translation_vector, background=Color.BLACK)\n\n    # Merge the target object into the reference object, preserving existing reference pixels\n    blit_object(output_grid, target, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 10x10 black grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate a random reference object\n    ref_obj = random_sprite(n=3, m=3, color_palette=[random.choice(Color.NOT_BLACK)], connectivity=4)\n\n    # Generate a random target object\n    target_obj = random_sprite(n=3, m=3, color_palette=[random.choice(Color.NOT_BLACK)], connectivity=4)\n\n    # Place the reference object randomly in the grid\n    x_ref, y_ref = random_free_location_for_sprite(grid, ref_obj, background=Color.BLACK)\n    blit_sprite(grid, ref_obj, x=x_ref, y=y_ref, background=Color.BLACK)\n\n    # Place the target object randomly in the grid\n    x_target, y_target = random_free_location_for_sprite(grid, target_obj, background=Color.BLACK)\n    blit_sprite(grid, target_obj, x=x_target, y=y_target, background=Color.BLACK)\n\n    # Randomly choose a direction for the target to move towards the reference\n    direction = random.choice([\"up\", \"down\", \"left\", \"right\"])\n\n    return grid, direction", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# In the input grid, you will see a reference object and a target object, along with a direction ('up', 'down', 'left', 'right').\n# The task is to translate the target object so it touches the reference object on the specified side without overlapping. The nearest edge of the target should align with the contact edge of the reference.\n# The output grid shows the target object aligned and merged with the reference object on the specified side.\n\ndef main(input_grid):\n    # Detect the objects (reference and target) and the direction\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    assert len(objects) == 2  # Ensure there are exactly two objects\n\n    # Determine the reference and target objects\n    ref_object, target_object = objects\n\n    # Identify the direction from the input (e.g., as a single pixel in the grid specifying direction)\n    direction_pixel = detect_objects(grid=input_grid, colors=[Color.GREY], monochromatic=True, connectivity=8, allowed_dimensions=[(1,1)])\n    assert len(direction_pixel) == 1\n    direction_pixel = direction_pixel[0]\n\n    # Map direction pixel to actual direction\n    direction_map = {\n        (0, -1): 'up',\n        (0, 1): 'down',\n        (-1, 0): 'left',\n        (1, 0): 'right'\n    }\n    direction = direction_map.get((direction_pixel[0][0], direction_pixel[0][1]))\n\n    # Translate target object to align and contact reference object\n    if direction == 'up':\n        # Move the target object up to touch the top of the reference\n        translation_vector = (0, -1)\n    elif direction == 'down':\n        # Move the target object down to touch the bottom of the reference\n        translation_vector = (0, 1)\n    elif direction == 'left':\n        # Move the target object left to touch the left of the reference\n        translation_vector = (-1, 0)\n    elif direction == 'right':\n        # Move the target object right to touch the right of the reference\n        translation_vector = (1, 0)\n\n    # Align the target object to the reference object\n    while not contact(object1=ref_object, object2=target_object, x1=0, y1=0, x2=translation_vector[0], y2=translation_vector[1]):\n        target_object = translate(target_object, translation_vector[0], translation_vector[1])\n        \n    # Merge target object into reference object\n    output_grid = np.copy(input_grid)\n    blit_object(output_grid, target_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a reference object and a target object, and randomly decide a direction\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random reference object\n    ref_sprite = random_sprite(n=[2, 3], m=[2, 3], color_palette=[Color.BLUE], connectivity=8)\n    x, y = random_free_location_for_sprite(grid, ref_sprite, padding=1, border_size=1)\n    blit_sprite(grid, ref_sprite, x, y)\n    \n    # Create a random target object\n    target_sprite = random_sprite(n=[2, 3], m=[2, 3], color_palette=[Color.RED], connectivity=8)\n    x, y = random_free_location_for_sprite(grid, target_sprite, padding=1, border_size=1)\n    blit_sprite(grid, target_sprite, x, y)\n\n    # Randomly choose a direction\n    directions = ['up', 'down', 'left', 'right']\n    direction = random.choice(directions)\n\n    # Place a direction indicator on the grid (using grey color)\n    if direction == 'up':\n        grid[0, 0] = Color.GREY\n    elif direction == 'down':\n        grid[0, 1] = Color.GREY\n    elif direction == 'left':\n        grid[1, 0] = Color.GREY\n    elif direction == 'right':\n        grid[1, 1] = Color.GREY\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# Given a grid with a reference object and a target object, translate the target so it touches the reference on a specified side (up/down/left/right).\n# Align the nearest edge of the target to the contact edge of the reference without overlap. \n# Merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels.\n# The output grid shows the target object aligned and merged with the reference object on the specified side.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the reference object and target object.\n    # 2. Determine the side of the reference where the target should be aligned.\n    # 3. Translate the target so it touches the reference on the specified side.\n    # 4. Align the nearest edge of the target to the contact edge of the reference.\n    # 5. Merge objects by painting target pixels onto the reference without overlap.\n\n    output_grid = np.copy(input_grid)\n\n    # Detect objects\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    assert len(objects) == 2\n\n    # Assume the first object detected is the reference and the second is the target\n    reference, target = objects\n\n    # Randomly choose a side for alignment: up, down, left, or right\n    sides = ['up', 'down', 'left', 'right']\n    side = np.random.choice(sides)\n\n    # Calculate translation based on the chosen side\n    if side == 'up':\n        # Align target below the top edge of reference\n        x_translation = 0\n        y_translation = -(target.shape[0] - 1) - 1\n    elif side == 'down':\n        # Align target above the bottom edge of reference\n        x_translation = 0\n        y_translation = reference.shape[0] - 1\n    elif side == 'left':\n        # Align target to the right of the left edge of reference\n        x_translation = -(target.shape[1] - 1) - 1\n        y_translation = 0\n    elif side == 'right':\n        # Align target to the left of the right edge of reference\n        x_translation = reference.shape[1] - 1\n        y_translation = 0\n\n    # Translate the target to align it properly\n    aligned_target = translate(target, x_translation, y_translation, background=Color.BLACK)\n\n    # Merge the target into the reference\n    blit_object(output_grid, aligned_target, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 10x10 grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a reference object (random shape and color)\n    ref_height, ref_width = np.random.randint(2, 4), np.random.randint(2, 4)\n    ref_color = random.choice(list(Color.NOT_BLACK))\n    reference = np.full((ref_height, ref_width), ref_color)\n    \n    # Place the reference object randomly on the grid\n    ref_x, ref_y = random_free_location_for_sprite(grid, reference, padding=1, border_size=1)\n    blit_sprite(grid, reference, ref_x, ref_y)\n\n    # Generate a target object (random shape and color)\n    tgt_height, tgt_width = np.random.randint(2, 4), np.random.randint(2, 4)\n    tgt_color = random.choice([c for c in Color.NOT_BLACK if c != ref_color])\n    target = np.full((tgt_height, tgt_width), tgt_color)\n\n    # Place the target object randomly on the grid\n    tgt_x, tgt_y = random_free_location_for_sprite(grid, target, padding=1, border_size=1)\n    blit_sprite(grid, target, tgt_x, tgt_y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# Given a grid with a reference object and a target object, translate the target so it touches the reference on a specified side (up/down/left/right).\n# Align the nearest edge of the target to the contact edge of the reference without overlap. \n# Merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels.\n# The output grid shows the target object aligned and merged with the reference object on the specified side.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the reference and target objects\n    # 2. Determine the direction to align the target to the reference\n    # 3. Translate the target to the edge of the reference on the specified side\n    # 4. Merge the target into the reference\n\n    # Detect all objects in the grid\n    objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, connectivity=4, monochromatic=False)\n    \n    # Assume the first object is the reference and the second is the target\n    reference_object = objects[0]\n    target_object = objects[1]\n    \n    # Direction to align the target to the reference (can be 'up', 'down', 'left', 'right')\n    direction = 'right'  # For example, this should be specified as part of the input\n\n    # Translate the target object to be adjacent to the reference object based on the direction\n    if direction == 'right':\n        # Align target to the right of the reference\n        ref_bounding_box = np.argwhere(reference_object)\n        target_bounding_box = np.argwhere(target_object)\n        \n        ref_max_x = ref_bounding_box[:, 1].max()\n        target_min_x = target_bounding_box[:, 1].min()\n        \n        # Calculate translation needed\n        translation_x = ref_max_x - target_min_x + 1  # +1 to ensure touching\n\n        # Move target to the new position\n        translated_target = translate(target_object, x=translation_x, y=0)\n    \n    elif direction == 'left':\n        # Align target to the left of the reference\n        ref_bounding_box = np.argwhere(reference_object)\n        target_bounding_box = np.argwhere(target_object)\n        \n        ref_min_x = ref_bounding_box[:, 1].min()\n        target_max_x = target_bounding_box[:, 1].max()\n        \n        # Calculate translation needed\n        translation_x = ref_min_x - target_max_x - 1  # -1 to ensure touching\n\n        # Move target to the new position\n        translated_target = translate(target_object, x=translation_x, y=0)\n    \n    elif direction == 'down':\n        # Align target below the reference\n        ref_bounding_box = np.argwhere(reference_object)\n        target_bounding_box = np.argwhere(target_object)\n        \n        ref_max_y = ref_bounding_box[:, 0].max()\n        target_min_y = target_bounding_box[:, 0].min()\n        \n        # Calculate translation needed\n        translation_y = ref_max_y - target_min_y + 1  # +1 to ensure touching\n\n        # Move target to the new position\n        translated_target = translate(target_object, x=0, y=translation_y)\n    \n    elif direction == 'up':\n        # Align target above the reference\n        ref_bounding_box = np.argwhere(reference_object)\n        target_bounding_box = np.argwhere(target_object)\n        \n        ref_min_y = ref_bounding_box[:, 0].min()\n        target_max_y = target_bounding_box[:, 0].max()\n        \n        # Calculate translation needed\n        translation_y = ref_min_y - target_max_y - 1  # -1 to ensure touching\n\n        # Move target to the new position\n        translated_target = translate(target_object, x=0, y=translation_y)\n    \n    # Create an output grid and merge the translated target with the reference\n    output_grid = np.copy(input_grid)\n    blit_object(output_grid, reference_object, background=Color.BLACK)\n    blit_object(output_grid, translated_target, background=Color.BLACK)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a reference object and a target object\n    n = m = 15\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Generate a reference object\n    ref_width, ref_height = np.random.randint(2, 5, size=2)\n    reference_object = random_sprite(n=ref_height, m=ref_width, color_palette=[Color.RED], connectivity=4)\n    \n    # Find a location for the reference object\n    x, y = random_free_location_for_sprite(grid, reference_object, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, reference_object, x, y, background=Color.BLACK)\n    \n    # Generate a target object\n    target_width, target_height = np.random.randint(2, 5, size=2)\n    target_object = random_sprite(n=target_height, m=target_width, color_palette=[Color.BLUE], connectivity=4)\n    \n    # Find a location for the target object\n    x, y = random_free_location_for_sprite(grid, target_object, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, target_object, x, y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# In the input grid, you will see two objects: a reference object and a target object, each represented by a different color.\n# Additionally, there will be a specified side (up/down/left/right) where the target object should be aligned to touch the reference object.\n# The task is to translate the target object such that its nearest edge aligns with the specified edge of the reference object without overlapping.\n# After proper alignment, merge the target object into the reference by painting the target pixels onto the grid, preserving existing reference pixels.\n\ndef main(input_grid, side):\n    # Plan:\n    # 1. Detect the reference and target objects using their colors.\n    # 2. Depending on the specified side (up/down/left/right), determine the translation needed to align the target with the reference.\n    # 3. Translate the target object.\n    # 4. Merge the target object into the reference object by painting the target pixels onto the grid.\n\n    output_grid = np.copy(input_grid)\n\n    # Detect the reference and target objects\n    reference_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    target_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n    \n    assert len(reference_objects) == 1\n    assert len(target_objects) == 1\n\n    reference_object = reference_objects[0]\n    target_object = target_objects[0]\n\n    # Crop both objects to get their bounding boxes\n    cropped_reference = crop(reference_object)\n    cropped_target = crop(target_object)\n\n    # Determine the translation needed\n    if side == 'up':\n        x_translation = 0\n        y_translation = np.min(np.where(reference_object)[0]) - np.max(np.where(target_object)[0]) - 1\n    elif side == 'down':\n        x_translation = 0\n        y_translation = np.max(np.where(reference_object)[0]) - np.min(np.where(target_object)[0]) + 1\n    elif side == 'left':\n        x_translation = np.min(np.where(reference_object)[1]) - np.max(np.where(target_object)[1]) - 1\n        y_translation = 0\n    elif side == 'right':\n        x_translation = np.max(np.where(reference_object)[1]) - np.min(np.where(target_object)[1]) + 1\n        y_translation = 0\n    else:\n        raise ValueError(\"Invalid side specified. Must be 'up', 'down', 'left', or 'right'.\")\n\n    # Translate the target object\n    translated_target = translate(target_object, x_translation, y_translation, background=Color.BLACK)\n\n    # Merge target into reference by painting target pixels into the grid\n    blit_object(output_grid, translated_target, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid with a reference object and a target object\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Create a reference object (e.g., a blue square)\n    reference_sprite = random_sprite(n=3, m=3, color_palette=[Color.BLUE], density=0.7)\n    x_ref, y_ref = random_free_location_for_sprite(grid, reference_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, reference_sprite, x_ref, y_ref, background=Color.BLACK)\n\n    # Create a target object (e.g., a red square)\n    target_sprite = random_sprite(n=2, m=2, color_palette=[Color.RED], density=0.7)\n    x_tgt, y_tgt = random_free_location_for_sprite(grid, target_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, target_sprite, x_tgt, y_tgt, background=Color.BLACK)\n\n    # Randomly select a side for the alignment\n    side = random.choice(['up', 'down', 'left', 'right'])\n    \n    return grid, side", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, merging, connected components\n\n# description:\n# Given a grid with a reference object and a target object, translate the target so it touches the reference on a specified side (up/down/left/right).\n# Align the nearest edge of the target to the contact edge of the reference without overlap. Merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels.\n# The output grid shows the target object aligned and merged with the reference object on the specified side.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the reference and target objects.\n    # 2. Determine the side where the target should align with the reference.\n    # 3. Translate the target to align with the reference on the specified side.\n    # 4. Merge the target into the reference by painting its pixels into the grid.\n\n    # Detect objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n\n    # Assume the reference object is the largest one, and the target is the second largest\n    reference_object = max(objects, key=lambda o: np.count_nonzero(o))\n    objects.remove(reference_object)\n    target_object = max(objects, key=lambda o: np.count_nonzero(o))\n\n    # Determine the side for alignment (assume input provides this information)\n    # For example, we can say the target should align to the 'right' of the reference\n    alignment_side = 'right'\n\n    # Get the bounding box of the reference object\n    ref_x_min, ref_y_min = np.min(np.argwhere(reference_object != Color.BLACK), axis=0)\n    ref_x_max, ref_y_max = np.max(np.argwhere(reference_object != Color.BLACK), axis=0)\n    \n    # Get the bounding box of the target object\n    tgt_x_min, tgt_y_min = np.min(np.argwhere(target_object != Color.BLACK), axis=0)\n    tgt_x_max, tgt_y_max = np.max(np.argwhere(target_object != Color.BLACK), axis=0)\n\n    # Calculate translation based on alignment side\n    if alignment_side == 'right':\n        translate_x = ref_x_max - tgt_x_min + 1\n        translate_y = ref_y_min - tgt_y_min\n    elif alignment_side == 'left':\n        translate_x = ref_x_min - tgt_x_max - 1\n        translate_y = ref_y_min - tgt_y_min\n    elif alignment_side == 'up':\n        translate_x = ref_x_min - tgt_x_min\n        translate_y = ref_y_min - tgt_y_max - 1\n    elif alignment_side == 'down':\n        translate_x = ref_x_min - tgt_x_min\n        translate_y = ref_y_max - tgt_y_min + 1\n\n    # Translate the target object\n    translated_target = translate(target_object, translate_x, translate_y, background=Color.BLACK)\n\n    # Create the output grid by merging the reference object with the translated target object\n    output_grid = np.copy(input_grid)\n    blit_object(output_grid, translated_target, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with reference and target objects\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define reference and target colors\n    ref_color = random.choice(Color.NOT_BLACK)\n    tgt_color = random.choice([c for c in Color.NOT_BLACK if c != ref_color])\n\n    # Generate reference object\n    ref_sprite = random_sprite(n=[2, 3], m=[2, 3], color_palette=[ref_color], density=0.5)\n    x, y = random_free_location_for_sprite(grid, ref_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, ref_sprite, x, y, background=Color.BLACK)\n\n    # Generate target object\n    tgt_sprite = random_sprite(n=[2, 3], m=[2, 3], color_palette=[tgt_color], density=0.5)\n    x, y = random_free_location_for_sprite(grid, tgt_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, tgt_sprite, x, y, background=Color.BLACK)\n\n    return grid"], "seeds": ["1f642eb9.py", "48d8fb45.py", "137eaa0f.py", "6d58a25d.py", "Concepts: \ntranslation, alignment, merging, connected components\n\nDescription: \nGiven a grid with a reference object and a target object, translate the target so it touches the reference on a specified side (up/down/left/right). Align the nearest edge of the target to the contact edge of the reference without overlap. Merge the target into the reference by painting target pixels into the grid, preserving existing reference pixels. The output grid shows the target object aligned and merged with the reference object on the specified side."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# Input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation.\n# Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W).\n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the pointer object in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    assert len(objects) == 1  # Ensure there is only one object\n    pointer = objects[0]\n\n    # Compute the centroid of the pointer\n    pointer_pixels = np.argwhere(pointer != Color.BLACK)\n    centroid = np.mean(pointer_pixels, axis=0)\n\n    # Determine the tip of the pointer (farthest from the centroid)\n    distances = np.linalg.norm(pointer_pixels - centroid, axis=1)\n    tip_index = np.argmax(distances)\n    tip_location = pointer_pixels[tip_index]\n\n    # Compute the vector from centroid to the tip\n    vector = tip_location - centroid\n\n    # Quantize the vector to one of the cardinal directions\n    if abs(vector[0]) > abs(vector[1]):\n        direction = 'E' if vector[0] > 0 else 'W'\n    else:\n        direction = 'S' if vector[1] > 0 else 'N'\n\n    # Return the direction\n    return direction\n\ndef generate_input():\n    # Create a grid with random dimensions\n    width, height = np.random.randint(5, 15, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Choose a random color for the pointer\n    pointer_color = np.random.choice(Color.NOT_BLACK)\n\n    # Generate a pointer-shaped sprite\n    pointer_length = np.random.randint(3, min(width, height) // 2)\n    pointer_sprite = np.full((pointer_length, pointer_length), pointer_color)\n    tip_index = np.random.choice([(0, pointer_length - 1), (pointer_length - 1, 0), \n                                  (pointer_length - 1, pointer_length - 1), (0, 0)])\n    pointer_sprite[tip_index] = Color.BLACK\n\n    # Place the pointer in a random location on the grid\n    x, y = random_free_location_for_sprite(input_grid, pointer_sprite, padding=1)\n    blit_sprite(input_grid, pointer_sprite, x, y)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# Input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation.\n# Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W).\n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Define cardinal directions\n    directions = {\n        (0, -1): 'N',  # North\n        (0, 1): 'S',   # South\n        (-1, 0): 'W',  # West\n        (1, 0): 'E'    # East\n    }\n\n    # Find the pointer object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    assert len(objects) == 1  # Ensure there's exactly one object\n    pointer = objects[0]\n\n    # Get the bounding box of the pointer\n    x, y, w, h = bounding_box(pointer)\n\n    # Crop to get the pointer sprite\n    pointer_sprite = crop(pointer)\n\n    # Calculate the centroid of the pointer\n    centroid = np.mean(np.argwhere(pointer_sprite != Color.BLACK), axis=0)\n\n    # Identify the tip of the pointer (assumed to be the most distant pixel from the centroid)\n    tip_coordinates = None\n    max_distance = 0\n    for tip_candidate in np.argwhere(pointer_sprite != Color.BLACK):\n        distance = np.linalg.norm(tip_candidate - centroid)\n        if distance > max_distance:\n            max_distance = distance\n            tip_coordinates = tip_candidate\n\n    # Calculate the vector from centroid to tip\n    vector = np.sign(tip_coordinates - centroid).astype(int)\n\n    # Quantize the vector to the nearest cardinal direction\n    quantized_direction = min(directions.keys(), key=lambda dir: np.linalg.norm(np.array(dir) - vector))\n\n    # Output the corresponding direction label\n    direction_label = directions[quantized_direction]\n    return direction_label\n\ndef generate_input():\n    # Create a grid\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Choose a random color for the pointer\n    pointer_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a pointer sprite\n    pointer_length = np.random.randint(3, 6)\n    pointer_width = np.random.randint(1, 3)\n    pointer_sprite = np.full((pointer_length, pointer_width), pointer_color)\n\n    # Make one end of the pointer distinct (the tip)\n    tip_index = (np.random.randint(pointer_length), np.random.randint(pointer_width))\n    pointer_sprite[tip_index] = pointer_color\n\n    # Randomly rotate or flip the pointer to vary its orientation\n    pointer_sprite = np.rot90(pointer_sprite, k=np.random.randint(4))\n    if np.random.choice([True, False]):\n        pointer_sprite = np.flipud(pointer_sprite)\n    if np.random.choice([True, False]):\n        pointer_sprite = np.fliplr(pointer_sprite)\n\n    # Place the pointer in a random location on the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, pointer_sprite, padding=1)\n        blit_sprite(grid, pointer_sprite, x, y)\n    except ValueError:\n        # If no location was found, retry (edge case handling)\n        return generate_input()\n\n    return grid", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# The input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation.\n# Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W).\n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Determine the background color\n    background_color = np.bincount(input_grid.flatten()).argmax()\n\n    # Find the object, which is assumed to be the only non-background component\n    objects = find_connected_components(input_grid, background=background_color, connectivity=8, monochromatic=True)\n    assert len(objects) == 1\n    pointer = objects[0]\n\n    # Find the bounding box and crop the object\n    x, y, w, h = bounding_box(pointer, background=background_color)\n    sprite = crop(pointer, background=background_color)\n\n    # Find the centroid of the object\n    points = np.argwhere(sprite != background_color)\n    centroid = np.mean(points, axis=0)\n\n    # Assume the tip is the farthest point from the centroid\n    distances = np.linalg.norm(points - centroid, axis=1)\n    tip_index = np.argmax(distances)\n    tip = points[tip_index]\n\n    # Compute the vector from centroid to tip\n    vector = tip - centroid\n\n    # Quantize the vector to one of the cardinal directions\n    direction = np.zeros(2, dtype=int)\n    if abs(vector[0]) > abs(vector[1]):\n        direction[0] = np.sign(vector[0])\n    else:\n        direction[1] = np.sign(vector[1])\n\n    # Map the direction to a label\n    direction_map = {(1, 0): \"E\", (-1, 0): \"W\", (0, 1): \"S\", (0, -1): \"N\"}\n    output_label = direction_map[tuple(direction)]\n\n    return output_label\n\ndef generate_input():\n    # Create a grid of a random size\n    size = np.random.randint(5, 15)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Generate a random pointer-shaped object\n    pointer_color = np.random.choice(Color.NOT_BLACK)\n    pointer_size = np.random.randint(3, size)\n    pointer = random_sprite(pointer_size, pointer_size, density=0.5, color_palette=[pointer_color])\n\n    # Place the pointer in a random location\n    x, y = random_free_location_for_sprite(grid, pointer, background=Color.BLACK)\n    blit_sprite(grid, pointer, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# In the input, you will see a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation. \n# Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W). \n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Find the background color, assuming it is the most common color\n    background_color = np.bincount(input_grid.flatten()).argmax()\n\n    # Find the single pointer-shaped object in the grid\n    objects = find_connected_components(input_grid, background=background_color, connectivity=8, monochromatic=True)\n    assert len(objects) == 1\n    pointer_object = objects[0]\n\n    # Crop the object to extract its sprite\n    pointer_sprite = crop(pointer_object, background=background_color)\n\n    # Calculate the centroid of the pointer object\n    non_background_pixels = np.argwhere(pointer_sprite != background_color)\n    centroid = non_background_pixels.mean(axis=0)\n\n    # Assume the tip of the pointer is the farthest point from the centroid\n    distances = np.linalg.norm(non_background_pixels - centroid, axis=1)\n    tip_index = np.argmax(distances)\n    tip = non_background_pixels[tip_index]\n\n    # Compute the vector from the centroid to the tip\n    vector = tip - centroid\n\n    # Quantize the vector to one of the cardinal directions\n    cardinal_directions = {\n        (0, -1): \"N\",  # North\n        (0, 1): \"S\",   # South\n        (-1, 0): \"W\",  # West\n        (1, 0): \"E\"    # East\n    }\n\n    # Determine which cardinal direction is closest\n    direction = max(cardinal_directions.keys(), key=lambda d: np.dot(d, vector))\n    direction_label = cardinal_directions[direction]\n\n    # Return the direction as a label\n    return direction_label\n\ndef generate_input():\n    # Create a grid with a random size\n    grid_size = np.random.randint(10, 20)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Choose a random color for the pointer\n    pointer_color = np.random.choice(Color.NOT_BLACK)\n\n    # Generate a random pointer-shaped object\n    pointer_shape = random_sprite(n=[3, 4, 5], m=[3, 4, 5], density=0.8, color_palette=[pointer_color], connectivity=8)\n\n    # Place the pointer randomly on the grid\n    x, y = random_free_location_for_sprite(grid, pointer_shape, padding=1)\n    blit_sprite(grid, pointer_shape, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# The input is a grid containing a single pointer-shaped object on a background. \n# The goal is to normalize the pointer by rotating and/or flipping it to match a canonical orientation. \n# Then, determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W). \n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Find the object in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    # Assuming there is exactly one pointer object\n    pointer = objects[0]\n\n    # Determine the bounding box and crop the object\n    x, y, w, h = bounding_box(pointer)\n    cropped_pointer = crop(pointer)\n\n    # Compute the centroid of the pointer\n    centroid = np.mean(np.argwhere(cropped_pointer != Color.BLACK), axis=0)\n\n    # Determine the tip of the pointer (farthest point from the centroid)\n    tip = max(np.argwhere(cropped_pointer != Color.BLACK), key=lambda p: np.linalg.norm(p - centroid))\n\n    # Compute the vector from the centroid to the tip\n    vector = np.array(tip) - centroid\n\n    # Quantize the vector to one of the cardinal directions\n    if abs(vector[0]) > abs(vector[1]):  # More horizontal\n        direction = \"E\" if vector[0] > 0 else \"W\"\n    else:  # More vertical\n        direction = \"S\" if vector[1] > 0 else \"N\"\n\n    return direction\n\ndef generate_input():\n    # Create a blank grid with a random background color\n    background_color = np.random.choice(Color.NOT_BLACK)\n    grid_size = np.random.randint(5, 15)\n    grid = np.full((grid_size, grid_size), background_color)\n\n    # Generate a random pointer-shaped object\n    pointer_length = np.random.randint(3, grid_size - 1)\n    pointer = np.full((pointer_length, pointer_length), Color.BLACK)\n\n    # Randomly choose the tip position and draw the pointer\n    tip_x, tip_y = np.random.randint(0, pointer_length, size=2)\n    draw_line(pointer, tip_x, tip_y, length=pointer_length, direction=(1 if tip_x < pointer_length / 2 else -1, 1 if tip_y < pointer_length / 2 else -1), color=np.random.choice(Color.NOT_BLACK))\n\n    # Place the pointer randomly on the grid\n    x, y = random_free_location_for_sprite(grid, pointer, padding=1)\n    blit_sprite(grid, pointer, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# Input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation.\n# Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W).\n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Step 1: Find the pointer-shaped object\n    background_color = Color.BLACK\n    objects = find_connected_components(input_grid, background=background_color, connectivity=8)\n\n    # Assume there is exactly one pointer-shaped object\n    assert len(objects) == 1\n    pointer_object = objects[0]\n\n    # Step 2: Crop the object to get its sprite\n    pointer_sprite = crop(pointer_object, background=background_color)\n\n    # Step 3: Find the centroid of the pointer\n    non_black_pixels = np.argwhere(pointer_sprite != background_color)\n    centroid = np.mean(non_black_pixels, axis=0)\n\n    # Step 4: Find the tip of the pointer (farthest point from the centroid)\n    distances = np.linalg.norm(non_black_pixels - centroid, axis=1)\n    tip_index = np.argmax(distances)\n    tip = non_black_pixels[tip_index]\n\n    # Step 5: Compute the vector from centroid to tip\n    vector = tip - centroid\n\n    # Step 6: Quantize the vector to one of the cardinal directions: N, S, E, W\n    # Normalize the vector\n    if np.abs(vector[0]) > np.abs(vector[1]):\n        direction = 'E' if vector[0] > 0 else 'W'\n    else:\n        direction = 'S' if vector[1] > 0 else 'N'\n\n    return direction\n\ndef generate_input():\n    # Create a grid to contain the pointer\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a pointer-shaped sprite\n    pointer_length = np.random.randint(3, grid_size // 2)\n    pointer_sprite = np.full((pointer_length, pointer_length), Color.RED)  # Random color for the pointer\n\n    # Remove one corner and possibly some other pixels to form a pointer shape\n    pointer_sprite[np.tril_indices(pointer_length, -1)] = Color.BLACK\n\n    # Randomly rotate or flip the sprite to generate different orientations\n    if np.random.rand() > 0.5:\n        pointer_sprite = np.rot90(pointer_sprite, k=np.random.randint(1, 4))\n    if np.random.rand() > 0.5:\n        pointer_sprite = np.flip(pointer_sprite, axis=np.random.choice([0, 1]))\n\n    # Place the pointer on the grid\n    x, y = random_free_location_for_sprite(grid, pointer_sprite, background=Color.BLACK)\n    blit_sprite(grid, pointer_sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# Input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation.\n# Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W).\n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Copy the input grid\n    output_grid = input_grid.copy()\n\n    # Find the pointer object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n\n    # There should be only one object in the grid\n    assert len(objects) == 1\n    pointer_obj = objects[0]\n\n    # Crop the object to extract the sprite\n    pointer_sprite = crop(pointer_obj)\n\n    # Compute the centroid of the pointer object\n    non_black_pixels = np.argwhere(pointer_sprite != Color.BLACK)\n    centroid = np.mean(non_black_pixels, axis=0)\n\n    # Identify the tip of the pointer (the furthest point from the centroid)\n    tip_idx = np.argmax(np.linalg.norm(non_black_pixels - centroid, axis=1))\n    tip = non_black_pixels[tip_idx]\n\n    # Compute the vector from the centroid to the tip\n    vector = tip - centroid\n\n    # Quantize this vector to one of the cardinal directions (N, S, E, W)\n    # We'll map the vector to the closest cardinal direction\n    directions = {\n        'N': np.array([-1, 0]),\n        'S': np.array([1, 0]),\n        'E': np.array([0, 1]),\n        'W': np.array([0, -1])\n    }\n\n    # Normalize the vector to unit length\n    unit_vector = vector / np.linalg.norm(vector)\n\n    # Determine the closest direction by comparing dot products\n    closest_direction = max(directions, key=lambda d: np.dot(unit_vector, directions[d]))\n\n    # Output the determined direction\n    return closest_direction\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate a random pointer-shaped sprite\n    pointer_sprite = random_sprite(3, 3, density=0.7, color_palette=[np.random.choice(Color.NOT_BLACK)], connectivity=8)\n\n    # Find a random free location for the sprite on the grid\n    x, y = random_free_location_for_sprite(grid, pointer_sprite, border_size=1)\n\n    # Place the sprite onto the grid\n    blit_sprite(grid, pointer_sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\n# description:\n# The input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation.\n# Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W).\n# Output the determined direction as a label.\n\ndef main(input_grid):\n    # Find the object in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    assert len(objects) == 1, \"There should be exactly one object in the grid.\"\n    \n    pointer = objects[0]\n\n    # Determine the bounding box of the pointer\n    x, y, w, h = bounding_box(pointer, background=Color.BLACK)\n\n    # Crop the pointer to extract the sprite\n    sprite = crop(pointer, background=Color.BLACK)\n\n    # Calculate the centroid of the pointer\n    colored_pixels = np.argwhere(sprite != Color.BLACK)\n    centroid = np.mean(colored_pixels, axis=0)\n\n    # Assume the tip of the pointer is the furthest point from the centroid\n    distances = np.linalg.norm(colored_pixels - centroid, axis=1)\n    tip_index = np.argmax(distances)\n    tip = colored_pixels[tip_index]\n\n    # Calculate the vector from the centroid to the tip\n    vector = tip - centroid\n\n    # Quantize the vector to determine the facing direction\n    # Cardinal directions: N, S, E, W\n    angle = np.arctan2(vector[0], vector[1])\n    if -np.pi / 4 <= angle < np.pi / 4:\n        direction = 'E'  # East\n    elif np.pi / 4 <= angle < 3 * np.pi / 4:\n        direction = 'N'  # North\n    elif -3 * np.pi / 4 <= angle < -np.pi / 4:\n        direction = 'S'  # South\n    else:\n        direction = 'W'  # West\n\n    return direction\n\ndef generate_input():\n    # Create a grid with a single pointer-shaped object\n    grid_size = 20\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly choose the pointer size and shape\n    pointer_length = np.random.randint(3, 7)\n    pointer_width = np.random.randint(1, 3)\n    \n    # Randomly choose a direction for the pointer\n    direction = np.random.choice(['N', 'S', 'E', 'W'])\n    \n    # Create the pointer sprite\n    pointer_sprite = np.full((pointer_length, pointer_width), np.random.choice(Color.NOT_BLACK))\n\n    if direction == 'N':\n        pointer_sprite[-1, :] = Color.BLACK\n    elif direction == 'S':\n        pointer_sprite[0, :] = Color.BLACK\n    elif direction == 'E':\n        pointer_sprite[:, 0] = Color.BLACK\n    elif direction == 'W':\n        pointer_sprite[:, -1] = Color.BLACK\n\n    # Find a random free location to place the pointer sprite on the grid\n    x, y = random_free_location_for_sprite(grid, pointer_sprite, border_size=2)\n    blit_sprite(grid, pointer_sprite, x, y)\n\n    return grid"], "seeds": ["6e19193c.py", "8e5a5113.py", "264363fd.py", "ea786f4a.py", "Concepts: \norientation detection, shape normalization, centroid-to-tip vector, direction quantization\n\nDescription: \nInput is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation. Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W). Output the determined direction as a label."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# The input grid may be divided by uninterrupted full rows or columns of a single color (e.g., grey). \n# Identify these dividers and split the grid into contiguous sub-grids. Each sub-grid is extracted \n# as a separate region between dividers. Empty sub-grids are discarded. The output is a list of \n# these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    divider_color = None\n    height, width = input_grid.shape\n\n    # Determine the divider color by looking for a full row or column with the same color\n    for color in Color.ALL_COLORS:\n        if any(np.all(input_grid[row, :] == color) for row in range(height)) or any(np.all(input_grid[:, col] == color) for col in range(width)):\n            divider_color = color\n            break\n\n    assert divider_color is not None, \"Divider color not found in the grid\"\n\n    # Find the indices of divider lines\n    horizontal_dividers = [row for row in range(height) if np.all(input_grid[row, :] == divider_color)]\n    vertical_dividers = [col for col in range(width) if np.all(input_grid[:, col] == divider_color)]\n\n    # Include boundaries\n    horizontal_dividers = [-1] + horizontal_dividers + [height]\n    vertical_dividers = [-1] + vertical_dividers + [width]\n\n    sub_grids = []\n\n    # Extract sub-grids between dividers\n    for i in range(len(horizontal_dividers) - 1):\n        for j in range(len(vertical_dividers) - 1):\n            x1, x2 = horizontal_dividers[i] + 1, horizontal_dividers[i + 1]\n            y1, y2 = vertical_dividers[j] + 1, vertical_dividers[j + 1]\n            sub_grid = input_grid[x1:x2, y1:y2]\n\n            # Check if sub-grid is non-empty\n            if np.any(sub_grid != divider_color):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(Color.NOT_BLACK, (height, width))\n\n    # Choose a random color for dividers\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create random horizontal and vertical dividers\n    num_horizontal_dividers = np.random.randint(1, 5)\n    num_vertical_dividers = np.random.randint(1, 5)\n\n    horizontal_dividers = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=2)\n    vertical_dividers = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=2)\n\n    for row in horizontal_dividers:\n        grid[row, :] = divider_color\n\n    for col in vertical_dividers:\n        grid[:, col] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# Input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey). \n# Identify these divider lines and use them to split the grid into contiguous sub-grids. \n# Each sub-grid is extracted as a separate region between dividers. \n# Discard any empty sub-grids. \n# The output is a list of these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Identify the divider color, assumed to be the most frequent color in uninterrupted lines\n    divider_color = None\n    for color in Color.ALL_COLORS:\n        if color == Color.BLACK:\n            continue\n        if any(np.all(input_grid[row, :] == color) for row in range(input_grid.shape[0])) or \\\n           any(np.all(input_grid[:, col] == color) for col in range(input_grid.shape[1])):\n            divider_color = color\n            break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Find all horizontal and vertical divider lines\n    horizontal_dividers = [y for y in range(input_grid.shape[0]) if np.all(input_grid[y, :] == divider_color)]\n    vertical_dividers = [x for x in range(input_grid.shape[1]) if np.all(input_grid[:, x] == divider_color)]\n\n    # Add edges as implicit dividers\n    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[0]]\n    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[1]]\n\n    # Extract sub-grids based on dividers\n    sub_grids = []\n    for h in range(len(horizontal_dividers) - 1):\n        for v in range(len(vertical_dividers) - 1):\n            y1, y2 = horizontal_dividers[h] + 1, horizontal_dividers[h + 1]\n            x1, x2 = vertical_dividers[v] + 1, vertical_dividers[v + 1]\n            sub_grid = input_grid[y1:y2, x1:x2]\n            \n            # Ensure the sub-grid is not entirely empty\n            if np.any(sub_grid != Color.BLACK):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate grid size\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly select a color for dividers\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Determine number of horizontal and vertical dividers\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    # Generate divider positions ensuring no overlap and adequate spacing\n    horizontal_positions = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=2)\n    vertical_positions = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=2)\n\n    # Draw the dividers\n    for y in horizontal_positions:\n        grid[y, :] = divider_color\n    for x in vertical_positions:\n        grid[:, x] = divider_color\n\n    # Fill sub-grids with randomly scattered colors\n    for h in range(len(horizontal_positions) + 1):\n        for v in range(len(vertical_positions) + 1):\n            y1 = 0 if h == 0 else horizontal_positions[h-1] + 1\n            y2 = horizontal_positions[h] if h < len(horizontal_positions) else height\n            x1 = 0 if v == 0 else vertical_positions[v-1] + 1\n            x2 = vertical_positions[v] if v < len(vertical_positions) else width\n\n            if y2 - y1 > 1 and x2 - x1 > 1:  # Ensure the sub-grid is big enough to fill\n                color = np.random.choice(Color.NOT_BLACK)\n                randomly_scatter_points(grid[y1:y2, x1:x2], color=color, density=0.3)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# The input grid may have uninterrupted full rows or columns of a single color (e.g., grey) that act as dividers. \n# Identify these dividers and split the grid into contiguous sub-grids between them. Discard any empty sub-grids.\n# Output a list of these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid):\n    # Identify the color of the dividers\n    candidate_divider_colors = [Color.GREY]  # More colors can be added if needed\n    divider_color = None\n\n    # Detect the divider color by checking for full rows or columns of a single color\n    for color in candidate_divider_colors:\n        if any(np.all(input_grid[i, :] == color) for i in range(input_grid.shape[0])) or any(np.all(input_grid[:, j] == color) for j in range(input_grid.shape[1])):\n            divider_color = color\n            break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Find the positions of the horizontal and vertical dividers\n    horizontal_dividers = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == divider_color)]\n    vertical_dividers = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == divider_color)]\n\n    # Add implicit dividers at the borders\n    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[0]]\n    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[1]]\n\n    # Extract sub-grids\n    sub_grids = []\n    for h in range(len(horizontal_dividers) - 1):\n        for v in range(len(vertical_dividers) - 1):\n            x1, x2 = horizontal_dividers[h] + 1, horizontal_dividers[h + 1]\n            y1, y2 = vertical_dividers[v] + 1, vertical_dividers[v + 1]\n            sub_grid = input_grid[x1:x2, y1:y2]\n\n            # Check if the sub-grid is non-empty\n            if np.any(sub_grid != Color.BLACK):  # Assuming black is the empty color\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of dividers\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    # Randomly position the dividers\n    horizontal_indices = randomly_spaced_indices(width, num_horizontal_dividers, border_size=1, padding=2)\n    vertical_indices = randomly_spaced_indices(height, num_vertical_dividers, border_size=1, padding=2)\n\n    # Set the dividers in the grid\n    for x in horizontal_indices:\n        grid[x, :] = Color.GREY\n    for y in vertical_indices:\n        grid[:, y] = Color.GREY\n\n    # Randomly generate sub-grid content between dividers\n    colors = list(Color.NOT_BLACK - {Color.GREY})\n    for h in range(len(horizontal_indices) + 1):\n        for v in range(len(vertical_indices) + 1):\n            x1 = 0 if h == 0 else horizontal_indices[h - 1] + 1\n            x2 = horizontal_indices[h] if h < len(horizontal_indices) else width\n            y1 = 0 if v == 0 else vertical_indices[v - 1] + 1\n            y2 = vertical_indices[v] if v < len(vertical_indices) else height\n\n            if x1 < x2 and y1 < y2:\n                sprite = random_sprite(\n                    n=x2 - x1, \n                    m=y2 - y1, \n                    density=0.3, # Adjust density as needed\n                    color_palette=colors\n                )\n                blit_sprite(grid, sprite, x=x1, y=y1, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# The input grid is potentially divided by uninterrupted full rows or columns of a single color (e.g., grey).\n# Identify these divider lines and use them to split the grid into contiguous sub-grids. \n# Each sub-grid is extracted as a separate region between dividers. Discard any empty sub-grids.\n# The output is a list of these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid):\n    # Identify the divider color\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i][j]\n            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):\n                divider_color = color\n                break\n    \n    assert divider_color is not None, \"No divider color found\"\n\n    # Find rows and columns that are completely filled with the divider color\n    divider_rows = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == divider_color)]\n    divider_cols = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == divider_color)]\n\n    # Add boundaries to the list of dividers\n    divider_rows = [-1] + divider_rows + [input_grid.shape[0]]\n    divider_cols = [-1] + divider_cols + [input_grid.shape[1]]\n\n    # Extract sub-grids between dividers, discard empty sub-grids\n    sub_grids = []\n    for i in range(len(divider_rows) - 1):\n        for j in range(len(divider_cols) - 1):\n            sub_grid = input_grid[divider_rows[i]+1:divider_rows[i+1], divider_cols[j]+1:divider_cols[j+1]]\n            if np.any(sub_grid != divider_color):  # Check if sub-grid is not empty\n                sub_grids.append(sub_grid)\n    \n    return sub_grids\n\ndef generate_input():\n    # Define grid size\n    grid_size = np.random.randint(15, 25)\n    grid = np.random.choice(Color.NOT_BLACK, (grid_size, grid_size))\n\n    # Choose a divider color\n    divider_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place divider lines\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    horizontal_dividers = randomly_spaced_indices(max_len=grid_size, n_indices=num_horizontal_dividers, border_size=1, padding=1)\n    vertical_dividers = randomly_spaced_indices(max_len=grid_size, n_indices=num_vertical_dividers, border_size=1, padding=1)\n\n    # Apply divider lines to the grid\n    for row in horizontal_dividers:\n        grid[row, :] = divider_color\n\n    for col in vertical_dividers:\n        grid[:, col] = divider_color\n\n    # Randomly scatter points of other colors in the sub-grids\n    for i in range(len(horizontal_dividers) + 1):\n        for j in range(len(vertical_dividers) + 1):\n            row_start = 0 if i == 0 else horizontal_dividers[i-1] + 1\n            row_end = grid_size if i == len(horizontal_dividers) else horizontal_dividers[i]\n            col_start = 0 if j == 0 else vertical_dividers[j-1] + 1\n            col_end = grid_size if j == len(vertical_dividers) else vertical_dividers[j]\n\n            sub_grid = grid[row_start:row_end, col_start:col_end]\n            randomly_scatter_points(sub_grid, color=np.random.choice(Color.NOT_BLACK), density=0.5)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# The input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey).\n# Identify these divider lines and use them to split the grid into contiguous sub-grids. Each sub-grid is extracted as a separate region between dividers.\n# Discard any empty sub-grids. The output is a list of these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid):\n    # Identify the divider color by finding any row or column that is completely a single color\n    divider_color = None\n    n_rows, n_cols = input_grid.shape\n\n    # Find divider color\n    for row in range(n_rows):\n        if np.all(input_grid[row, :] == input_grid[row, 0]):\n            divider_color = input_grid[row, 0]\n            break\n\n    if divider_color is None:\n        for col in range(n_cols):\n            if np.all(input_grid[:, col] == input_grid[0, col]):\n                divider_color = input_grid[0, col]\n                break\n\n    assert divider_color is not None, \"No divider line found\"\n\n    # Find all the dividers and extract sub-grids\n    horizontal_dividers = [row for row in range(n_rows) if np.all(input_grid[row, :] == divider_color)]\n    vertical_dividers = [col for col in range(n_cols) if np.all(input_grid[:, col] == divider_color)]\n    \n    # Include the edges\n    horizontal_dividers = [0] + horizontal_dividers + [n_rows]\n    vertical_dividers = [0] + vertical_dividers + [n_cols]\n\n    sub_grids = []\n\n    # Extract sub-grids\n    for i in range(len(horizontal_dividers) - 1):\n        for j in range(len(vertical_dividers) - 1):\n            top, bottom = horizontal_dividers[i], horizontal_dividers[i + 1]\n            left, right = vertical_dividers[j], vertical_dividers[j + 1]\n\n            sub_grid = input_grid[top:bottom, left:right]\n            if np.any(sub_grid != divider_color):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(list(Color.NOT_BLACK), (width, height))\n\n    # Randomly select divider color\n    divider_color = np.random.choice(list(Color.ALL_COLORS))\n\n    # Randomly select the number of dividers\n    n_horizontal_dividers = np.random.randint(2, 5)\n    n_vertical_dividers = np.random.randint(2, 5)\n\n    # Randomly place dividers\n    horizontal_indices = randomly_spaced_indices(width, n_horizontal_dividers, border_size=1, padding=2)\n    vertical_indices = randomly_spaced_indices(height, n_vertical_dividers, border_size=1, padding=2)\n\n    for row in horizontal_indices:\n        grid[row, :] = divider_color\n\n    for col in vertical_indices:\n        grid[:, col] = divider_color\n\n    # Randomly scatter some points in the regions to ensure they are not empty\n    for _ in range(5):\n        randomly_scatter_points(grid, color=np.random.choice(list(Color.NOT_BLACK - {divider_color})), density=0.1)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# The input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey).\n# Identify these divider lines and use them to split the grid into contiguous sub-grids.\n# Each sub-grid is extracted as a separate region between dividers. Discard any empty sub-grids.\n# The output is a list of these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Plan:\n    # 1. Identify potential divider lines that are uninterrupted rows or columns of a single color.\n    # 2. Use these dividers to split the grid into sub-grids.\n    # 3. Extract each sub-grid and discard any that are empty.\n    # 4. Return the list of non-empty sub-grids.\n\n    divider_color = Color.GREY\n    height, width = input_grid.shape\n\n    # Identify the horizontal and vertical dividers\n    horizontal_dividers = [y for y in range(height) if np.all(input_grid[y, :] == divider_color)]\n    vertical_dividers = [x for x in range(width) if np.all(input_grid[:, x] == divider_color)]\n\n    # Add boundaries to the divider lists to handle edges\n    horizontal_dividers = [-1] + horizontal_dividers + [height]\n    vertical_dividers = [-1] + vertical_dividers + [width]\n\n    sub_grids = []\n\n    # Split the grid into sub-grids based on divider positions\n    for i in range(len(horizontal_dividers) - 1):\n        for j in range(len(vertical_dividers) - 1):\n            y_start = horizontal_dividers[i] + 1\n            y_end = horizontal_dividers[i + 1]\n            x_start = vertical_dividers[j] + 1\n            x_end = vertical_dividers[j + 1]\n\n            sub_grid = input_grid[y_start:y_end, x_start:x_end]\n\n            # Check if the sub-grid is non-empty (contains at least one non-divider, non-black pixel)\n            if np.any(sub_grid != divider_color) and np.any(sub_grid != Color.BLACK):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\n\ndef generate_input() -> np.ndarray:\n    # Generate a grid with random size\n    height, width = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly determine the number of dividers\n    num_horizontal_dividers = np.random.randint(1, 4)\n    num_vertical_dividers = np.random.randint(1, 4)\n\n    # Randomly place horizontal dividers\n    horizontal_positions = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=1)\n    for y in horizontal_positions:\n        grid[y, :] = Color.GREY\n\n    # Randomly place vertical dividers\n    vertical_positions = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=1)\n    for x in vertical_positions:\n        grid[:, x] = Color.GREY\n\n    # Fill sub-grids with random colors\n    color_palette = list(Color.NOT_BLACK)\n    for i in range(len(horizontal_positions) + 1):\n        for j in range(len(vertical_positions) + 1):\n            y_start = 0 if i == 0 else horizontal_positions[i - 1] + 1\n            y_end = height if i == len(horizontal_positions) else horizontal_positions[i]\n            x_start = 0 if j == 0 else vertical_positions[j - 1] + 1\n            x_end = width if j == len(vertical_positions) else vertical_positions[j]\n\n            if y_end > y_start and x_end > x_start:\n                color = np.random.choice(color_palette)\n                grid[y_start:y_end, x_start:x_end] = color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# Input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey).\n# Identify these divider lines and use them to split the grid into contiguous sub-grids. \n# Each sub-grid is extracted as a separate region between dividers. Discard any empty sub-grids. \n# The output is a list of these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid: np.ndarray) -> List[np.ndarray]:\n    # Identify the color used for dividers.\n    divider_color = None\n    for x in range(input_grid.shape[0]):\n        if np.all(input_grid[x, :] == input_grid[x, 0]):\n            divider_color = input_grid[x, 0]\n            break\n        if np.all(input_grid[:, x] == input_grid[0, x]):\n            divider_color = input_grid[0, x]\n            break\n            \n    assert divider_color is not None, \"No divider color found\"\n\n    # Find the horizontal and vertical divider lines\n    horizontal_dividers = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]\n    vertical_dividers = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]\n\n    # Include edges to ensure full coverage\n    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[1]]\n    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[0]]\n\n    # Extract sub-grids between dividers\n    sub_grids = []\n    for i in range(len(vertical_dividers) - 1):\n        for j in range(len(horizontal_dividers) - 1):\n            x1, x2 = vertical_dividers[i] + 1, vertical_dividers[i + 1]\n            y1, y2 = horizontal_dividers[j] + 1, horizontal_dividers[j + 1]\n            sub_grid = input_grid[x1:x2, y1:y2]\n            if np.any(sub_grid != divider_color):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input() -> np.ndarray:\n    # Randomly generate the grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(Color.NOT_BLACK, size=(width, height))\n\n    # Choose a color to act as the divider\n    divider_color = Color.GREY\n\n    # Randomly determine the number of dividers\n    num_h_dividers = np.random.randint(1, min(width, 5))\n    num_v_dividers = np.random.randint(1, min(height, 5))\n\n    # Randomly place horizontal and vertical dividers\n    h_indices = randomly_spaced_indices(max_len=height, n_indices=num_h_dividers, border_size=1, padding=1)\n    v_indices = randomly_spaced_indices(max_len=width, n_indices=num_v_dividers, border_size=1, padding=1)\n\n    # Draw the dividers\n    for h in h_indices:\n        grid[:, h] = divider_color\n    for v in v_indices:\n        grid[v, :] = divider_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# divider detection, grid slicing, connected components, sub-grid extraction\n\n# description:\n# Input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey).\n# Identify these divider lines and use them to split the grid into contiguous sub-grids.\n# Each sub-grid is extracted as a separate region between dividers.\n# Discard any empty sub-grids. The output is a list of these non-empty sub-grids, preserving their original order and content.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the color of the divider (grey) by finding a full row or column with the same color.\n    # 2. Identify all horizontal and vertical divider lines.\n    # 3. Split the grid into contiguous sub-grids using the divider lines.\n    # 4. Discard any empty sub-grids and return the list of non-empty sub-grids.\n\n    width, height = input_grid.shape\n\n    # Step 1: Detect the divider color\n    divider_color = None\n    for i in range(width):\n        if np.all(input_grid[i, :] == input_grid[i, 0]):\n            divider_color = input_grid[i, 0]\n            break\n\n    if divider_color is None:\n        for j in range(height):\n            if np.all(input_grid[:, j] == input_grid[0, j]):\n                divider_color = input_grid[0, j]\n                break\n\n    assert divider_color is not None, \"No divider color found\"\n\n    # Step 2: Identify divider lines\n    horizontal_dividers = [y for y in range(height) if np.all(input_grid[:, y] == divider_color)]\n    vertical_dividers = [x for x in range(width) if np.all(input_grid[x, :] == divider_color)]\n\n    # Add borders as implicit dividers\n    horizontal_dividers = [-1] + horizontal_dividers + [height]\n    vertical_dividers = [-1] + vertical_dividers + [width]\n\n    # Step 3: Split into sub-grids\n    sub_grids = []\n    for i in range(len(vertical_dividers) - 1):\n        for j in range(len(horizontal_dividers) - 1):\n            x_start = vertical_dividers[i] + 1\n            x_end = vertical_dividers[i + 1]\n            y_start = horizontal_dividers[j] + 1\n            y_end = horizontal_dividers[j + 1]\n\n            sub_grid = input_grid[x_start:x_end, y_start:y_end]\n            if np.any(sub_grid != divider_color):\n                sub_grids.append(sub_grid)\n\n    return sub_grids\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.random.choice(Color.NOT_BLACK, (width, height), replace=True)\n\n    # Select a color for dividers\n    divider_color = Color.GREY\n\n    # Randomly decide the number of horizontal and vertical dividers\n    n_horizontal_dividers = np.random.randint(1, 4)\n    n_vertical_dividers = np.random.randint(1, 4)\n\n    # Randomly space divider indices\n    horizontal_indices = randomly_spaced_indices(max_len=height, n_indices=n_horizontal_dividers, border_size=1, padding=2)\n    vertical_indices = randomly_spaced_indices(max_len=width, n_indices=n_vertical_dividers, border_size=1, padding=2)\n\n    # Draw horizontal and vertical dividers\n    for y in horizontal_indices:\n        grid[:, y] = divider_color\n\n    for x in vertical_indices:\n        grid[x, :] = divider_color\n\n    return grid"], "seeds": ["780d0b14.py", "90c28cc7.py", "00d62c1b.py", "06df4c85.py", "Concepts: \ndivider detection, grid slicing, connected components, sub-grid extraction\n\nDescription: \nInput is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey). Identify these divider lines and use them to split the grid into contiguous sub-grids. Each sub-grid is extracted as a separate region between dividers. Discard any empty sub-grids. The output is a list of these non-empty sub-grids, preserving their original order and content."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). \n# Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. \n# If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; \n# if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact.\n# Maintain block order and shape; stop when further movement would result in collision or leaving the grid. \n# The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, \n# with empty space opposite the fall direction.\n\ndef main(input_grid, gravity_direction, cohesion_mode):\n    # Copy the input grid to begin transformations\n    output_grid = np.copy(input_grid)\n    \n    # Determine the direction vector based on gravity direction\n    if gravity_direction == 'down':\n        direction = (0, 1)\n    elif gravity_direction == 'up':\n        direction = (0, -1)\n    elif gravity_direction == 'left':\n        direction = (-1, 0)\n    elif gravity_direction == 'right':\n        direction = (1, 0)\n    else:\n        raise ValueError(\"Invalid gravity direction\")\n    \n    # Identify unique blocks\n    blocks = find_connected_components(output_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # Sort blocks based on their position to handle them in the correct order\n    # Sorting ensures that in per-column mode we process from bottom to top or left to right depending on gravity\n    if gravity_direction in ['down', 'up']:\n        blocks.sort(key=lambda obj: np.min(np.where(obj != Color.BLACK)[1]) if gravity_direction == 'down' else -np.max(np.where(obj != Color.BLACK)[1]))\n    else:\n        blocks.sort(key=lambda obj: np.min(np.where(obj != Color.BLACK)[0]) if gravity_direction == 'right' else -np.max(np.where(obj != Color.BLACK)[0]))\n\n    # Move blocks according to cohesion mode\n    if cohesion_mode == 'per-column':\n        for obj in blocks:\n            move_block_independently(output_grid, obj, direction)\n    elif cohesion_mode == 'cohesive':\n        move_blocks_cohesively(output_grid, blocks, direction)\n    else:\n        raise ValueError(\"Invalid cohesion mode\")\n\n    return output_grid\n\ndef move_block_independently(grid, block, direction):\n    # Move each block in the specified direction until collision\n    possible = True\n    while possible:\n        translated_block = translate(block, *direction)\n        if not collision(object1=grid, object2=translated_block):\n            block[:] = translated_block\n        else:\n            possible = False\n    blit_object(grid, block)\n\ndef move_blocks_cohesively(grid, blocks, direction):\n    # Create a single composite block from all blocks\n    composite_block = np.full_like(grid, Color.BLACK)\n    for block in blocks:\n        blit_object(composite_block, block)\n    \n    # Move the composite block in the specified direction until collision\n    possible = True\n    while possible:\n        translated_composite = translate(composite_block, *direction)\n        if not collision(object1=grid, object2=translated_composite):\n            composite_block[:] = translated_composite\n        else:\n            possible = False\n    \n    # Clear the grid and blit the final position of the composite block\n    grid[:] = Color.BLACK\n    blit_object(grid, composite_block)\n\ndef generate_input():\n    # Randomly determine grid size\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Create random blocks of different colors\n    num_blocks = np.random.randint(2, 5)\n    for _ in range(num_blocks):\n        color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(np.random.randint(1, 3), np.random.randint(1, 3), color_palette=[color])\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n    \n    # Randomly choose gravity direction and cohesion mode\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n    \n    return grid, gravity_direction, cohesion_mode", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right').\n# Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries.\n# If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers;\n# if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact.\n# Maintain block order and shape; stop when further movement would result in collision or leaving the grid.\n# The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n\ndef main(input_grid):\n    # Extract grid size\n    height, width = input_grid.shape\n    \n    # Determine gravity direction and cohesion mode\n    gravity_direction = input_grid[0, 0]\n    cohesion_mode = input_grid[0, 1]\n    assert gravity_direction in ['down', 'up', 'left', 'right'], \"Invalid gravity direction\"\n    assert cohesion_mode in ['per-column', 'cohesive'], \"Invalid cohesion mode\"\n    \n    # Clear gravity direction and cohesion mode from the grid\n    input_grid[0, 0] = Color.BLACK\n    input_grid[0, 1] = Color.BLACK\n\n    # Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Find connected components (blocks) in the grid\n    blocks = find_connected_components(input_grid, background=Color.BLACK)\n\n    if cohesion_mode == 'cohesive':\n        # Apply cohesive gravity: treat all blocks as one rigid shape\n        apply_cohesive_gravity(output_grid, blocks, gravity_direction)\n    else:\n        # Apply per-column gravity: move blocks independently\n        apply_per_column_gravity(output_grid, blocks, gravity_direction)\n    \n    return output_grid\n\ndef apply_cohesive_gravity(grid, blocks, direction):\n    # Determine translation vector based on gravity direction\n    translation = {\n        'down': (0, 1),\n        'up': (0, -1),\n        'left': (-1, 0),\n        'right': (1, 0)\n    }[direction]\n    \n    # Move each block as a single unit until collision\n    for block in blocks:\n        while not collision(object1=translate(block, *translation), object2=grid):\n            block = translate(block, *translation)\n        blit_object(grid, block)\n\ndef apply_per_column_gravity(grid, blocks, direction):\n    # Determine translation vector based on gravity direction\n    translation = {\n        'down': (0, 1),\n        'up': (0, -1),\n        'left': (-1, 0),\n        'right': (1, 0)\n    }[direction]\n    \n    # Move each block independently\n    for block in blocks:\n        while not collision(object1=translate(block, *translation), object2=grid):\n            block = translate(block, *translation)\n        blit_object(grid, block)\n\ndef generate_input():\n    # Random grid size\n    height = np.random.randint(8, 15)\n    width = np.random.randint(8, 15)\n    grid = np.full((height, width), Color.BLACK, dtype=int)\n\n    # Randomly choose gravity direction and cohesion mode\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n\n    # Place gravity direction and cohesion mode in the grid\n    grid[0, 0] = gravity_direction\n    grid[0, 1] = cohesion_mode\n\n    # Randomly generate blocks and place in the grid\n    num_blocks = np.random.randint(2, 5)\n    for _ in range(num_blocks):\n        block_size = np.random.randint(2, 4)\n        block = random_sprite(block_size, block_size, color_palette=Color.NOT_BLACK)\n        x, y = random_free_location_for_sprite(grid, block)\n        blit_sprite(grid, block, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries.\n# If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact.\n# Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n\ndef main(input_grid, gravity_direction='down', cohesion_mode='per-column'):\n    # Initialize the output grid with the same size as input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Get all connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    if cohesion_mode == 'per-column':\n        if gravity_direction in ('down', 'up'):\n            # Handle vertical column-wise gravity\n            for x in range(input_grid.shape[0]):\n                column = input_grid[x, :]\n                if gravity_direction == 'down':\n                    # Start from the bottom and move up\n                    filled_indices = np.where(column != Color.BLACK)[0]\n                    for idx in reversed(filled_indices):\n                        color = column[idx]\n                        # Find the target position\n                        target_idx = idx\n                        while target_idx < column.shape[0] - 1 and output_grid[x, target_idx + 1] == Color.BLACK:\n                            target_idx += 1\n                        output_grid[x, target_idx] = color\n                else:\n                    # Start from the top and move down\n                    filled_indices = np.where(column != Color.BLACK)[0]\n                    for idx in filled_indices:\n                        color = column[idx]\n                        # Find the target position\n                        target_idx = idx\n                        while target_idx > 0 and output_grid[x, target_idx - 1] == Color.BLACK:\n                            target_idx -= 1\n                        output_grid[x, target_idx] = color\n        else:\n            # Handle horizontal column-wise gravity\n            for y in range(input_grid.shape[1]):\n                row = input_grid[:, y]\n                if gravity_direction == 'right':\n                    # Start from the right and move left\n                    filled_indices = np.where(row != Color.BLACK)[0]\n                    for idx in reversed(filled_indices):\n                        color = row[idx]\n                        # Find the target position\n                        target_idx = idx\n                        while target_idx < row.shape[0] - 1 and output_grid[target_idx + 1, y] == Color.BLACK:\n                            target_idx += 1\n                        output_grid[target_idx, y] = color\n                else:\n                    # Start from the left and move right\n                    filled_indices = np.where(row != Color.BLACK)[0]\n                    for idx in filled_indices:\n                        color = row[idx]\n                        # Find the target position\n                        target_idx = idx\n                        while target_idx > 0 and output_grid[target_idx - 1, y] == Color.BLACK:\n                            target_idx -= 1\n                        output_grid[target_idx, y] = color\n\n    elif cohesion_mode == 'cohesive':\n        # Treat the whole structure as a single rigid body\n        for comp in components:\n            blit_object(output_grid, comp)\n            while True:\n                if gravity_direction == 'down':\n                    # Try moving down\n                    if collision(object1=translate(comp, 0, 1), object2=output_grid):\n                        break\n                    comp = translate(comp, 0, 1)\n                elif gravity_direction == 'up':\n                    # Try moving up\n                    if collision(object1=translate(comp, 0, -1), object2=output_grid):\n                        break\n                    comp = translate(comp, 0, -1)\n                elif gravity_direction == 'right':\n                    # Try moving right\n                    if collision(object1=translate(comp, 1, 0), object2=output_grid):\n                        break\n                    comp = translate(comp, 1, 0)\n                elif gravity_direction == 'left':\n                    # Try moving left\n                    if collision(object1=translate(comp, -1, 0), object2=output_grid):\n                        break\n                    comp = translate(comp, -1, 0)\n\n            # Final position of the component\n            blit_object(output_grid, comp)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random blocks and a random gravity direction and cohesion mode\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Add random blocks to the grid\n    num_blocks = np.random.randint(5, 10)\n    for _ in range(num_blocks):\n        block_size = np.random.randint(2, 4)\n        block = random_sprite(block_size, block_size, color_palette=Color.NOT_BLACK)\n        x, y = random_free_location_for_sprite(grid, block, background=Color.BLACK)\n        blit_sprite(grid, block, x, y)\n\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n\n    return grid, gravity_direction, cohesion_mode", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries.\n# If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact.\n# Maintain block order and shape; stop when further movement would result in collision or leaving the grid.\n# The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n\ndef main(input_grid):\n    # Extract gravity direction and cohesion mode from the grid\n    gravity_direction = input_grid[0, 0]  # Assume first element encodes gravity direction\n    cohesion_mode = input_grid[0, 1]  # Assume second element encodes cohesion mode\n\n    # Remove direction and mode encoding for processing\n    input_grid = input_grid[1:, :]\n\n    # Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define movement vectors based on gravity direction\n    if gravity_direction == 'down':\n        move_vector = (1, 0)\n    elif gravity_direction == 'up':\n        move_vector = (-1, 0)\n    elif gravity_direction == 'left':\n        move_vector = (0, -1)\n    elif gravity_direction == 'right':\n        move_vector = (0, 1)\n    else:\n        raise ValueError(\"Invalid gravity direction\")\n\n    # Process connected components based on cohesion mode\n    if cohesion_mode == 'cohesive':\n        # Treat entire block structure as a single object\n        objects = [input_grid]\n    else:\n        # Treat each column independently\n        objects = [input_grid[:, i:i+1] for i in range(input_grid.shape[1])]\n\n    for obj in objects:\n        # Translate the object according to gravity until collision or boundary\n        while True:\n            translated_obj = translate(obj, *move_vector)\n            if collision(object1=translated_obj, object2=output_grid) or \\\n               not (0 <= translated_obj.shape[0] <= output_grid.shape[0] and\n                    0 <= translated_obj.shape[1] <= output_grid.shape[1]):\n                break\n            obj = translated_obj\n\n        # Blit the final position of the object onto the output grid\n        blit_object(output_grid, obj)\n\n    return output_grid\n\n\ndef generate_input():\n    # Define grid size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select gravity direction and cohesion mode\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n\n    # Encode the gravity direction and cohesion mode in the first row\n    grid[0, 0] = gravity_direction\n    grid[0, 1] = cohesion_mode\n\n    # Generate random blocks in the grid\n    num_blocks = np.random.randint(3, 6)\n    for _ in range(num_blocks):\n        block_color = np.random.choice(list(Color.NOT_BLACK))\n        block_size = np.random.randint(1, 4, size=2)\n        block = random_sprite(block_size[0], block_size[1], color_palette=[block_color])\n        x, y = random_free_location_for_sprite(grid[1:], block)\n        blit_sprite(grid, block, x + 1, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. \n# If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. \n# Maintain block order and shape; stop when further movement would result in collision or leaving the grid. \n# The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n\ndef main(input_grid, gravity_direction, cohesion_mode):\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # Determine translation vector based on gravity direction\n    if gravity_direction == 'down':\n        translation_vector = (1, 0)\n    elif gravity_direction == 'up':\n        translation_vector = (-1, 0)\n    elif gravity_direction == 'left':\n        translation_vector = (0, -1)\n    elif gravity_direction == 'right':\n        translation_vector = (0, 1)\n    else:\n        raise ValueError(\"Invalid gravity direction\")\n\n    # Process blocks based on cohesion mode\n    if cohesion_mode == 'per-column':\n        for col in range(width):\n            column_blocks = output_grid[:, col]\n            for row in range(height):\n                if column_blocks[row] != Color.BLACK:\n                    # Move each block down independently\n                    current_pos = (row, col)\n                    while True:\n                        next_pos = (current_pos[0] + translation_vector[0], current_pos[1] + translation_vector[1])\n                        if (0 <= next_pos[0] < height and 0 <= next_pos[1] < width and output_grid[next_pos] == Color.BLACK):\n                            output_grid[next_pos] = output_grid[current_pos]\n                            output_grid[current_pos] = Color.BLACK\n                            current_pos = next_pos\n                        else:\n                            break\n\n    elif cohesion_mode == 'cohesive':\n        blocks = find_connected_components(output_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n        for block in blocks:\n            while True:\n                translated_block = translate(block, *translation_vector)\n                if not collision(object1=translated_block, object2=output_grid, background=Color.BLACK):\n                    block = translated_block\n                else:\n                    break\n            blit_object(output_grid, block)\n\n    else:\n        raise ValueError(\"Invalid cohesion mode\")\n\n    return output_grid\n\n\ndef generate_input():\n    height = np.random.randint(5, 15)\n    width = np.random.randint(5, 15)\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly place some blocks of various colors\n    num_blocks = np.random.randint(3, 8)\n    for _ in range(num_blocks):\n        block_height = np.random.randint(1, 3)\n        block_width = np.random.randint(1, 3)\n        block_sprite = random_sprite(block_height, block_width, color_palette=list(Color.NOT_BLACK))\n        x, y = random_free_location_for_sprite(input_grid, block_sprite)\n        blit_sprite(input_grid, block_sprite, x, y)\n\n    # Randomly choose gravity direction and cohesion mode for the input\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n\n    return input_grid, gravity_direction, cohesion_mode", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n\ndef main(input_data):\n    input_grid, gravity_direction, cohesion_mode = input_data\n    output_grid = np.copy(input_grid)\n    \n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    if cohesion_mode == 'per-column':\n        for col in range(output_grid.shape[1]):\n            column_objects = [obj for obj in objects if np.any(np.where(obj != Color.BLACK)[1] == col)]\n            for obj in column_objects:\n                move_object_in_direction(output_grid, obj, gravity_direction)\n    else: # 'cohesive'\n        for obj in objects:\n            move_object_in_direction(output_grid, obj, gravity_direction)\n\n    return output_grid\n\ndef move_object_in_direction(grid, obj, direction):\n    dx, dy = 0, 0\n    if direction == 'down':\n        dy = 1\n    elif direction == 'up':\n        dy = -1\n    elif direction == 'right':\n        dx = 1\n    elif direction == 'left':\n        dx = -1\n\n    while not collision(object1=translate(obj, dx, dy), object2=grid):\n        obj = translate(obj, dx, dy)\n\n    blit_object(grid, obj)\n\ndef generate_input():\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_objects = np.random.randint(2, 5)\n    for _ in range(num_objects):\n        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW])\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y)\n\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n\n    return grid, gravity_direction, cohesion_mode", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n\ndef main(input_grid, gravity_direction, cohesion_mode):\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all connected components (blocks) in the grid\n    blocks = find_connected_components(input_grid, connectivity=4, background=Color.BLACK)\n\n    if cohesion_mode == 'per-column':\n        for col in range(input_grid.shape[1]):\n            column_blocks = [block for block in blocks if np.any(np.any(block[:, col] != Color.BLACK, axis=0))]\n            for block in column_blocks:\n                move_block(block, output_grid, gravity_direction)\n    elif cohesion_mode == 'cohesive':\n        for block in blocks:\n            move_block(block, output_grid, gravity_direction)\n\n    return output_grid\n\ndef move_block(block, output_grid, gravity_direction):\n    # Determine the movement vector based on gravity direction\n    if gravity_direction == 'down':\n        move_vector = (1, 0)\n    elif gravity_direction == 'up':\n        move_vector = (-1, 0)\n    elif gravity_direction == 'right':\n        move_vector = (0, 1)\n    elif gravity_direction == 'left':\n        move_vector = (0, -1)\n    else:\n        raise ValueError(\"Invalid gravity direction\")\n\n    # Move blocks in the specified direction until they collide\n    while not collision(object1=translate(block, *move_vector), object2=output_grid):\n        block = translate(block, *move_vector)\n\n    # Blit the final position of the block onto the output grid\n    blit_object(output_grid, block)\n\ndef generate_input():\n    # Randomly generate grid size\n    width, height = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate random blocks\n    num_blocks = np.random.randint(2, 5)\n    for _ in range(num_blocks):\n        block_width, block_height = np.random.randint(1, 3), np.random.randint(1, 3)\n        block = random_sprite(block_width, block_height, color_palette=Color.NOT_BLACK)\n        x, y = random_free_location_for_sprite(grid, block)\n        blit_sprite(grid, block, x, y)\n    \n    # Randomly choose a gravity direction\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n\n    # Randomly choose a cohesion mode\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n\n    return grid, gravity_direction, cohesion_mode", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity simulation, directional movement, cohesion modes, collision detection\n\n# description:\n# Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.\n\ndef main(input_grid):\n    # Extract the gravity direction and cohesion mode from the first row\n    gravity_direction = input_grid[0, 0]\n    cohesion_mode = input_grid[0, 1]\n\n    # Remove the first row which contains metadata\n    input_grid = input_grid[1:]\n\n    # Copy the input grid to the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Apply gravity based on the direction\n    if gravity_direction == 'down':\n        if cohesion_mode == 'per-column':\n            for col in range(input_grid.shape[1]):\n                column = input_grid[:, col]\n                non_black_indices = np.where(column != Color.BLACK)[0]\n                for i, idx in enumerate(non_black_indices):\n                    output_grid[-len(non_black_indices) + i, col] = column[idx]\n        elif cohesion_mode == 'cohesive':\n            blocks = find_connected_components(input_grid, background=Color.BLACK)\n            for block in blocks:\n                while not collision(object1=block, object2=output_grid, y1=1):\n                    block = translate(block, 0, 1)\n                blit_object(output_grid, block)\n    elif gravity_direction == 'up':\n        if cohesion_mode == 'per-column':\n            for col in range(input_grid.shape[1]):\n                column = input_grid[:, col]\n                non_black_indices = np.where(column != Color.BLACK)[0]\n                for i, idx in enumerate(non_black_indices):\n                    output_grid[i, col] = column[idx]\n        elif cohesion_mode == 'cohesive':\n            blocks = find_connected_components(input_grid, background=Color.BLACK)\n            for block in blocks:\n                while not collision(object1=block, object2=output_grid, y1=-1):\n                    block = translate(block, 0, -1)\n                blit_object(output_grid, block)\n    elif gravity_direction == 'left':\n        if cohesion_mode == 'per-column':\n            for row in range(input_grid.shape[0]):\n                line = input_grid[row, :]\n                non_black_indices = np.where(line != Color.BLACK)[0]\n                for i, idx in enumerate(non_black_indices):\n                    output_grid[row, i] = line[idx]\n        elif cohesion_mode == 'cohesive':\n            blocks = find_connected_components(input_grid, background=Color.BLACK)\n            for block in blocks:\n                while not collision(object1=block, object2=output_grid, x1=-1):\n                    block = translate(block, -1, 0)\n                blit_object(output_grid, block)\n    elif gravity_direction == 'right':\n        if cohesion_mode == 'per-column':\n            for row in range(input_grid.shape[0]):\n                line = input_grid[row, :]\n                non_black_indices = np.where(line != Color.BLACK)[0]\n                for i, idx in enumerate(non_black_indices):\n                    output_grid[row, -len(non_black_indices) + i] = line[idx]\n        elif cohesion_mode == 'cohesive':\n            blocks = find_connected_components(input_grid, background=Color.BLACK)\n            for block in blocks:\n                while not collision(object1=block, object2=output_grid, x1=1):\n                    block = translate(block, 1, 0)\n                blit_object(output_grid, block)\n\n    return output_grid\n\n\ndef generate_input():\n    # Randomly determine dimensions for the grid\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n\n    # Create a grid with a row for gravity direction and cohesion mode\n    grid = np.full((n+1, m), Color.BLACK, dtype=int)\n\n    # Randomly choose gravity direction and cohesion mode\n    gravity_direction = np.random.choice(['down', 'up', 'left', 'right'])\n    cohesion_mode = np.random.choice(['per-column', 'cohesive'])\n\n    # Encode gravity direction and cohesion mode in the first row\n    grid[0, 0] = gravity_direction\n    grid[0, 1] = cohesion_mode\n\n    # Fill in the rest of the grid with random colors\n    for _ in range(np.random.randint(5, 15)):\n        color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(1, 1, color_palette=[color])\n        x, y = random_free_location_for_sprite(grid[1:], sprite, background=Color.BLACK)\n        blit_sprite(grid[1:], sprite, x, y)\n\n    return grid"], "seeds": ["f15e1fac.py", "1caeab9d.py", "017c7c7b.py", "4093f84a.py", "Concepts: \ngravity simulation, directional movement, cohesion modes, collision detection\n\nDescription: \nInput consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, translation, erasure, rotation, grid manipulation\n\n# description:\n# Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0).\n# Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates.\n# Additionally, apply a 90-degree clockwise rotation to the object before placing it at the new location.\n# Redraw the object at the new position, preserving its rotated shape and color. The output grid reflects the object moved to the new location with its original position cleared.\n\ndef main(input_grid):\n    # Identify all objects in the grid; assuming only one object needs manipulation\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n    assert len(objects) == 1, \"There should be exactly one object in the input grid.\"\n    obj = objects[0]\n\n    # Get the bounding box of the object\n    x, y, width, height = bounding_box(obj)\n\n    # Erase the object in the input grid by setting it to the background color (0)\n    input_grid[x:x+width, y:y+height] = Color.BLACK\n\n    # Crop the object to get its sprite representation\n    sprite = crop(obj, background=Color.BLACK)\n\n    # Rotate the sprite 90 degrees clockwise\n    rotated_sprite = np.rot90(sprite, k=-1)\n\n    # Determine a new position for the object\n    new_x, new_y = np.random.randint(0, input_grid.shape[0] - rotated_sprite.shape[0]), np.random.randint(0, input_grid.shape[1] - rotated_sprite.shape[1])\n\n    # Check if the new position is free\n    if collision(object1=input_grid, object2=rotated_sprite, x2=new_x, y2=new_y, background=Color.BLACK):\n        raise ValueError(\"No free space for the rotated object. Try again.\")\n\n    # Blit the rotated object to the new position\n    blit_sprite(input_grid, rotated_sprite, new_x, new_y, background=Color.BLACK)\n\n    return input_grid\n\ndef generate_input():\n    # Create an empty grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random sprite (object) to place on the grid\n    sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=Color.NOT_BLACK, connectivity=4)\n\n    # Find a free location for the sprite and place it there\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, translation, erasure, grid manipulation\n\n# description:\n# Identify a single connected component (object) within the input grid.\n# Determine its bounding box and erase the object by setting its pixels to the background color (0).\n# Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates.\n# Redraw the object at the new position, preserving its shape and color.\n# The output grid reflects the object moved to the new location with its original position cleared.\n\ndef main(input_grid):\n    # Extract the object from the input grid. Assume only one object is present.\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8, background=Color.BLACK)\n\n    # Assume there's exactly one object\n    assert len(objects) == 1\n    obj = objects[0]\n\n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n    # Create an output grid initialized as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Erase the object from its original position\n    output_grid[x:x+width, y:y+height] = Color.BLACK\n\n    # Determine a new position for the object. For simplicity, move it to the top left corner.\n    new_x, new_y = 0, 0\n\n    # Translate the object to the new position\n    translated_obj = translate(obj, new_x - x, new_y - y, background=Color.BLACK)\n\n    # Redraw the object at the new position\n    blit_object(output_grid, translated_obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a single random object\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random sprite (object)\n    sprite_width, sprite_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite = random_sprite(sprite_width, sprite_height, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n\n    # Place the sprite at a random location on the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, translation, erasure, grid manipulation\n\n# description:\n# Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0).\n# Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates.\n# Redraw the object at the new position, preserving its shape and color.\n# The output grid reflects the object moved to the new location with its original position cleared.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Assume there's only one object for this puzzle\n    assert len(objects) == 1\n    obj = objects[0]\n\n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n    # Erase the object from its original position\n    output_grid[x:x+width, y:y+height] = Color.BLACK\n\n    # Translate the object to a new random position\n    new_x, new_y = np.random.randint(0, input_grid.shape[0] - width), np.random.randint(0, input_grid.shape[1] - height)\n\n    # Blit the object at the new position\n    blit_sprite(output_grid, crop(obj, background=Color.BLACK), new_x, new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random object (sprite) with random color\n    color_palette = list(Color.NOT_BLACK)\n    sprite = random_sprite(np.random.randint(3, 5), np.random.randint(3, 5), color_palette=color_palette, background=Color.BLACK)\n\n    # Find a random free location for the sprite\n    x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=0)\n\n    # Place the sprite on the grid\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, translation, erasure, grid manipulation\n\n# description:\n# Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0).\n# Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates.\n# Redraw the object at the new position, preserving its shape and color. The output grid reflects the object moved to the new location with its original position cleared.\n\ndef main(input_grid, new_position):\n    # Plan:\n    # 1. Extract the single object from the input grid\n    # 2. Calculate the bounding box of the object\n    # 3. Erase the object from its original position\n    # 4. Move the object to the new position\n    # 5. Return the modified grid\n\n    background_color = Color.BLACK\n\n    # Extract the connected component (object) from the input grid\n    objects = find_connected_components(input_grid, background=background_color, connectivity=4, monochromatic=False)\n    assert len(objects) == 1, \"There should be exactly one object in the input grid.\"\n\n    # Get the object and its bounding box\n    obj = objects[0]\n    x, y, width, height = bounding_box(obj, background=background_color)\n\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Erase the object from its original position\n    output_grid[x:x + width, y:y + height] = background_color\n\n    # Calculate the new position to translate the object to\n    new_x, new_y = new_position\n\n    # Translate the object and blit it onto the output grid at the new position\n    translated_obj = translate(obj, new_x - x, new_y - y, background=background_color)\n    blit_object(output_grid, translated_obj, background=background_color)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a single random object\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random sprite (object)\n    sprite_width, sprite_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n    sprite = random_sprite(sprite_width, sprite_height, color_palette=[sprite_color], background=Color.BLACK)\n\n    # Find a random free location for the sprite on the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n\n    # Blit the sprite onto the grid\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Determine a new random position for the object to be moved to\n    new_x, new_y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n\n    return grid, (new_x, new_y)", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, rotation, grid manipulation\n\n# description:\n# Identify a single connected component (object) within the input grid. Determine its bounding box and rotate the object 90 degrees clockwise around its center.\n# The output grid reflects the object rotated in place.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the connected component (object) within the grid.\n    # 2. Crop the object to isolate it.\n    # 3. Rotate the cropped object 90 degrees clockwise.\n    # 4. Place the rotated object back onto the grid in its original position.\n\n    background = Color.BLACK\n    \n    # Identify the connected component.\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background)\n    \n    # There should only be one object in the grid.\n    assert len(objects) == 1\n    obj = objects[0]\n    \n    # Crop the object to get a sprite.\n    sprite = crop(obj, background=background)\n    \n    # Rotate the sprite 90 degrees clockwise.\n    rotated_sprite = np.rot90(sprite, k=-1)\n    \n    # Get the position of the object within the grid.\n    x, y = object_position(obj, background=background)\n    \n    # Create an output grid.\n    output_grid = np.copy(input_grid)\n    \n    # Fill the original position with the background color to clear it.\n    blit_sprite(output_grid, np.full(sprite.shape, background), x, y, background=background)\n    \n    # Place the rotated object back onto the grid.\n    blit_sprite(output_grid, rotated_sprite, x, y, background=background)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions.\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate a random object (sprite).\n    sprite = random_sprite(n=np.random.randint(3, 5), m=np.random.randint(3, 5), color_palette=Color.NOT_BLACK, background=Color.BLACK, connectivity=4)\n    \n    # Find a random free location to place the sprite onto the grid.\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n    \n    # Place the sprite onto the grid.\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, symmetry, grid manipulation\n\n# description:\n# The input grid contains objects of different colors. Each object should be reflected across a specified axis of symmetry (horizontal or vertical) that goes through the center of the grid.\n# The output grid should display the reflected objects while preserving the original objects' colors and shapes.\n\ndef main(input_grid):\n    # Create an output grid of the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Randomly decide the axis of symmetry: 0 for horizontal, 1 for vertical\n    axis_of_symmetry = np.random.choice([0, 1])\n\n    # Reflect objects across the chosen axis of symmetry\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    for obj in objects:\n        # Find the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n        # Determine reflection based on the axis of symmetry\n        if axis_of_symmetry == 0:  # Horizontal reflection\n            # Flip the object vertically\n            reflected_obj = np.flipud(obj)\n            # Calculate new position\n            new_x = 2 * (input_grid.shape[0] // 2) - x - height\n            new_y = y\n        else:  # Vertical reflection\n            # Flip the object horizontally\n            reflected_obj = np.fliplr(obj)\n            # Calculate new position\n            new_x = x\n            new_y = 2 * (input_grid.shape[1] // 2) - y - width\n\n        # Place the reflected object onto the output grid\n        blit_object(output_grid, translate(reflected_obj, new_x - x, new_y - y, background=Color.BLACK), background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a random size between 10x10 and 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of objects (2 to 5)\n    num_objects = np.random.randint(2, 6)\n    for _ in range(num_objects):\n        # Create a random object with random size and color\n        obj_width, obj_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        color = random.choice(Color.NOT_BLACK)\n        obj = np.full((obj_width, obj_height), color)\n\n        # Find a random free location for the object and place it on the grid\n        x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=1)\n        blit_sprite(grid, obj, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, translation, erasure, grid manipulation\n\n# description:\n# Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0).\n# Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates.\n# Redraw the object at the new position, preserving its shape and color. The output grid reflects the object moved to the new location with its original position cleared.\n\ndef main(input_grid):\n    # Create a copy of the input grid for manipulation\n    output_grid = np.copy(input_grid)\n    \n    # Identify connected components in the grid\n    objects = find_connected_components(output_grid, background=Color.BLACK, monochromatic=True, connectivity=8)\n    \n    # Assume there is only one object\n    assert len(objects) == 1\n    obj = objects[0]\n    \n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n    \n    # Erase the object from its original position\n    output_grid[x:x+width, y:y+height] = Color.BLACK\n    \n    # Translate the object to a new position\n    new_x, new_y = np.random.randint(0, output_grid.shape[0] - width), np.random.randint(0, output_grid.shape[1] - height)\n    \n    # Create a cropped version of the object to be redrawn\n    sprite = crop(obj, background=Color.BLACK)\n    \n    # Redraw the object at the new position\n    blit_sprite(output_grid, sprite, new_x, new_y, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate a random sprite (object) with random dimensions and color\n    width, height = np.random.randint(3, 5), np.random.randint(3, 5)\n    color = random.choice(list(Color.NOT_BLACK))\n    sprite = random_sprite(width, height, color_palette=[color], background=Color.BLACK)\n    \n    # Find a random free location for the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n    \n    # Place the sprite onto the grid\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, translation, erasure, grid manipulation\n\n# description:\n# Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0).\n# Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates.\n# Redraw the object at the new position, preserving its shape and color. The output grid reflects the object moved to the new location with its original position cleared.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the connected component (object).\n    # 2. Determine the object's bounding box.\n    # 3. Erase the object by setting its pixels to the background color.\n    # 4. Calculate a new random position to translate the object.\n    # 5. Translate and redraw the object at the new position on the grid.\n\n    # Find the connected component in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Assuming only one object exists in the grid\n    obj = components[0]\n\n    # Determine the object's bounding box\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n    \n    # Erase the object from its original position\n    input_grid[x:x+width, y:y+height] = Color.BLACK\n\n    # Determine a new position for the object\n    new_x, new_y = random_free_location_for_sprite(input_grid, crop(obj), background=Color.BLACK, border_size=1)\n\n    # Translate and redraw the object at the new position\n    translated_object = translate(obj, new_x - x, new_y - y, background=Color.BLACK)\n    blit_object(input_grid, translated_object, background=Color.BLACK)\n\n    return input_grid\n\n\ndef generate_input():\n    # Create an empty grid with a random size between 10x10 and 20x20\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random connected component with dimensions between 3x3 and 5x5\n    width, height = np.random.randint(3, 6, size=2)\n    sprite = random_sprite(width, height, density=0.7, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n\n    # Place the sprite randomly on the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid"], "seeds": ["137eaa0f.py", "44d8ac46.py", "b527c5c6.py", "1f642eb9.py", "Concepts: \nobject identification, translation, erasure, grid manipulation\n\nDescription: \nIdentify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0). Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates. Redraw the object at the new position, preserving its shape and color. The output grid reflects the object moved to the new location with its original position cleared."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# Input is a 3-pixel L-shaped triomino on a 2x2 grid. Identify which of the four corners\n# (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape. Output the\n# orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner.\n# The grid may contain noise, but the L-shape is dominant.\n\ndef main(input_grid):\n    # Identify the location of the non-background pixels\n    non_background_coords = np.argwhere(input_grid != Color.BLACK)\n    \n    # Determine which corner is missing by checking the coordinates\n    corners = {\n        \"tl\": (0, 0),\n        \"tr\": (0, 1),\n        \"bl\": (1, 0),\n        \"br\": (1, 1)\n    }\n    \n    # Find the missing corner by checking which one is not part of the non-background coordinates\n    for corner, coord in corners.items():\n        if tuple(coord) not in map(tuple, non_background_coords):\n            missing_corner = corner\n            break\n    \n    # Create the output grid with the orientation text\n    output_grid = np.array([[missing_corner]], dtype=object)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 2x2 grid filled with the background color\n    grid = np.full((2, 2), Color.BLACK, dtype=int)\n\n    # Randomly select one of the four possible L-shape orientations\n    orientations = {\n        \"tl\": [(0, 1), (1, 0), (1, 1)],\n        \"tr\": [(0, 0), (1, 0), (1, 1)],\n        \"bl\": [(0, 0), (0, 1), (1, 1)],\n        \"br\": [(0, 0), (0, 1), (1, 0)]\n    }\n    chosen_orientation = np.random.choice(list(orientations.keys()))\n\n    # Fill in the L-shape on the grid with a random color from the palette\n    color = np.random.choice(list(Color.NOT_BLACK))\n    for coord in orientations[chosen_orientation]:\n        grid[coord[0], coord[1]] = color\n\n    # Optionally add some noise on the grid, but ensure L-shape is dominant\n    noise_density = np.random.uniform(0, 0.1)  # Small chance of noise\n    if np.random.rand() < noise_density:\n        noise_coords = np.random.choice(4, size=int(noise_density * 4), replace=False)\n        for coord in noise_coords:\n            x, y = divmod(coord, 2)\n            if grid[x, y] == Color.BLACK:  # Only add noise to empty spaces\n                grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# The input is a 3-pixel L-shaped triomino on a 2x2 grid.\n# Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape.\n# Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner.\n# The grid may contain noise, but the L-shape is dominant.\n\ndef main(input_grid):\n    # Define the potential corners for L-shape detection\n    corners = {\n        'tl': [(0, 1), (1, 0), (1, 1)],\n        'tr': [(0, 0), (1, 0), (1, 1)],\n        'bl': [(0, 0), (0, 1), (1, 1)],\n        'br': [(0, 0), (0, 1), (1, 0)],\n    }\n    \n    # Find occupied positions in the input grid\n    occupied_positions = set(zip(*np.where(input_grid != Color.BLACK)))\n    \n    # Compare occupied positions with known L-shape positions to find the missing corner\n    for corner, positions in corners.items():\n        if occupied_positions == set(positions):\n            return np.array([[corner]])\n    \n    return np.array([[\"unknown\"]])  # Default case if something goes wrong\n\ndef generate_input():\n    # Initialize a 2x2 grid\n    grid = np.zeros((2, 2), dtype=int)\n    \n    # Randomly select one of the four L-shape configurations\n    l_shape_types = ['tl', 'tr', 'bl', 'br']\n    selected_l_shape = np.random.choice(l_shape_types)\n    \n    # Define the L-shape positions for each corner\n    l_shape_positions = {\n        'tl': [(0, 1), (1, 0), (1, 1)],\n        'tr': [(0, 0), (1, 0), (1, 1)],\n        'bl': [(0, 0), (0, 1), (1, 1)],\n        'br': [(0, 0), (0, 1), (1, 0)],\n    }\n    \n    # Fill the grid according to the selected L-shape\n    for x, y in l_shape_positions[selected_l_shape]:\n        grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n        \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# Input is a 3-pixel L-shaped triomino on a 2x2 grid. Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape. Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner. The grid may contain noise, but the L-shape is dominant.\n\ndef main(input_grid):\n    # Define the coordinates for the four corners\n    corners = {'tl': (0, 0), 'tr': (0, 1), 'bl': (1, 0), 'br': (1, 1)}\n    \n    # Determine which corner is missing from the L-shape\n    for corner, (x, y) in corners.items():\n        if input_grid[x, y] == Color.BLACK:\n            return np.array([[corner]])\n    \n    raise ValueError(\"No missing corner detected, input is invalid.\")\n\ndef generate_input():\n    # Create a 2x2 grid full of black color (indicating empty)\n    grid = np.full((2, 2), Color.BLACK, dtype=int)\n    \n    # Randomly choose one corner to leave empty\n    corners = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    missing_corner = random.choice(corners)\n    \n    # Fill the other three corners with random colors from the available palette\n    for x, y in corners:\n        if (x, y) != missing_corner:\n            grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# In the input, you will see a 2x2 grid with a 3-pixel L-shaped triomino.\n# Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape.\n# Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner.\n# The grid may contain noise, but the L-shape is dominant.\n\ndef main(input_grid):\n    # Identify which corner is missing in the L-shape\n    corner_positions = {\n        \"tl\": (0, 0),\n        \"tr\": (0, 1),\n        \"bl\": (1, 0),\n        \"br\": (1, 1)\n    }\n    \n    # Find the location of the pixels in the L-shape\n    occupied_positions = np.argwhere(input_grid != Color.BLACK)\n    \n    # Generate a set of possible L-shape positions based on occupied positions\n    occupied_set = set(tuple(pos) for pos in occupied_positions)\n    \n    # Check which corner is missing\n    for corner, pos in corner_positions.items():\n        if pos not in occupied_set:\n            return np.array([[corner]])\n    \n    raise ValueError(\"No valid L-shape detected.\")\n\ndef generate_input():\n    # Create a 2x2 grid\n    grid = np.full((2, 2), Color.BLACK, dtype=int)\n    \n    # Choose a random missing corner for the L-shape\n    missing_corner = np.random.choice([\"tl\", \"tr\", \"bl\", \"br\"])\n    \n    # Define the L-shape positions based on the missing corner\n    l_shape_positions = {\n        \"tl\": [(0, 1), (1, 0), (1, 1)],\n        \"tr\": [(0, 0), (1, 0), (1, 1)],\n        \"bl\": [(0, 0), (0, 1), (1, 1)],\n        \"br\": [(0, 0), (0, 1), (1, 0)]\n    }\n    \n    # Fill in the L-shape on the grid with a random color\n    color = np.random.choice(list(Color.NOT_BLACK))\n    for pos in l_shape_positions[missing_corner]:\n        grid[pos] = color\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# The input is a 2x2 grid containing a dominant L-shaped triomino (3 pixels).\n# The grid has noise, but the L-shape is clearly discernible.\n# Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape.\n# Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner.\n\ndef main(input_grid):\n    # Count the number of non-black pixels in each corner\n    top_left = input_grid[0, 0] != Color.BLACK\n    top_right = input_grid[0, 1] != Color.BLACK\n    bottom_left = input_grid[1, 0] != Color.BLACK\n    bottom_right = input_grid[1, 1] != Color.BLACK\n    \n    # Use the pattern of occupied corners to determine the missing corner\n    if not top_left:\n        return np.array([[\"tl\"]], dtype=object)\n    elif not top_right:\n        return np.array([[\"tr\"]], dtype=object)\n    elif not bottom_left:\n        return np.array([[\"bl\"]], dtype=object)\n    elif not bottom_right:\n        return np.array([[\"br\"]], dtype=object)\n\ndef generate_input():\n    # Create a 2x2 grid with an L-shaped triomino\n    grid = np.full((2, 2), Color.BLACK, dtype=int)\n    \n    # Choose which corner will be missing (i.e., not part of the L-shape)\n    missing_corner = np.random.choice([\"tl\", \"tr\", \"bl\", \"br\"])\n    \n    # Fill the L-shape into the grid based on the missing corner\n    if missing_corner != \"tl\":\n        grid[0, 0] = np.random.choice(list(Color.NOT_BLACK))\n    if missing_corner != \"tr\":\n        grid[0, 1] = np.random.choice(list(Color.NOT_BLACK))\n    if missing_corner != \"bl\":\n        grid[1, 0] = np.random.choice(list(Color.NOT_BLACK))\n    if missing_corner != \"br\":\n        grid[1, 1] = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Introduce some noise by randomly changing one cell to another color\n    # if there is a free cell to introduce noise\n    if missing_corner == \"tl\":\n        grid[1, 1] = np.random.choice(list(Color.NOT_BLACK))\n    elif missing_corner == \"tr\":\n        grid[1, 0] = np.random.choice(list(Color.NOT_BLACK))\n    elif missing_corner == \"bl\":\n        grid[0, 1] = np.random.choice(list(Color.NOT_BLACK))\n    elif missing_corner == \"br\":\n        grid[0, 0] = np.random.choice(list(Color.NOT_BLACK))\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# The input is a 2x2 grid with a dominant L-shaped triomino and some possible noise.\n# The output should be a 1x1 grid with a pixel corresponding to the missing corner of the L-shape:\n# \"tl\" for top-left, \"tr\" for top-right, \"bl\" for bottom-left, or \"br\" for bottom-right.\n\ndef main(input_grid):\n    # Define the possible L-shape configurations\n    l_shapes = {\n        \"tl\": np.array([[0, 1], [1, 1]]),\n        \"tr\": np.array([[1, 0], [1, 1]]),\n        \"bl\": np.array([[1, 1], [0, 1]]),\n        \"br\": np.array([[1, 1], [1, 0]])\n    }\n    \n    # Detect the L-shape by matching the dominant pattern\n    for orientation, pattern in l_shapes.items():\n        if np.array_equal((input_grid != 0).astype(int), pattern):\n            return np.array([[orientation]])\n\ndef generate_input():\n    # Create a noise-infested 2x2 grid with a dominant L-shape\n    background_color = Color.BLACK\n    colors = list(Color.NOT_BLACK)\n    \n    # Randomly choose an L-shape orientation\n    orientation = np.random.choice([\"tl\", \"tr\", \"bl\", \"br\"])\n    \n    # Create a blank 2x2 grid\n    grid = np.full((2, 2), background_color)\n    \n    # Define the L-shape patterns\n    l_patterns = {\n        \"tl\": [(0, 1), (1, 0), (1, 1)],\n        \"tr\": [(0, 0), (1, 0), (1, 1)],\n        \"bl\": [(0, 0), (0, 1), (1, 1)],\n        \"br\": [(0, 0), (0, 1), (1, 0)]\n    }\n    \n    # Add the L-shape to the grid using a random non-black color\n    l_shape_color = np.random.choice(colors)\n    for x, y in l_patterns[orientation]:\n        grid[x, y] = l_shape_color\n    \n    # Add random noise (non-L-shape colors) with a low probability\n    for i in range(2):\n        for j in range(2):\n            if grid[i, j] == background_color and np.random.rand() < 0.2:\n                grid[i, j] = np.random.choice(colors)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# Input is a 3-pixel L-shaped triomino on a 2x2 grid. Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape.\n# Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner. The grid may contain noise, but the L-shape is dominant.\n\ndef main(input_grid):\n    # Find the coordinates of the colored pixels in the grid\n    non_black_coords = np.argwhere(input_grid != Color.BLACK)\n    \n    # Check for the missing corner by identifying which corner does not have a pixel\n    corners = {\n        \"tl\": (0, 0),\n        \"tr\": (0, 1),\n        \"bl\": (1, 0),\n        \"br\": (1, 1)\n    }\n    \n    # Determine the missing corner\n    for corner, coord in corners.items():\n        if not any((coord == non_black_coord).all() for non_black_coord in non_black_coords):\n            return np.array([[corner]])\n    \n    return np.array([[\"unknown\"]])  # default case, should not happen if inputs are valid\n\ndef generate_input():\n    # Create a 2x2 grid\n    grid = np.full((2, 2), Color.BLACK, dtype=int)\n    \n    # Choose one corner to be the missing corner\n    missing_corner = np.random.choice([\"tl\", \"tr\", \"bl\", \"br\"])\n    \n    # Define the L-shape by filling the grid except the chosen missing corner\n    corners = {\n        \"tl\": [(0, 1), (1, 0), (1, 1)],\n        \"tr\": [(0, 0), (1, 0), (1, 1)],\n        \"bl\": [(0, 0), (0, 1), (1, 1)],\n        \"br\": [(0, 0), (0, 1), (1, 0)]\n    }\n    \n    # Fill the grid according to the L-shape\n    fill_color = np.random.choice(list(Color.NOT_BLACK))\n    for coord in corners[missing_corner]:\n        grid[coord] = fill_color\n    \n    # Add some noise if desired (not necessary for the puzzle, but could be added to increase difficulty)\n    noise_level = np.random.choice([0, 0, 1])  # 0 or 1 extra noise pixels\n    for _ in range(noise_level):\n        x, y = np.random.randint(0, 2, size=2)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# L-shape detection, corner identification, orientation classification\n\n# description:\n# The input is a 3-pixel L-shaped triomino on a 2x2 grid. Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape. \n# Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner. The grid may contain noise, but the L-shape is dominant.\n\ndef main(input_grid):\n    # Since we know the grid is always 2x2, we can directly check the positions\n    # to determine which corner of the grid is missing from the L-shape.\n    \n    # The grid is expected to have a dominant L-shape, which means three out of the four positions should be colored.\n    positions = {\n        (0, 0): \"tl\",  # Top-left\n        (0, 1): \"tr\",  # Top-right\n        (1, 0): \"bl\",  # Bottom-left\n        (1, 1): \"br\"   # Bottom-right\n    }\n    \n    # Calculate the number of colored pixels at each position\n    colored_positions = [(i, j) for i in range(2) for j in range(2) if input_grid[i, j] != Color.BLACK]\n    \n    # Determine the missing corner\n    missing_corner = set(positions.keys()) - set(colored_positions)\n    \n    # The missing corner should be exactly one element\n    assert len(missing_corner) == 1\n    \n    # Return the orientation of the missing corner\n    missing_corner = missing_corner.pop()\n    return positions[missing_corner]\n\ndef generate_input():\n    # Create a 2x2 grid and randomly select one corner position to be the missing one\n    grid = np.full((2, 2), Color.BLACK, dtype=int)\n    \n    # Randomly choose the color for the L-shape\n    l_shape_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Define all possible L-shape configurations\n    l_shape_positions = [\n        [(0, 0), (0, 1), (1, 0)],  # Missing bottom-right\n        [(0, 0), (0, 1), (1, 1)],  # Missing bottom-left\n        [(0, 0), (1, 0), (1, 1)],  # Missing top-right\n        [(0, 1), (1, 0), (1, 1)],  # Missing top-left\n    ]\n    \n    # Randomly select an L-shape configuration\n    chosen_l_shape = np.random.choice(l_shape_positions)\n    \n    # Fill the chosen positions with the selected color\n    for (i, j) in chosen_l_shape:\n        grid[i, j] = l_shape_color\n        \n    # Optionally add some noise\n    noise_probability = 0.1  # 10% chance to add a noise pixel\n    for i in range(2):\n        for j in range(2):\n            if grid[i, j] == Color.BLACK and np.random.rand() < noise_probability:\n                grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n    \n    return grid"], "seeds": ["44f52bb0.py", "ff28f65a.py", "a8c38be5.py", "1caeab9d.py", "Concepts: \nL-shape detection, corner identification, orientation classification\n\nDescription: \nInput is a 3-pixel L-shaped triomino on a 2x2 grid. Identify which of the four corners (top-left, top-right, bottom-left, bottom-right) is unoccupied by the L-shape. Output the orientation as one of \"tl\", \"tr\", \"bl\", or \"br\" corresponding to the missing corner. The grid may contain noise, but the L-shape is dominant."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, recolor, connected components, bounding box\n\n# description:\n# Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right).\n# Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1).\n# The background and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Find the single connected object in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    assert len(objects) == 1, \"There should be exactly one connected object in the input grid\"\n    obj = objects[0]\n\n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n    # Determine the missing corner by checking which corner of the bounding box does not have any part of the object\n    corners = {\n        \"top-left\": (x, y),\n        \"top-right\": (x + width - 1, y),\n        \"bottom-left\": (x, y + height - 1),\n        \"bottom-right\": (x + width - 1, y + height - 1)\n    }\n    \n    missing_corner = None\n    for corner, (cx, cy) in corners.items():\n        if not (0 <= cx < obj.shape[1] and 0 <= cy < obj.shape[0] and obj[cy, cx] != Color.BLACK):\n            missing_corner = corner\n            break\n    \n    # Recolor the object based on the missing corner\n    color_map = {\n        \"top-left\": Color.RED,\n        \"top-right\": Color.YELLOW,\n        \"bottom-left\": Color.GREEN,\n        \"bottom-right\": Color.BLUE\n    }\n    \n    new_color = color_map[missing_corner]\n\n    # Recolor the object\n    output_grid = np.copy(input_grid)\n    flood_fill(output_grid, x, y, new_color, connectivity=8)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a single connected object\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate a random single connected object\n    obj_size = np.random.randint(4, 8)\n    obj = random_sprite(obj_size, obj_size, color_palette=[Color.GREY], connectivity=8)\n\n    # Place the object in the grid at a random location\n    x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK)\n    blit_sprite(grid, obj, x, y, background=Color.BLACK)\n\n    # Remove one corner from the placed object to introduce the orientation\n    x_offset, y_offset = np.random.choice([(0, 0), (obj.shape[1] - 1, 0), (0, obj.shape[0] - 1), (obj.shape[1] - 1, obj.shape[0] - 1)])\n    grid[y + y_offset, x + x_offset] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, orientation detection, bounding box, recoloring\n\n# description:\n# Given an input grid with a single connected object, determine its orientation by identifying the missing corner in its bounding box.\n# Recolor the object based on orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), bottom-right to blue (1).\n# The background and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Step 1: Find the connected object\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one connected object.\"\n\n    # Extract the single object\n    obj = objects[0]\n\n    # Step 2: Determine the bounding box of the object\n    x, y, w, h = bounding_box(obj, background=Color.BLACK)\n\n    # Step 3: Identify the missing corner in the bounding box\n    # Check each corner to see if it's missing from the object\n    corners = {\n        'top-left': (x, y),\n        'top-right': (x + w - 1, y),\n        'bottom-left': (x, y + h - 1),\n        'bottom-right': (x + w - 1, y + h - 1)\n    }\n    missing_corner = None\n    for corner, (cx, cy) in corners.items():\n        if obj[cy][cx] == Color.BLACK:\n            missing_corner = corner\n            break\n\n    # Step 4: Recolor the object based on the missing corner\n    color_map = {\n        'top-left': Color.RED,\n        'top-right': Color.YELLOW,\n        'bottom-left': Color.GREEN,\n        'bottom-right': Color.BLUE\n    }\n    new_color = color_map[missing_corner]\n    recolored_obj = np.where(obj != Color.BLACK, new_color, obj)\n\n    # Prepare the output grid by copying the input grid to preserve background\n    output_grid = np.copy(input_grid)\n\n    # Step 5: Blit the recolored object back onto the output grid\n    blit_object(output_grid, recolored_obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a single connected object\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a random shape and make it connected\n    shape_size = np.random.randint(3, min(grid_size, 7))\n    shape = random_sprite(shape_size, shape_size, color_palette=[Color.GREY], connectivity=8)\n\n    # Place the shape at a random location in the grid\n    x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n    blit_sprite(grid, shape, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, recolor, connected components, bounding box\n\n# description:\n# Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right).\n# Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1).\n# The background and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Extract the single connected object from the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    assert len(objects) == 1, \"There should be exactly one connected object in the input grid.\"\n    object_grid = objects[0]\n\n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(object_grid, background=Color.BLACK)\n\n    # Determine missing corner of the bounding box to find the orientation\n    top_left = (x, y)\n    top_right = (x, y + width - 1)\n    bottom_left = (x + height - 1, y)\n    bottom_right = (x + height - 1, y + width - 1)\n\n    # Determine which corner is missing\n    corners = [top_left, top_right, bottom_left, bottom_right]\n    present_corners = [corner for corner in corners if object_grid[corner] != Color.BLACK]\n    \n    # Map present corners to the missing corner\n    missing_corner_map = {\n        frozenset([top_right, bottom_left, bottom_right]): \"top-left\",\n        frozenset([top_left, bottom_left, bottom_right]): \"top-right\",\n        frozenset([top_left, top_right, bottom_right]): \"bottom-left\",\n        frozenset([top_left, top_right, bottom_left]): \"bottom-right\",\n    }\n    \n    missing_corner = missing_corner_map[frozenset(present_corners)]\n\n    # Color map based on missing corner\n    color_map = {\n        \"top-left\": Color.RED,\n        \"top-right\": Color.YELLOW,\n        \"bottom-left\": Color.GREEN,\n        \"bottom-right\": Color.BLUE\n    }\n    \n    # Recolor the object uniformly based on the missing corner\n    recolor = color_map[missing_corner]\n    flood_fill(object_grid, x, y, recolor)\n\n    # Copy the recolored object back to the original grid\n    output_grid = np.copy(input_grid)\n    blit_object(output_grid, object_grid, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with a single connected object with a missing corner\n    grid_size = np.random.randint(10, 20)\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a random sprite with a missing corner\n    sprite_size = np.random.randint(4, 8)\n    sprite = np.full((sprite_size, sprite_size), Color.TEAL)\n    \n    # Remove a random corner\n    corners = [(0, 0), (0, sprite_size - 1), (sprite_size - 1, 0), (sprite_size - 1, sprite_size - 1)]\n    missing_corner = random.choice(corners)\n    sprite[missing_corner] = Color.BLACK\n\n    # Place sprite at a random location in the grid\n    x, y = random_free_location_for_sprite(input_grid, sprite, border_size=1, padding=0)\n    blit_sprite(input_grid, sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, recolor, connected components, bounding box\n\n# description:\n# Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right). \n# Recolor the entire object uniformly based on this orientation using a fixed color map: \n# top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1). \n# The background and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Extract the single connected object from the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8, background=Color.BLACK)\n    \n    # Assume there is only one object\n    obj = objects[0]\n    \n    # Get the bounding box of the object\n    obj_x, obj_y, obj_w, obj_h = bounding_box(obj, background=Color.BLACK)\n    \n    # Determine which corner of the bounding box is missing\n    missing_corners = {\n        (0, 0): Color.RED,      # top-left\n        (0, obj_w-1): Color.YELLOW,   # top-right\n        (obj_h-1, 0): Color.GREEN,    # bottom-left\n        (obj_h-1, obj_w-1): Color.BLUE  # bottom-right\n    }\n    \n    # Check each corner to find the missing one\n    for (corner_x, corner_y), color in missing_corners.items():\n        if obj[corner_x, corner_y] == Color.BLACK:\n            orientation_color = color\n            break\n\n    # Create an output grid and fill the object with the determined color\n    output_grid = np.copy(input_grid)\n    flood_fill(output_grid, obj_x, obj_y, orientation_color, connectivity=8)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create an empty grid with a random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Create a random connected object\n    obj_size = np.random.randint(3, min(n, m)//2 + 1)\n    obj = random_sprite(obj_size, obj_size, color_palette=[Color.TEAL], connectivity=8)\n    \n    # Randomly choose a corner to remove\n    corners = [(0, 0), (0, obj_size-1), (obj_size-1, 0), (obj_size-1, obj_size-1)]\n    missing_corner = random.choice(corners)\n    obj[missing_corner] = Color.BLACK\n    \n    # Place the object randomly on the grid\n    x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK)\n    blit_sprite(grid, obj, x, y, background=Color.BLACK)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, recolor, connected components, bounding box\n\n# description:\n# The input consists of a grid containing a single connected object of any shape and color except black. \n# The task is to determine the object's orientation by finding which corner of its bounding box is missing. \n# Once the missing corner is identified (top-left, top-right, bottom-left, bottom-right), recolor the entire object using the following mapping:\n# top-left -> red (3), top-right -> yellow (4), bottom-left -> green (2), and bottom-right -> blue (1).\n# The background (black) and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Extract the connected components of the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # There should only be one connected component, which is the object\n    obj = components[0]\n\n    # Find the bounding box of the object\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n    # Determine the missing corner based on the object\u2019s position in the bounding box\n    if not np.any(obj[x:x+1, y:y+1] != Color.BLACK):\n        # Top-left corner is missing\n        fill_color = Color.RED\n    elif not np.any(obj[x:x+1, y+width-1:y+width] != Color.BLACK):\n        # Top-right corner is missing\n        fill_color = Color.YELLOW\n    elif not np.any(obj[x+height-1:x+height, y:y+1] != Color.BLACK):\n        # Bottom-left corner is missing\n        fill_color = Color.GREEN\n    elif not np.any(obj[x+height-1:x+height, y+width-1:y+width] != Color.BLACK):\n        # Bottom-right corner is missing\n        fill_color = Color.BLUE\n\n    # Recolor the object uniformly with the determined color\n    flood_fill(input_grid, x, y, fill_color, connectivity=8)\n\n    return input_grid\n\n\ndef generate_input():\n    # Create a random grid size\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a random sprite and place it at a random location\n    sprite_size = np.random.randint(4, 6)\n    sprite = random_sprite(sprite_size, sprite_size, color_palette=[random.choice(list(Color.NOT_BLACK))], connectivity=8)\n    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n\n    # Place the sprite onto the grid\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Remove one corner from the bounding box of the sprite\n    if np.random.rand() < 0.25:\n        # Remove top-left corner\n        grid[x, y] = Color.BLACK\n    elif np.random.rand() < 0.5:\n        # Remove top-right corner\n        grid[x, y + sprite_size - 1] = Color.BLACK\n    elif np.random.rand() < 0.75:\n        # Remove bottom-left corner\n        grid[x + sprite_size - 1, y] = Color.BLACK\n    else:\n        # Remove bottom-right corner\n        grid[x + sprite_size - 1, y + sprite_size - 1] = Color.BLACK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, recolor, connected components, bounding box\n\n# description:\n# Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right).\n# Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1).\n# The background and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Extract the connected object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    assert len(objects) == 1, \"There should be exactly one connected object in the input grid.\"\n    obj = objects[0]\n\n    # Find the bounding box of the object\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n    # Determine the missing corner\n    corners = {\n        \"top-left\": (x, y),\n        \"top-right\": (x, y + width - 1),\n        \"bottom-left\": (x + height - 1, y),\n        \"bottom-right\": (x + height - 1, y + width - 1),\n    }\n\n    # Check for the presence of these corners in the object\n    missing_corner = None\n    for corner, (cx, cy) in corners.items():\n        if (cx < obj.shape[0]) and (cy < obj.shape[1]) and obj[cx, cy] == Color.BLACK:\n            missing_corner = corner\n            break\n\n    # Map the missing corner to its color\n    color_map = {\n        \"top-left\": Color.RED,\n        \"top-right\": Color.YELLOW,\n        \"bottom-left\": Color.GREEN,\n        \"bottom-right\": Color.BLUE\n    }\n\n    # Recolor the object based on its missing corner\n    color = color_map[missing_corner]\n    obj[obj != Color.BLACK] = color\n\n    # Create the output grid and blit the recolored object back\n    output_grid = np.copy(input_grid)\n    blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid and define the size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate a random connected object\n    obj = random_sprite(\n        n=[3, 4, 5],\n        m=[3, 4, 5],\n        density=0.7,\n        symmetry='not_symmetric',\n        color_palette=[Color.GREY],\n        connectivity=8\n    )\n\n    obj = crop(obj, background=Color.BLACK)\n\n    # Randomly choose a corner to remove\n    corners = {\n        \"top-left\": (0, 0),\n        \"top-right\": (0, obj.shape[1] - 1),\n        \"bottom-left\": (obj.shape[0] - 1, 0),\n        \"bottom-right\": (obj.shape[0] - 1, obj.shape[1] - 1),\n    }\n    corner_to_remove = np.random.choice(list(corners.keys()))\n    cx, cy = corners[corner_to_remove]\n    obj[cx, cy] = Color.BLACK\n\n    # Place the object randomly in the grid\n    x, y = random_free_location_for_sprite(grid, obj, padding=1, padding_connectivity=8)\n    blit_sprite(grid, obj, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, recolor, connected components, bounding box\n\n# description:\n# Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right). Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1). The background and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Find the connected components\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n    \n    # We expect exactly one connected object in the grid\n    assert len(objects) == 1, \"There should be exactly one connected object in the grid.\"\n    \n    # Extract the object\n    obj = objects[0]\n    \n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj)\n    \n    # Define the corners of the bounding box\n    corners = {\n        'top-left': (x, y),\n        'top-right': (x + width - 1, y),\n        'bottom-left': (x, y + height - 1),\n        'bottom-right': (x + width - 1, y + height - 1)\n    }\n    \n    # Check which corner is missing\n    missing_corner = None\n    for corner_name, (cx, cy) in corners.items():\n        if obj[cy, cx] == Color.BLACK:  # Assuming background is black\n            missing_corner = corner_name\n            break\n    \n    # Define the color map based on the missing corner\n    color_map = {\n        'top-left': Color.RED,\n        'top-right': Color.YELLOW,\n        'bottom-left': Color.GREEN,\n        'bottom-right': Color.BLUE\n    }\n    \n    # Determine the color to fill the object\n    fill_color = color_map[missing_corner]\n    \n    # Recolor the connected object\n    output_grid = np.copy(input_grid)\n    flood_fill(output_grid, y, x, fill_color, connectivity=4)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with single connected object\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate a random monochromatic sprite\n    sprite = random_sprite(n, m, density=0.5, connectivity=4, color_palette=[Color.GREY])\n    \n    # Determine a position to blit the sprite into the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x, y)\n    \n    # Remove a corner from the sprite's bounding box\n    sx, sy, sw, sh = bounding_box(sprite)\n    corner_to_remove = np.random.choice(['top-left', 'top-right', 'bottom-left', 'bottom-right'])\n    if corner_to_remove == 'top-left':\n        sprite[sy, sx] = Color.BLACK\n    elif corner_to_remove == 'top-right':\n        sprite[sy, sx + sw - 1] = Color.BLACK\n    elif corner_to_remove == 'bottom-left':\n        sprite[sy + sh - 1, sx] = Color.BLACK\n    elif corner_to_remove == 'bottom-right':\n        sprite[sy + sh - 1, sx + sw - 1] = Color.BLACK\n    \n    # Blit the modified sprite back into the grid\n    blit_sprite(grid, sprite, x, y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# orientation detection, recolor, connected components, bounding box\n\n# description:\n# The input grid contains a single connected object. The task is to determine the object's orientation by identifying the missing corner in its bounding box:\n# top-left, top-right, bottom-left, or bottom-right. Recolor the entire object uniformly based on this orientation using a fixed color map:\n# - top-left to red (3)\n# - top-right to yellow (4)\n# - bottom-left to green (2)\n# - bottom-right to blue (1)\n# The background and any other grid content remain unchanged.\n\ndef main(input_grid):\n    # Extract the single connected object from the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    \n    # There should be exactly one object\n    assert len(objects) == 1, \"The input should contain exactly one connected object\"\n    obj = objects[0]\n    \n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj)\n    \n    # Identify the missing corner\n    missing_corners = [(x, y), (x, y + height - 1), (x + width - 1, y), (x + width - 1, y + height - 1)]\n    present_corners = set(np.argwhere(obj != Color.BLACK).tolist())\n    missing_corner = next(corner for corner in missing_corners if corner not in present_corners)\n    \n    # Map the missing corner to the appropriate color\n    orientation_to_color = {\n        (x, y): Color.RED,         # top-left\n        (x, y + height - 1): Color.YELLOW,  # top-right\n        (x + width - 1, y): Color.GREEN,   # bottom-left\n        (x + width - 1, y + height - 1): Color.BLUE    # bottom-right\n    }\n    \n    # Get the new color for the object based on its missing corner\n    new_color = orientation_to_color[missing_corner]\n    \n    # Recolor the object uniformly\n    obj[obj != Color.BLACK] = new_color\n    \n    # Create the output grid and place the recolored object\n    output_grid = np.copy(input_grid)\n    blit_object(output_grid, obj, background=Color.BLACK)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Define grid dimensions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate a random connected object with a missing corner\n    object_size = np.random.randint(3, min(n, m) // 2)\n    obj = random_sprite(object_size, object_size, density=0.7, color_palette=[Color.GREY], connectivity=8)\n    \n    # Manually remove one corner to create a missing corner effect\n    x, y, width, height = bounding_box(obj, background=Color.BLACK)\n    missing_corners = [(x, y), (x, y + height - 1), (x + width - 1, y), (x + width - 1, y + height - 1)]\n    missing_corner = np.random.choice(len(missing_corners))\n    obj[missing_corners[missing_corner]] = Color.BLACK\n    \n    # Place the object randomly in the grid\n    try:\n        x, y = random_free_location_for_sprite(grid, obj, padding=1, padding_connectivity=8)\n        blit_sprite(grid, obj, x, y, background=Color.BLACK)\n    except ValueError:\n        pass  # In rare cases, there might not be enough space; retrying the generation is recommended\n    \n    return grid"], "seeds": ["137eaa0f.py", "7447852a.py", "a8c38be5.py", "d2abd087.py", "Concepts: \norientation detection, recolor, connected components, bounding box\n\nDescription: \nInput is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right). Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1). The background and any other grid content remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# Given a grid with various colors, for each 2x2 window in the grid, check if all cells match a specified target color.\n# Return a grid of the same size where each 2x2 window is True if every cell in the window matches the target color; otherwise, False.\n# The rest of the grid is marked with Color.BLACK.\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Initialize an output grid of the same size as the input grid, filled with Color.BLACK\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Iterate over each possible 2x2 window in the grid\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            # Extract the 2x2 window\n            window = input_grid[i:i+2, j:j+2]\n\n            # Check if all elements in the window are the target color\n            if np.all(window == target_color):\n                # Mark the corresponding area in the output grid as True\n                output_grid[i:i+2, j:j+2] = True\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Define grid size, minimum size is 2x2 for a 2x2 window to fit\n    rows, cols = random.randint(5, 10), random.randint(5, 10)\n    \n    # Randomly choose a target color from available colors\n    target_color = random.choice(list(Color.ALL_COLORS))\n\n    # Create a grid with random colors\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(rows, cols))\n\n    # Ensure that there is at least one 2x2 section with the target color\n    if rows > 1 and cols > 1:\n        start_x, start_y = random.randint(0, rows - 2), random.randint(0, cols - 2)\n        grid[start_x:start_x+2, start_y:start_y+2] = target_color\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# The input is a grid with various colors. For each 2x2 window in the grid, check if all cells match a specified target color.\n# Return a grid where each 2x2 window is filled with True if every cell in the window matches the target color; otherwise, False.\n# This operation is applied to each 2x2 window independently.\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    n, m = input_grid.shape\n    # Initialize the output grid with False values\n    output_grid = np.full((n-1, m-1), False, dtype=bool)\n\n    # Iterate over each possible 2x2 window in the input grid\n    for i in range(n - 1):\n        for j in range(m - 1):\n            # Extract the 2x2 window\n            window = input_grid[i:i+2, j:j+2]\n            # Check if all elements in the window match the target color\n            if np.all(window == target_color):\n                output_grid[i, j] = True\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Generate a grid with random colors\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(n, m))\n\n    # Select a target color randomly from the color palette\n    target_color = np.random.choice(list(Color.ALL_COLORS))\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# Input is a grid with various colors. For each 2x2 window in the grid, check if all cells match a specified target color.\n# Return a grid of the same size where each 2x2 window is True if every cell matches the target color, otherwise False.\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Create a boolean output grid of the same size as input grid\n    output_grid = np.zeros_like(input_grid, dtype=bool)\n    \n    # Define the dimensions of the grid\n    rows, cols = input_grid.shape\n\n    # Iterate through each 2x2 window\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            # Extract the 2x2 window\n            window = input_grid[i:i+2, j:j+2]\n            \n            # Check if all elements in the window match the target color\n            if np.all(window == target_color):\n                # Mark the top-left corner of the 2x2 window as True\n                output_grid[i, j] = True\n    \n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Randomly choose the grid dimensions between 5x5 and 10x10\n    n, m = random.randint(5, 10), random.randint(5, 10)\n\n    # Create an empty grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a target color from the available colors (excluding black)\n    target_color = random.choice(Color.NOT_BLACK)\n\n    # Fill the grid with random colors\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = random.choice(Color.NOT_BLACK)\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# The input grid contains various colored pixels. The task is to scan the grid using a 2x2 window\n# and check if all cells in the window match a specified target color. The output will be a boolean grid\n# where True indicates that the 2x2 window matches the target color, and False otherwise.\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Initialize the output grid with False values\n    output_grid = np.full((input_grid.shape[0] - 1, input_grid.shape[1] - 1), False, dtype=bool)\n    \n    # Scan the input grid with a 2x2 window\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            # Extract the 2x2 window\n            window = input_grid[i:i+2, j:j+2]\n            \n            # Check if all cells in the window match the target color\n            if np.all(window == target_color):\n                output_grid[i, j] = True\n    \n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Define grid dimensions\n    n, m = np.random.randint(5, 10, size=2)\n    # Create a random grid with colors\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(n, m))\n    \n    # Randomly select a target color from the available colors\n    target_color = np.random.choice(list(Color.ALL_COLORS))\n    \n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# The input is a grid of various colors. For each 2x2 window in the grid, check if all cells match a specified target color.\n# The function returns a grid of the same size with True where all cells match the target color in the 2x2 window, and False otherwise.\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    output_grid = np.zeros(input_grid.shape, dtype=bool)\n    rows, cols = input_grid.shape\n    \n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            # Extract the 2x2 window\n            window = input_grid[i:i+2, j:j+2]\n            # Check if all values in the window match the target color\n            if np.all(window == target_color):\n                output_grid[i:i+2, j:j+2] = True\n                \n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    grid_size = np.random.randint(5, 10)\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(grid_size, grid_size))\n\n    # Randomly select a target color from the available color palette\n    target_color = np.random.choice(list(Color.ALL_COLORS))\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# The input grid contains various colors. For each 2x2 window in the grid, check if all cells match a specified target color.\n# Return a grid of the same size with True if every cell in the window matches the target color; otherwise, return False.\n# This operation is applied to each 2x2 window independently, resulting in a grid indicating which 2x2 windows are homogeneous in color.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Determine the size of the grid\n    rows, cols = input_grid.shape\n    # Initialize the output grid of same size with False values\n    output_grid = np.zeros((rows, cols), dtype=bool)\n    \n    # Specify the target color to match\n    target_color = Color.RED  # Example target color; this can be any color from Color.ALL_COLORS\n\n    # Iterate through each possible 2x2 window in the grid\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            # Extract the current 2x2 window\n            window = input_grid[i:i+2, j:j+2]\n            # Check if all cells in the window match the target color\n            if np.all(window == target_color):\n                # If they match, set the corresponding cells in the output grid to True\n                output_grid[i:i+2, j:j+2] = True\n\n    return output_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Randomly select the grid size\n    rows, cols = random.randint(5, 10), random.randint(5, 10)\n    # Create a grid of random colors\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(rows, cols))\n    \n    # Randomly choose some 2x2 regions to be homogeneous and match the target color\n    for _ in range(random.randint(1, 5)):\n        # Select a random starting position for the 2x2 window\n        i, j = random.randint(0, rows - 2), random.randint(0, cols - 2)\n        # Set a random target color from the available colors\n        target_color = random.choice(list(Color.NOT_BLACK))\n        # Make the 2x2 window homogeneous\n        grid[i:i+2, j:j+2] = target_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# The input is a grid with various colors. For each 2x2 window in the grid, check if all cells match a specified target color.\n# Return True if every cell in the window matches the target color; otherwise, return False. This operation is applied to each 2x2 window independently.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Target color to check in 2x2 windows\n    target_color = Color.RED  # You can change this to any color you want to test against\n\n    # Create an output grid initialized to False\n    output_grid = np.full((input_grid.shape[0]-1, input_grid.shape[1]-1), False, dtype=bool)\n\n    # Iterate over each possible 2x2 window in the grid\n    for x in range(input_grid.shape[0] - 1):\n        for y in range(input_grid.shape[1] - 1):\n            # Extract the 2x2 window\n            window = input_grid[x:x+2, y:y+2]\n            \n            # Check if all elements in the window match the target color\n            if np.all(window == target_color):\n                output_grid[x, y] = True\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Randomly determine the grid size\n    grid_size = np.random.randint(5, 10)\n    \n    # Initialize an empty grid\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly populate the grid with colors\n    for x in range(grid_size):\n        for y in range(grid_size):\n            grid[x, y] = np.random.choice(list(Color.ALL_COLORS))\n\n    return grid", "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# window scanning, color matching, pattern detection\n\n# description:\n# The input grid is filled with various colors. For each 2x2 window in the grid, check if all cells match a specified target color.\n# If every cell in the window matches the target color, return True; otherwise, return False for that window.\n# The output is a boolean grid where each cell corresponds to a 2x2 window in the input grid.\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Determine the dimensions of the input grid\n    rows, cols = input_grid.shape\n    \n    # Initialize an output grid of size (rows-1) x (cols-1) to store boolean results for each 2x2 window\n    output_grid = np.zeros((rows-1, cols-1), dtype=bool)\n    \n    # Iterate over each possible top-left corner of a 2x2 window\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            # Extract the 2x2 window\n            window = input_grid[i:i+2, j:j+2]\n            # Check if all elements in the window match the target color\n            if np.all(window == target_color):\n                output_grid[i, j] = True\n    \n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Randomly determine the size of the grid\n    n = random.randint(5, 10)\n    m = random.randint(5, 10)\n    \n    # Create a grid of size n x m with random colors\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(n, m))\n    \n    # Randomly select a target color from the available colors\n    target_color = random.choice(list(Color.ALL_COLORS))\n    \n    return grid, target_color"], "seeds": ["06df4c85.py", "00d62c1b.py", "ff28f65a.py", "239be575.py", "Concepts: \nwindow scanning, color matching, pattern detection\n\nDescription: \nInput is a grid with various colors. For each 2x2 window in the grid, check if all cells match a specified target color. Return True if every cell in the window matches the target color; otherwise, return False. This operation is applied to each 2x2 window independently."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# Starting from a seed pixel, create a diagonal zigzag pattern by alternating between horizontal and vertical movements.\n# Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step),\n# painting each traversed pixel. Continue this alternating pattern until reaching the grid boundary. The result is a\n# staircase-like diagonal composed of axis-aligned segments.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the seed pixel in the input grid.\n    # 2. Create a diagonal zigzag pattern starting from the seed pixel.\n    # 3. Alternate between horizontal and vertical movements, painting the path, until reaching the boundary.\n\n    # Extract the seed pixel\n    seed_pixel = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)[0]\n    seed_x, seed_y = object_position(seed_pixel, background=Color.BLACK)\n    seed_color = object_colors(seed_pixel)[0]\n\n    # Define the steps for horizontal and vertical movements\n    horizontal_step = 3\n    vertical_step = 2\n\n    # Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    width, height = input_grid.shape\n\n    # Starting from the seed pixel, create the zigzag pattern\n    x, y = seed_x, seed_y\n    move_horizontal = True\n\n    while 0 <= x < width and 0 <= y < height:\n        output_grid[x, y] = seed_color\n\n        if move_horizontal:\n            # Draw a horizontal line\n            end_x = min(x + horizontal_step, width)\n            draw_line(output_grid, x=x, y=y, end_x=end_x, color=seed_color)\n            x = end_x - 1  # Move to the end of the line\n        else:\n            # Draw a vertical line\n            end_y = min(y + vertical_step, height)\n            draw_line(output_grid, x=x, y=y, end_y=end_y, color=seed_color)\n            y = end_y - 1  # Move to the end of the line\n\n        # Alternate the movement direction\n        move_horizontal = not move_horizontal\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a color for the seed pixel\n    seed_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the seed pixel somewhere in the grid\n    x = np.random.randint(0, width)\n    y = np.random.randint(0, height)\n    grid[x, y] = seed_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# In the input, you will see a grid with a single colored seed pixel.\n# To make the output, you should draw a diagonal zigzag pattern starting from the seed pixel by alternating between horizontal and vertical movements.\n# Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step), painting each traversed pixel.\n# Continue this alternating pattern until reaching the grid boundary, resulting in a staircase-like diagonal composed of axis-aligned segments.\n\ndef main(input_grid):\n    # Output grid is the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect the seed pixel\n    seed_pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    seed_color = object_colors(seed_pixel)[0]\n    seed_x, seed_y = object_position(seed_pixel)\n\n    # Define fixed steps for horizontal and vertical movements\n    horizontal_step = 3\n    vertical_step = 2\n\n    # Initialize current position\n    current_x, current_y = seed_x, seed_y\n\n    # Draw the zigzag pattern\n    while True:\n        # Move horizontally\n        for _ in range(horizontal_step):\n            if 0 <= current_x < output_grid.shape[0]:\n                output_grid[current_x, current_y] = seed_color\n                current_x += 1\n            else:\n                break\n        \n        # Move vertically\n        for _ in range(vertical_step):\n            if 0 <= current_y < output_grid.shape[1]:\n                output_grid[current_x, current_y] = seed_color\n                current_y += 1\n            else:\n                break\n        \n        # Stop if out of bounds\n        if current_x >= output_grid.shape[0] or current_y >= output_grid.shape[1]:\n            break\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose a color for the seed pixel\n    seed_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the seed pixel within the grid\n    seed_x = np.random.randint(0, width)\n    seed_y = np.random.randint(0, height)\n    grid[seed_x, seed_y] = seed_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# From a seed pixel, create a diagonal zigzag pattern by alternating between horizontal and vertical movements.\n# Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step), painting each traversed pixel.\n# Continue this alternating pattern until reaching the grid boundary, forming a staircase-like diagonal.\n\ndef main(input_grid):\n    # Output grid is the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the seed pixel\n    seed_pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    seed_color = object_colors(seed_pixel)[0]\n    seed_x, seed_y = object_position(seed_pixel)\n\n    # Define step sizes\n    horizontal_step = 3\n    vertical_step = 2\n\n    # Start creating the zigzag pattern\n    x, y = seed_x, seed_y\n    width, height = output_grid.shape\n\n    while x < width and y < height:\n        # Draw horizontal line\n        end_x = min(x + horizontal_step, width)\n        draw_line(output_grid, x, y, end_x=end_x, direction=(1, 0), color=seed_color)\n        x = end_x\n\n        # Draw vertical line\n        end_y = min(y + vertical_step, height)\n        draw_line(output_grid, x - 1, y, end_y=end_y, direction=(0, 1), color=seed_color)\n        y = end_y\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose a color for the seed pixel\n    seed_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the seed pixel within the grid\n    x = np.random.randint(0, width)\n    y = np.random.randint(0, height)\n    grid[x, y] = seed_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# In the input, you will see a grid with a single seed pixel of a random color.\n# To make the output, create a diagonal zigzag pattern starting from the seed pixel. \n# Alternate between horizontal and vertical movements, moving horizontally by a fixed number of pixels (horizontal_step), \n# then vertically by another fixed number (vertical_step), painting each traversed pixel. \n# Continue this alternating pattern until reaching the grid boundary, creating a staircase-like diagonal composed of axis-aligned segments.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the seed pixel and its color\n    # 2. Initialize the output grid\n    # 3. Create the zigzag pattern starting from the seed pixel\n\n    # 1. Identify the seed pixel\n    seed_component = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)[0]\n    seed_x, seed_y = object_position(seed_component, background=Color.BLACK)\n    seed_color = object_colors(seed_component)[0]\n\n    # 2. Initialize the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    width, height = input_grid.shape\n\n    # 3. Create the zigzag pattern\n    horizontal_step = 3\n    vertical_step = 2\n    x, y = seed_x, seed_y\n    direction = 1  # 1 for right and down, -1 for left and up\n    while 0 <= x < width and 0 <= y < height:\n        # Move horizontally\n        for _ in range(horizontal_step):\n            if 0 <= x < width and 0 <= y < height:\n                output_grid[x, y] = seed_color\n                x += direction\n            else:\n                break\n        \n        # Move vertically\n        for _ in range(vertical_step):\n            if 0 <= x < width and 0 <= y < height:\n                output_grid[x, y] = seed_color\n                y += direction\n            else:\n                break\n\n        # Flip direction after each zigzag\n        direction *= -1\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a color for the seed\n    seed_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the seed pixel at a random location\n    seed_x = np.random.randint(0, width)\n    seed_y = np.random.randint(0, height)\n    grid[seed_x, seed_y] = seed_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# In the input, you will see a grid with a single colored seed pixel.\n# To make the output, start from the seed pixel and create a diagonal zigzag pattern by alternating between horizontal and vertical movements.\n# Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step),\n# painting each traversed pixel. Continue this alternating pattern until reaching the grid boundary, creating a staircase-like diagonal composed of axis-aligned segments.\n\ndef main(input_grid):\n    # Identify the seed pixel\n    seed_pixel = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)[0]\n    seed_x, seed_y = object_position(seed_pixel, background=Color.BLACK)\n    seed_color = object_colors(seed_pixel, background=Color.BLACK)[0]\n\n    # Define the steps for horizontal and vertical movements\n    horizontal_step = 3\n    vertical_step = 2\n\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n\n    # Start the zigzag pattern from the seed pixel\n    current_x, current_y = seed_x, seed_y\n    direction = 1  # 1 for moving right and down, -1 for moving left and up\n\n    while 0 <= current_x < output_grid.shape[0] and 0 <= current_y < output_grid.shape[1]:\n        # Move horizontally\n        for _ in range(horizontal_step):\n            if 0 <= current_x < output_grid.shape[0]:\n                output_grid[current_x, current_y] = seed_color\n                current_x += direction\n            else:\n                break\n\n        # Move vertically\n        for _ in range(vertical_step):\n            if 0 <= current_y < output_grid.shape[1]:\n                output_grid[current_x, current_y] = seed_color\n                current_y += direction\n            else:\n                break\n\n        # Change direction for the next zigzag\n        direction *= -1\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose a color for the seed pixel\n    seed_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the seed pixel within the grid\n    seed_x = np.random.randint(0, width)\n    seed_y = np.random.randint(0, height)\n    grid[seed_x, seed_y] = seed_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# In the input you will see a grid with a single colored pixel.\n# To make the output, start from this pixel and create a diagonal zigzag pattern by alternating between horizontal and vertical movements.\n# Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step),\n# painting each traversed pixel. Continue this alternating pattern until reaching the grid boundary.\n\ndef main(input_grid):\n    # Output grid is the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect the seed pixel\n    seed_pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    seed_color = object_colors(seed_pixel)[0]\n    x, y = object_position(seed_pixel)\n\n    # Define the steps for horizontal and vertical movements\n    horizontal_step = 3\n    vertical_step = 2\n\n    # Dimensions of the grid\n    max_x, max_y = input_grid.shape\n\n    # Start from the seed pixel and create the zigzag pattern\n    while x < max_x and y < max_y:\n        # Move horizontally\n        end_x = min(x + horizontal_step, max_x)\n        draw_line(output_grid, x, y, end_x=end_x, color=seed_color, direction=(1, 0))\n        x = end_x\n\n        # Move vertically\n        if x < max_x:\n            end_y = min(y + vertical_step, max_y)\n            draw_line(output_grid, x, y, end_y=end_y, color=seed_color, direction=(0, 1))\n            y = end_y\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose a color for the seed pixel\n    seed_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the seed pixel somewhere in the grid\n    x = np.random.randint(0, width)\n    y = np.random.randint(0, height)\n    grid[x, y] = seed_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# Given an input grid with a single seed pixel of a random color, create a diagonal zigzag pattern.\n# The pattern starts from the seed pixel and alternates between horizontal and vertical movements with fixed steps.\n# The pattern extends until it reaches the boundary of the grid, forming a staircase-like diagonal composed of axis-aligned segments.\n\ndef main(input_grid):\n    # Output grid is the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Locate the seed pixel\n    seed_pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    seed_color = object_colors(seed_pixel)[0]\n    seed_x, seed_y = object_position(seed_pixel, anchor='upper left')\n\n    # Define step sizes for horizontal and vertical movements\n    horizontal_step = 3\n    vertical_step = 2\n\n    # Initialize current position\n    x, y = seed_x, seed_y\n\n    # Create the zigzag pattern\n    while x < output_grid.shape[0] and y < output_grid.shape[1]:\n        # Draw horizontal segment\n        end_x = min(x + horizontal_step, output_grid.shape[0])\n        x, y = draw_line(output_grid, x, y, end_x=end_x, color=seed_color, direction=(1, 0))\n\n        # Draw vertical segment\n        end_y = min(y + vertical_step, output_grid.shape[1])\n        x, y = draw_line(output_grid, x, y, end_y=end_y, color=seed_color, direction=(0, 1))\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose a color for the seed pixel\n    seed_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the seed pixel at a random position\n    seed_x = np.random.randint(0, width)\n    seed_y = np.random.randint(0, height)\n    grid[seed_x, seed_y] = seed_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\n# description:\n# In the input, you will see a grid with a single seed pixel.\n# To make the output, starting from this seed pixel, create a diagonal zigzag pattern by alternating between horizontal and vertical movements.\n# Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step), painting each traversed pixel.\n# Continue this pattern until the grid boundary is reached. The result is a staircase-like diagonal composed of axis-aligned segments.\n\ndef main(input_grid):\n    # Output grid is the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect the seed pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_color = object_colors(pixel)[0]\n    pixel_x, pixel_y = object_position(pixel)\n\n    # Define horizontal and vertical step sizes\n    horizontal_step = 3\n    vertical_step = 2\n\n    # Start from the seed pixel\n    x, y = pixel_x, pixel_y\n\n    # Create the zigzag pattern\n    while True:\n        # Move horizontally\n        for _ in range(horizontal_step):\n            if x >= output_grid.shape[0]:\n                return output_grid\n            output_grid[x, y] = pixel_color\n            x += 1\n\n        # Move vertically\n        for _ in range(vertical_step):\n            if y >= output_grid.shape[1]:\n                return output_grid\n            output_grid[x - 1, y] = pixel_color\n            y += 1\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose the color of the seed pixel\n    seed_pixel_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the seed pixel within the grid\n    x = np.random.randint(0, n // 2)  # Place seed pixel in the left half\n    y = np.random.randint(0, m // 2)  # Place seed pixel in the top half\n    grid[x, y] = seed_pixel_color\n\n    return grid"], "seeds": ["3ac3eb23.py", "8403a5d5.py", "6d58a25d.py", "feca6190.py", "Concepts: \ndiagonal movement, zigzag pattern, axis-aligned runs, boundary detection\n\nDescription: \nStarting from a seed pixel, create a diagonal zigzag pattern by alternating between horizontal and vertical movements. Move horizontally by a fixed number of pixels (horizontal_step), then vertically by another fixed number (vertical_step), painting each traversed pixel. Continue this alternating pattern until reaching the grid boundary. The result is a staircase-like diagonal composed of axis-aligned segments."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input, you will see a grid with two distinct pixels marked as start and end with specific colors.\n# To make the output, draw a straight line connecting these two pixels using Bresenham's line algorithm.\n# Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the start and end points by their unique colors\n    start_color = Color.RED\n    end_color = Color.BLUE\n    line_color = Color.GREEN  # The color of the line to be drawn\n\n    # Find the position of the start and end pixels\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    end_pos = np.argwhere(input_grid == end_color)[0]\n\n    # Extract the coordinates\n    x_start, y_start = start_pos\n    x_end, y_end = end_pos\n\n    # Draw the line using Bresenham's line algorithm\n    draw_line(output_grid, x_start, y_start, end_x=x_end, end_y=y_end, color=line_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two distinct random colors for start and end\n    start_color = Color.RED\n    end_color = Color.BLUE\n\n    # Randomly select two distinct positions on the grid for start and end\n    x_start, y_start = np.random.randint(0, n), np.random.randint(0, m)\n    x_end, y_end = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Ensure the start and end points are distinct\n    while (x_start == x_end and y_start == y_end):\n        x_end, y_end = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Set the start and end colors on the grid\n    grid[x_start, y_start] = start_color\n    grid[x_end, y_end] = end_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels. Use Bresenham's line algorithm to determine the path of the line. Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the positions of the start and end points from the input grid\n    # 2. Use Bresenham's line algorithm to find the path between these two points\n    # 3. Color each pixel along the path with the line color\n\n    # 1. Extract the start and end points\n    start_point = np.argwhere(input_grid == Color.BLUE)[0]\n    end_point = np.argwhere(input_grid == Color.RED)[0]\n\n    # 2. Bresenham's line algorithm\n    def bresenham_line(x0, y0, x1, y1):\n        points = []\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n        err = dx - dy\n\n        while True:\n            points.append((x0, y0))\n            if x0 == x1 and y0 == y1:\n                break\n            e2 = 2 * err\n            if e2 > -dy:\n                err -= dy\n                x0 += sx\n            if e2 < dx:\n                err += dx\n                y0 += sy\n        return points\n\n    # 3. Draw the line on the grid\n    output_grid = input_grid.copy()\n    line_color = Color.GREEN\n    path_points = bresenham_line(start_point[0], start_point[1], end_point[0], end_point[1])\n    for x, y in path_points:\n        output_grid[x, y] = line_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a start and end point\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place the start and end points\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    \n    # Ensure start and end points are not the same\n    while start_x == end_x and start_y == end_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    grid[start_x, start_y] = Color.BLUE\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# The input grid contains two distinct pixels marked as start and end.\n# The task is to draw a straight line connecting these two pixels using Bresenham's line algorithm.\n# The pixels along this path should be updated to a specified line color, while all other pixels remain unchanged.\n\ndef main(input_grid):\n    # Find the start and end points\n    start_color = Color.BLUE\n    end_color = Color.RED\n    line_color = Color.GREEN\n\n    # Locate the start and end pixel positions\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    end_pos = np.argwhere(input_grid == end_color)[0]\n\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n\n    # Bresenham's line algorithm to draw a line\n    x1, y1 = start_pos\n    x2, y2 = end_pos\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    sx = 1 if x1 < x2 else -1\n    sy = 1 if y1 < y2 else -1\n    err = dx - dy\n\n    while True:\n        output_grid[x1, y1] = line_color\n        if x1 == x2 and y1 == y2:\n            break\n        e2 = 2 * err\n        if e2 > -dy:\n            err -= dy\n            x1 += sx\n        if e2 < dx:\n            err += dx\n            y1 += sy\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions between 10x10 and 20x20\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select two distinct positions for the start and end points\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    while start_x == end_x and start_y == end_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Assign start and end colors\n    grid[start_x, start_y] = Color.BLUE\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input, you will see a grid with two distinct colored pixels, marked as start and end.\n# To make the output, draw a straight line connecting these two pixels using Bresenham's line algorithm.\n# The line should be drawn with a specified color (e.g., Color.BLUE) and all other pixels in the grid remain unchanged.\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the colors of the start and end points\n    start_color, end_color = np.unique(input_grid[input_grid != Color.BLACK])\n\n    # Find the positions of the start and end points\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    end_pos = np.argwhere(input_grid == end_color)[0]\n\n    # Use Bresenham's line algorithm to determine the path\n    def bresenham_line(x0, y0, x1, y1):\n        \"\"\" Bresenham's Line Algorithm to generate points between (x0, y0) and (x1, y1) \"\"\"\n        points = []\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n        err = dx - dy\n\n        while True:\n            points.append((x0, y0))\n            if x0 == x1 and y0 == y1:\n                break\n            e2 = err * 2\n            if e2 > -dy:\n                err -= dy\n                x0 += sx\n            if e2 < dx:\n                err += dx\n                y0 += sy\n        return points\n\n    # Get the line points\n    line_points = bresenham_line(start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n\n    # Draw the line on the output grid\n    for x, y in line_points:\n        output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select two distinct colors for start and end points\n    colors = np.random.choice(list(Color.NOT_BLACK), size=2, replace=False)\n\n    # Place the start point\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[start_x, start_y] = colors[0]\n\n    # Place the end point\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    # Ensure start and end are not at the same position\n    while (end_x == start_x and end_y == start_y):\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[end_x, end_y] = colors[1]\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels.\n# Use Bresenham's line algorithm to determine the path of the line. Update the grid by coloring each pixel along\n# the path with a specified line color. All other pixels in the grid remain unchanged.\n\ndef bresenham_line(x0, y0, x1, y1):\n    \"\"\"Generate points for a line using Bresenham's line algorithm.\"\"\"\n    points = []\n    dx = abs(x1 - x0)\n    dy = abs(y1 - y0)\n    sx = 1 if x0 < x1 else -1\n    sy = 1 if y0 < y1 else -1\n    err = dx - dy\n\n    while True:\n        points.append((x0, y0))\n        if x0 == x1 and y0 == y1:\n            break\n        e2 = 2*err\n        if e2 > -dy:\n            err -= dy\n            x0 += sx\n        if e2 < dx:\n            err += dx\n            y0 += sy\n\n    return points\n\ndef main(input_grid):\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the start (Color.GREEN) and end (Color.RED) points\n    start = np.argwhere(input_grid == Color.GREEN)\n    end = np.argwhere(input_grid == Color.RED)\n\n    # There should be exactly one start and one end point\n    assert len(start) == 1 and len(end) == 1\n\n    start_x, start_y = start[0]\n    end_x, end_y = end[0]\n\n    # Use Bresenham's algorithm to get the line points\n    line_points = bresenham_line(start_x, start_y, end_x, end_y)\n\n    # Draw the line on the grid with a specified color, e.g., Color.BLUE\n    for x, y in line_points:\n        output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select start and end points\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Ensure start and end points are not the same\n    while start_x == end_x and start_y == end_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Place start and end points on the grid\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, grid update, Bresenham's line algorithm\n\n# description:\n# In the input, you will see a grid with two distinct pixels marked as start and end.\n# To make the output, draw a straight line connecting these two pixels using Bresenham's line algorithm.\n# Update the grid by coloring each pixel along the path with a specified line color.\n# All other pixels in the grid remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Get indices of the start and end points\n    start_coords = np.argwhere(input_grid == Color.BLUE)[0]\n    end_coords = np.argwhere(input_grid == Color.RED)[0]\n    \n    # Define the line color\n    line_color = Color.GREEN\n    \n    # Bresenham's line algorithm implementation\n    x0, y0 = start_coords\n    x1, y1 = end_coords\n    \n    dx = abs(x1 - x0)\n    dy = abs(y1 - y0)\n    sx = 1 if x0 < x1 else -1\n    sy = 1 if y0 < y1 else -1\n    \n    err = dx - dy\n    \n    while True:\n        output_grid[x0, y0] = line_color\n        if x0 == x1 and y0 == y1:\n            break\n        e2 = 2 * err\n        if e2 > -dy:\n            err -= dy\n            x0 += sx\n        if e2 < dx:\n            err += dx\n            y0 += sy\n    \n    return output_grid\n\ndef generate_input():\n    # Define the grid size\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly place the start and end pixels ensuring they are distinct\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    \n    # Ensure the start and end points are distinct\n    while start_x == end_x and start_y == end_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    \n    # Mark the start and end points\n    grid[start_x, start_y] = Color.BLUE\n    grid[end_x, end_y] = Color.RED\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels.\n# Use Bresenham's line algorithm to determine the path of the line. Update the grid by coloring each pixel along the path with a specified line color.\n# All other pixels in the grid remain unchanged.\n\ndef main(input_grid):\n    # Copy input grid to the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Find start and end points marked by distinct colors\n    start_color, end_color = None, None\n    start_pos, end_pos = None, None\n    \n    for color in Color.NOT_BLACK:\n        positions = np.argwhere(input_grid == color)\n        if len(positions) == 1:\n            if start_pos is None:\n                start_pos = positions[0]\n                start_color = color\n            else:\n                end_pos = positions[0]\n                end_color = color\n                break\n    \n    assert start_pos is not None and end_pos is not None, \"Start or end point not found\"\n\n    # Use Bresenham's line algorithm to draw a line between start_pos and end_pos\n    def bresenham_line(x0, y0, x1, y1):\n        points = []\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n        err = dx - dy\n\n        while True:\n            points.append((x0, y0))\n            if x0 == x1 and y0 == y1:\n                break\n            e2 = err * 2\n            if e2 > -dy:\n                err -= dy\n                x0 += sx\n            if e2 < dx:\n                err += dx\n                y0 += sy\n        return points\n\n    line_points = bresenham_line(start_pos[0], start_pos[1], end_pos[0], end_pos[1])\n    \n    # Choose a line color different from the start and end colors\n    line_color = next(color for color in Color.NOT_BLACK if color not in [start_color, end_color])\n\n    # Update the grid with the line color\n    for x, y in line_points:\n        output_grid[x, y] = line_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size between 10 and 20\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose two different colors for start and end points\n    start_color, end_color = np.random.choice([color for color in Color.NOT_BLACK], size=2, replace=False)\n\n    # Place start and end points at random positions\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Ensure start and end points are not the same\n    while (start_x, start_y) == (end_x, end_y):\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    grid[start_x, start_y] = start_color\n    grid[end_x, end_y] = end_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, Bresenham's line algorithm\n\n# description:\n# In the input, you will see a grid with two distinct pixels marked as start and end.\n# To make the output, draw a straight line connecting these two pixels using Bresenham's line algorithm.\n# Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged.\n\ndef bresenhams_line(x0, y0, x1, y1):\n    \"\"\" Bresenham's Line Algorithm to generate points in a line between two points (x0, y0) and (x1, y1). \"\"\"\n    points = []\n    dx = abs(x1 - x0)\n    dy = abs(y1 - y0)\n    sx = 1 if x0 < x1 else -1\n    sy = 1 if y0 < y1 else -1\n    err = dx - dy\n\n    while True:\n        points.append((x0, y0))\n        if x0 == x1 and y0 == y1:\n            break\n        e2 = err * 2\n        if e2 > -dy:\n            err -= dy\n            x0 += sx\n        if e2 < dx:\n            err += dx\n            y0 += sy\n    return points\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Identify the start and end points\n    start = np.where(input_grid == Color.RED)\n    x0, y0 = start[0][0], start[1][0]\n    end = np.where(input_grid == Color.BLUE)\n    x1, y1 = end[0][0], end[1][0]\n    \n    # Use Bresenham's line algorithm to get the points for the line\n    line_points = bresenhams_line(x0, y0, x1, y1)\n    \n    # Draw the line on the output grid\n    for x, y in line_points:\n        output_grid[x, y] = Color.GREEN\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions between 10 and 20\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place the start pixel (red)\n    x0, y0 = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x0, y0] = Color.RED\n\n    # Randomly place the end pixel (blue) ensuring it's not the same as the start\n    x1, y1 = np.random.randint(0, n), np.random.randint(0, m)\n    while (x1, y1) == (x0, y0):\n        x1, y1 = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x1, y1] = Color.BLUE\n\n    return grid"], "seeds": ["23581191.py", "2dd70a9a.py", "b527c5c6.py", "834ec97d.py", "Concepts: \nline drawing, pixel connectivity, grid update\n\nDescription: \nGiven a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels. Use Bresenham's line algorithm to determine the path of the line. Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# The input grid contains a path and obstacles. Starting from a given point, follow the path until an obstacle is encountered.\n# When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear.\n# Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles,\n# always turning the same way as specified.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start point, end point, direction, and obstacles.\n    # 2. Navigate the path from start to end, implementing turns when encountering obstacles.\n    # 3. Generate the output grid with the path marked.\n\n    output_grid = input_grid.copy()\n\n    # Define colors\n    path_color = Color.GREEN\n    obstacle_color = Color.RED\n    start_color = Color.BLUE\n    end_color = Color.YELLOW\n\n    # Find start, end, and obstacles\n    start_x, start_y = np.argwhere(input_grid == start_color)[0]\n    end_x, end_y = np.argwhere(input_grid == end_color)[0]\n    obstacles = np.argwhere(input_grid == obstacle_color)\n\n    # Define initial direction (moving right)\n    direction = (0, 1)\n    turn_direction = 'right'  # Could be set to 'left' as well\n\n    # Function to turn direction\n    def turn(current_direction, direction='right'):\n        if direction == 'right':\n            return (-current_direction[1], current_direction[0])\n        elif direction == 'left':\n            return (current_direction[1], -current_direction[0])\n\n    # Navigate the path\n    x, y = start_x, start_y\n    while (x, y) != (end_x, end_y):\n        # Move in the current direction\n        new_x, new_y = x + direction[0], y + direction[1]\n\n        # Check for obstacles\n        if (new_x, new_y) in map(tuple, obstacles):\n            # Turn in the specified direction\n            direction = turn(direction, turn_direction)\n            continue\n\n        # Mark the path\n        output_grid[x, y] = path_color\n\n        # Update position\n        x, y = new_x, new_y\n\n    # Mark the endpoint\n    output_grid[end_x, end_y] = path_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a path, obstacles, and start/end points\n    grid_size = random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Define colors\n    path_color = Color.GREEN\n    obstacle_color = Color.RED\n    start_color = Color.BLUE\n    end_color = Color.YELLOW\n\n    # Create start and end points\n    start_x, start_y = random.randint(0, grid_size - 1), random.randint(0, grid_size - 1)\n    end_x, end_y = random.randint(0, grid_size - 1), random.randint(0, grid_size - 1)\n\n    grid[start_x, start_y] = start_color\n    grid[end_x, end_y] = end_color\n\n    # Create a random path\n    x, y = start_x, start_y\n    while (x, y) != (end_x, end_y):\n        grid[x, y] = path_color\n        direction = random.choice([(0, 1), (1, 0), (0, -1), (-1, 0)])\n        x, y = x + direction[0], y + direction[1]\n        x, y = max(0, min(grid_size - 1, x)), max(0, min(grid_size - 1, y))\n\n    # Add obstacles\n    num_obstacles = random.randint(5, 10)\n    for _ in range(num_obstacles):\n        ox, oy = random.randint(0, grid_size - 1), random.randint(0, grid_size - 1)\n        if grid[ox, oy] == Color.BLACK:\n            grid[ox, oy] = obstacle_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# Start from a given point on a grid with obstacles. Navigate the path, turning in the specified direction ('left' or 'right') when an obstacle is encountered.\n# Continue moving until the path is clear, then resume the original direction. The output grid shows the path with consistent detours around obstacles.\n\ndef main(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Parse the input\n    start_color = Color.RED\n    obstacle_color = Color.GREY\n    path_color = Color.BLUE\n    direction_choice = 'right'  # can be 'left' or 'right'\n\n    # Find the starting point\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    x, y = start_pos\n\n    # Determine initial direction (assume starting direction is down (1, 0))\n    direction = (1, 0)\n\n    # Function to turn left or right\n    def turn(direction, choice):\n        dx, dy = direction\n        if choice == 'right':\n            return (-dy, dx)\n        elif choice == 'left':\n            return (dy, -dx)\n\n    # Follow the path\n    while True:\n        # Move to the next cell\n        next_x, next_y = x + direction[0], y + direction[1]\n\n        # Check bounds\n        if not (0 <= next_x < input_grid.shape[0] and 0 <= next_y < input_grid.shape[1]):\n            break\n\n        # Check for obstacle\n        if input_grid[next_x, next_y] == obstacle_color:\n            # Turn in the specified direction\n            direction = turn(direction, direction_choice)\n            continue\n\n        # Mark the path\n        output_grid[next_x, next_y] = path_color\n\n        # Move to the next position\n        x, y = next_x, next_y\n\n        # Check if there's a need to turn back to the original direction\n        if input_grid[x, y] != obstacle_color:\n            # If the path is clear, continue in the same direction\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random path and obstacles\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define colors\n    start_color = Color.RED\n    obstacle_color = Color.GREY\n    path_color = Color.BLUE\n\n    # Randomly place the start point\n    start_x, start_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    grid[start_x, start_y] = start_color\n\n    # Randomly place obstacles\n    num_obstacles = np.random.randint(5, 10)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[obs_x, obs_y] = obstacle_color\n\n    # Create a random path\n    current_x, current_y = start_x, start_y\n    direction = (1, 0)\n    for _ in range(np.random.randint(10, 20)):\n        # Move in the current direction\n        next_x, next_y = current_x + direction[0], current_y + direction[1]\n\n        # Check bounds and avoid obstacles\n        if 0 <= next_x < width and 0 <= next_y < height and grid[next_x, next_y] != obstacle_color:\n            grid[next_x, next_y] = path_color\n            current_x, current_y = next_x, next_y\n        else:\n            # Turn randomly\n            direction = turn(direction, np.random.choice(['left', 'right']))\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# Input is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered. \n# When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear.\n# Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, \n# always turning the same way as specified.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Define the colors\n    path_color = Color.RED\n    obstacle_color = Color.GREY\n    start_color = Color.BLUE\n\n    # Find the start position\n    start_x, start_y = np.argwhere(input_grid == start_color)[0]\n\n    # Define the initial direction (right)\n    direction = (0, 1)\n\n    # Define a function to turn left or right\n    def turn(direction, turn_direction):\n        if turn_direction == 'left':\n            return (-direction[1], direction[0])\n        elif turn_direction == 'right':\n            return (direction[1], -direction[0])\n\n    # Move along the path\n    x, y = start_x, start_y\n    while 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1]:\n        # Move forward\n        x, y = x + direction[0], y + direction[1]\n\n        # Check for obstacles\n        if 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1] and input_grid[x, y] == obstacle_color:\n            # Turn right\n            direction = turn(direction, 'right')\n            # Move forward with new direction\n            x, y = x + direction[0], y + direction[1]\n            # Continue moving until path is clear\n            while 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1] and input_grid[x, y] != path_color:\n                x, y = x + direction[0], y + direction[1]\n            # Resume original direction\n            direction = turn(direction, 'left')\n        \n        # Mark the path\n        if 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1]:\n            output_grid[x, y] = path_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with a path and obstacles\n    width, height = 10, 10\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define colors\n    path_color = Color.RED\n    obstacle_color = Color.GREY\n    start_color = Color.BLUE\n\n    # Randomly place the starting point\n    start_x, start_y = np.random.randint(1, width-1), np.random.randint(1, height-1)\n    grid[start_x, start_y] = start_color\n\n    # Create a simple path\n    for x in range(start_x, width-1):\n        grid[x, start_y] = path_color\n\n    # Place obstacles randomly\n    for _ in range(3):\n        obs_x, obs_y = np.random.randint(1, width-1), np.random.randint(1, height-1)\n        grid[obs_x, obs_y] = obstacle_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# The input grid contains a path and obstacles. Starting from a given point (marked with a specific color),\n# navigate the path in a specified direction until an obstacle (another color) is encountered.\n# When an obstacle is hit, turn in a specified direction ('left' or 'right') to navigate around it,\n# and continue until the path is clear. Resume the original direction once past the obstacle.\n# The output grid should show the path with consistent detours around obstacles,\n# always turning in the specified direction. \n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start position, path color, and obstacle color.\n    # 2. Determine the initial direction of movement.\n    # 3. Implement pathfinding with fixed direction turns upon encountering obstacles.\n    # 4. Return the modified grid with the navigated path.\n\n    # Define path and obstacle colors\n    path_color = Color.BLUE\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n\n    # Find the start position\n    start_position = np.argwhere(input_grid == start_color)[0]\n\n    # Initial direction (moving right)\n    direction = (0, 1)  # (dx, dy) format\n\n    def turn_left(direction):\n        # Rotate the direction left\n        if direction == (0, 1):  # Right to Up\n            return (-1, 0)\n        elif direction == (-1, 0):  # Up to Left\n            return (0, -1)\n        elif direction == (0, -1):  # Left to Down\n            return (1, 0)\n        elif direction == (1, 0):  # Down to Right\n            return (0, 1)\n\n    def turn_right(direction):\n        # Rotate the direction right\n        if direction == (0, 1):  # Right to Down\n            return (1, 0)\n        elif direction == (1, 0):  # Down to Left\n            return (0, -1)\n        elif direction == (0, -1):  # Left to Up\n            return (-1, 0)\n        elif direction == (-1, 0):  # Up to Right\n            return (0, 1)\n\n    # Initialize the output grid as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Start navigation from the start position\n    x, y = start_position\n    while True:\n        # Move in the current direction\n        x += direction[0]\n        y += direction[1]\n\n        # Check boundaries\n        if not (0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1]):\n            break\n\n        # If we encounter an obstacle, make a turn\n        if input_grid[x, y] == obstacle_color:\n            # Turn right\n            direction = turn_right(direction)\n            # Move one step in the new direction\n            x += direction[0]\n            y += direction[1]\n\n        # If we move back to the path, continue\n        if input_grid[x, y] == path_color:\n            output_grid[x, y] = path_color\n        else:\n            # If no valid path, break the loop\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a start point, path, and obstacles\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Define path, obstacle, and start colors\n    path_color = Color.BLUE\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n\n    # Create a random path with obstacles\n    x, y = np.random.randint(1, n-1, size=2)\n    grid[x, y] = start_color\n    direction = (0, 1)  # Start moving right\n\n    for _ in range(np.random.randint(5, n)):\n        # Place path\n        x += direction[0]\n        y += direction[1]\n\n        # Check boundaries and switch direction if needed\n        if x < 0 or x >= n or y < 0 or y >= n:\n            break\n\n        grid[x, y] = path_color\n\n        # Randomly place an obstacle nearby\n        if np.random.rand() > 0.7:\n            ox, oy = x + np.random.randint(-1, 2), y + np.random.randint(-1, 2)\n            if 0 <= ox < n and 0 <= oy < n:\n                grid[ox, oy] = obstacle_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# In the input, you will see a grid with a path of a specific color and obstacles of another color.\n# Starting from a given point, navigate the path in a specified direction until an obstacle is encountered.\n# When an obstacle is hit, turn either left or right (specified in the input) and continue moving until the path is clear.\n# Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Parse the input\n    path_color = Color.BLUE\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n    turn_direction = 'left'  # Can be 'left' or 'right', assumed for simplicity\n\n    # Find the starting point\n    start_x, start_y = np.argwhere(input_grid == start_color)[0]\n\n    # Define movement directions (dx, dy)\n    directions = {\n        'right': (0, 1),\n        'down': (1, 0),\n        'left': (0, -1),\n        'up': (-1, 0)\n    }\n    direction_order = ['right', 'down', 'left', 'up']\n\n    # Start direction is 'right' for simplicity\n    current_direction = 'right'\n    dx, dy = directions[current_direction]\n\n    # Function to get the next direction when an obstacle is encountered\n    def get_next_direction(cur_dir, turn):\n        index = direction_order.index(cur_dir)\n        if turn == 'left':\n            return direction_order[(index - 1) % 4]\n        else:\n            return direction_order[(index + 1) % 4]\n\n    # Navigate the path\n    x, y = start_x, start_y\n    while True:\n        # Move in the current direction\n        x, y = x + dx, y + dy\n\n        # Check for out of bounds\n        if not (0 <= x < output_grid.shape[0] and 0 <= y < output_grid.shape[1]):\n            break\n\n        # Check if we've reached an obstacle\n        if output_grid[x, y] == obstacle_color:\n            # Turn to avoid obstacle\n            current_direction = get_next_direction(current_direction, turn_direction)\n            dx, dy = directions[current_direction]\n            continue\n\n        # Check if we've reached the end of the path\n        if output_grid[x, y] == Color.BLACK:\n            break\n\n        # Mark the path on the output grid\n        output_grid[x, y] = path_color\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty grid\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define colors\n    path_color = Color.BLUE\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n\n    # Draw a random path\n    path_length = np.random.randint(5, 10)\n    x, y = np.random.randint(1, width-1), np.random.randint(1, height-1)\n    grid[x, y] = start_color\n\n    current_direction = np.random.choice(['right', 'down'])\n    directions = {\n        'right': (0, 1),\n        'down': (1, 0),\n        'left': (0, -1),\n        'up': (-1, 0)\n    }\n\n    for _ in range(path_length):\n        dx, dy = directions[current_direction]\n        x, y = x + dx, y + dy\n\n        # Ensure the path stays within bounds\n        if not (0 <= x < width and 0 <= y < height):\n            break\n\n        grid[x, y] = path_color\n\n    # Place some obstacles randomly\n    for _ in range(np.random.randint(3, 6)):\n        ox, oy = np.random.randint(1, width-1), np.random.randint(1, height-1)\n        if grid[ox, oy] == Color.BLACK:\n            grid[ox, oy] = obstacle_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# Input is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered.\n# When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear. \n# Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, always turning the same way as specified.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the starting point and the initial direction.\n    # 2. Traverse the path while checking for obstacles.\n    # 3. When an obstacle is encountered, turn in the specified direction ('left' or 'right').\n    # 4. Continue moving in the new direction until the path is clear.\n    # 5. Return to the original direction and continue traversal.\n    # 6. Mark the traversed path on the output grid.\n\n    # Colors in the grid\n    path_color = Color.YELLOW\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n    direction_color = Color.BLUE\n\n    # Copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the start position and initial direction\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    direction_pos = np.argwhere(input_grid == direction_color)[0]\n\n    # Calculate the initial direction vector\n    direction = (direction_pos - start_pos).flatten()\n    direction = tuple(direction)\n\n    # Set the turn direction\n    turn_direction = 'right'  # or 'left'\n\n    # Function to turn left or right\n    def turn(current_direction, turn_direction):\n        if turn_direction == 'right':\n            return (current_direction[1], -current_direction[0])\n        elif turn_direction == 'left':\n            return (-current_direction[1], current_direction[0])\n        return current_direction\n\n    # Traverse the path\n    x, y = start_pos\n    while 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1]:\n        # Mark the path\n        output_grid[x, y] = path_color\n\n        # Check the next position\n        nx, ny = x + direction[0], y + direction[1]\n\n        # Check if next position hits an obstacle\n        if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:\n            if input_grid[nx, ny] == obstacle_color:\n                # Turn in the specified direction\n                direction = turn(direction, turn_direction)\n            else:\n                # Move forward\n                x, y = nx, ny\n        else:\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Create a basic grid\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Define colors\n    path_color = Color.YELLOW\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n    direction_color = Color.BLUE\n\n    # Randomly place the start point on the grid\n    start_x, start_y = np.random.randint(0, n, size=2)\n    grid[start_x, start_y] = start_color\n\n    # Define an initial direction (e.g., to the right)\n    direction = (1, 0)  # right\n    direction_x, direction_y = start_x + direction[0], start_y + direction[1]\n    if 0 <= direction_x < n and 0 <= direction_y < n:\n        grid[direction_x, direction_y] = direction_color\n\n    # Place obstacles\n    num_obstacles = np.random.randint(3, 6)\n    for _ in range(num_obstacles):\n        ox, oy = np.random.randint(0, n, size=2)\n        grid[ox, oy] = obstacle_color\n\n    # Create a path\n    for _ in range(np.random.randint(5, 10)):\n        path_x, path_y = np.random.randint(0, n, size=2)\n        if grid[path_x, path_y] == Color.BLACK:\n            grid[path_x, path_y] = path_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# Input is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered.\n# When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear.\n# Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles,\n# always turning the same way as specified.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Parse the grid to identify the path, obstacles, and starting point\n    # 2. Determine the initial direction of movement\n    # 3. Implement path navigation with fixed direction turns to avoid obstacles\n    # 4. Return the output grid with the navigated path\n\n    # 1. Parse the input grid\n    path_color = Color.BLUE\n    obstacle_color = Color.GREY\n    start_color = Color.GREEN\n    output_grid = input_grid.copy()\n\n    # Find the starting point\n    start_x, start_y = np.argwhere(input_grid == start_color)[0]\n    \n    # Determine initial direction (we assume starting direction is always right)\n    direction = (0, 1)\n    \n    # Define turn directions (right turn)\n    left_turn = { (0, 1): (-1, 0), (-1, 0): (0, -1), (0, -1): (1, 0), (1, 0): (0, 1) }\n    right_turn = { (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0), (-1, 0): (0, 1) }\n    current_turn = right_turn  # Can switch between left_turn and right_turn for diversity\n    \n    # 2. Navigate the path\n    x, y = start_x, start_y\n    while True:\n        # Move in the current direction\n        next_x, next_y = x + direction[0], y + direction[1]\n\n        # Check if we've moved off the grid or hit a path color (stop condition)\n        if not (0 <= next_x < input_grid.shape[0] and 0 <= next_y < input_grid.shape[1]):\n            break\n        if input_grid[next_x, next_y] == path_color:\n            break\n\n        # Check for an obstacle\n        if input_grid[next_x, next_y] == obstacle_color:\n            # Turn in the fixed direction (right)\n            direction = current_turn[direction]\n        else:\n            # Move to the next position\n            x, y = next_x, next_y\n            output_grid[x, y] = path_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a path, obstacles, and a starting point\n\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Define colors\n    path_color = Color.BLUE\n    obstacle_color = Color.GREY\n    start_color = Color.GREEN\n\n    # Create a path\n    path_length = np.random.randint(5, grid_size)\n    x, y = np.random.randint(0, grid_size), np.random.randint(0, grid_size)\n    direction = (0, 1)  # initial direction is right\n\n    for _ in range(path_length):\n        if not (0 <= x < grid_size and 0 <= y < grid_size):\n            break\n        grid[x, y] = path_color\n        x, y = x + direction[0], y + direction[1]\n\n    # Place the starting point at the beginning of the path\n    start_x, start_y = np.argwhere(grid == path_color)[0]\n    grid[start_x, start_y] = start_color\n\n    # Add obstacles randomly\n    num_obstacles = np.random.randint(1, 5)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(0, grid_size), np.random.randint(0, grid_size)\n        if grid[obs_x, obs_y] == Color.BLACK:\n            grid[obs_x, obs_y] = obstacle_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# The input grid contains a colored path and obstacles. You start from a specific point and move along the path in a set direction.\n# When an obstacle is encountered, you turn in the specified direction ('left' or 'right') and continue until the path clears.\n# Resume the original direction after passing the obstacle. The output grid shows the path with detours around obstacles,\n# consistently turning the specified way.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start point and the initial direction\n    # 2. Navigate the path while encountering obstacles, making turns as specified\n    # 3. Return the grid with the completed path\n\n    # Set up the colors and initial direction\n    path_color = Color.RED\n    obstacle_color = Color.GREY\n    start_color = Color.GREEN\n    direction = 'right'  # or 'left', depending on the puzzle specification\n\n    # Determine the initial starting point and direction based on the input grid\n    start_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n    start_object = [obj for obj in start_objects if start_color in object_colors(obj)][0]\n    x, y = object_position(start_object, anchor=\"center\")\n\n    # Define the initial movement direction (e.g., right)\n    move_direction = (0, 1)  # moving right initially\n\n    def turn_left(direction):\n        # Define how to turn left based on current direction\n        dx, dy = direction\n        return (-dy, dx)\n\n    def turn_right(direction):\n        # Define how to turn right based on current direction\n        dx, dy = direction\n        return (dy, -dx)\n\n    # Create a copy of the input grid for output\n    output_grid = input_grid.copy()\n\n    # Navigate the path\n    while True:\n        # Check if the current position is valid\n        if not (0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1]):\n            break\n\n        # Mark the path on the output grid\n        output_grid[x, y] = path_color\n\n        # Move in the current direction\n        next_x, next_y = x + move_direction[0], y + move_direction[1]\n\n        # Check for obstacles\n        if (0 <= next_x < input_grid.shape[0] and 0 <= next_y < input_grid.shape[1]) and input_grid[next_x, next_y] == obstacle_color:\n            # Turn in the specified direction\n            if direction == 'left':\n                move_direction = turn_left(move_direction)\n            else:  # direction == 'right'\n                move_direction = turn_right(move_direction)\n        else:\n            # No obstacle, continue in the same direction\n            x, y = next_x, next_y\n\n    return output_grid\n\ndef generate_input():\n    # Generate an input grid with a path and obstacles\n\n    # Define grid size\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Define colors\n    path_color = Color.RED\n    obstacle_color = Color.GREY\n    start_color = Color.GREEN\n\n    # Create a path\n    x, y = np.random.randint(1, n-1), np.random.randint(1, n-1)\n    grid[x, y] = start_color\n\n    # Generate a random path\n    for _ in range(np.random.randint(5, 10)):\n        direction = np.random.choice([(0, 1), (1, 0), (0, -1), (-1, 0)])\n        length = np.random.randint(2, 5)\n        x, y = draw_line(grid, x, y, length=length, direction=direction, color=path_color, stop_at_color=[obstacle_color])\n\n    # Place obstacles randomly\n    for _ in range(np.random.randint(5, 10)):\n        ox, oy = np.random.randint(0, n), np.random.randint(0, n)\n        if grid[ox, oy] == Color.BLACK:\n            grid[ox, oy] = obstacle_color\n\n    return grid"], "seeds": ["2dd70a9a.py", "b782dc8a.py", "6e19193c.py", "5168d44c.py", "Concepts: \nobstacle navigation, fixed direction turn, pathfinding\n\nDescription: \nInput is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered. When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear. Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, always turning the same way as specified."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object selection, connected components, filtering\n\n# description:\n# The input is a grid containing several colored objects. Each object is a connected component of pixels with the same color.\n# To produce the output, extract all connected components and filter them such that only those with an area greater than a threshold remain.\n# The output is a list of selected objects, represented by their bounding boxes and constituent pixels. Non-selected objects are excluded.\n\ndef main(input_grid):\n    # Define the area threshold for selection\n    area_threshold = 5\n\n    # Detect all connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Prepare a list to store the selected objects\n    selected_objects = []\n\n    # Iterate over each component to apply the selection criterion\n    for comp in components:\n        # Calculate the area of the component (number of pixels)\n        area = np.sum(comp != Color.BLACK)\n\n        # If the component's area is greater than the threshold, select it\n        if area > area_threshold:\n            # Crop the component to get its bounding box\n            cropped_comp = crop(comp, background=Color.BLACK)\n\n            # Add the cropped component to the list of selected objects\n            selected_objects.append(cropped_comp)\n\n    return selected_objects\n\ndef generate_input():\n    # Generate a grid with dimensions between 10x10 to 20x20\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the number of objects to place on the grid\n    num_objects = np.random.randint(3, 6)\n\n    # Place objects randomly on the grid\n    for _ in range(num_objects):\n        # Randomly determine the size of the object\n        obj_n, obj_m = np.random.randint(2, 5, size=2)\n\n        # Create a random sprite of the object\n        obj_color = random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(obj_n, obj_m, color_palette=[obj_color], density=0.5)\n\n        # Try to place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no space, continue with next object\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object selection, connected components, filtering\n\n# description:\n# The input grid is a black grid containing multicolored objects. Each object is a connected component with a single color.\n# Apply a selection criterion: retain only those objects larger than a specified minimum size.\n# The output is a list of the selected objects, each represented by its bounding box and constituent pixels.\n# Non-selected objects are excluded from the output.\n\ndef main(input_grid):\n    # Define the minimum size for object selection\n    min_size = 5  # Minimum number of pixels an object must have to be retained\n\n    # Detect all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Create a list to store selected objects\n    selected_objects = []\n\n    # Iterate over each object and apply the selection criterion\n    for obj in objects:\n        # Crop the object to get its bounding box\n        cropped_obj = crop(obj, background=Color.BLACK)\n        \n        # If the object meets the size criterion, add it to the selected objects list\n        if np.count_nonzero(cropped_obj != Color.BLACK) >= min_size:\n            selected_objects.append(cropped_obj)\n\n    return selected_objects\n\ndef generate_input():\n    # Create a grid of random size between 15x15 and 20x20\n    n, m = np.random.randint(15, 21), np.random.randint(15, 21)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Define possible colors excluding black\n    colors = list(Color.NOT_BLACK)\n\n    # Number of objects to add\n    num_objects = np.random.randint(3, 6)\n\n    # Add objects to the grid\n    for _ in range(num_objects):\n        # Generate a random sprite with a random color\n        color = np.random.choice(colors)\n        sprite_size = np.random.randint(3, 6)\n        sprite = random_sprite(sprite_size, sprite_size, density=0.5, color_palette=[color], connectivity=4)\n        \n        try:\n            # Find a random location for the sprite in the grid\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n            # Place the sprite in the grid\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no location is found, continue to next sprite\n            continue\n            \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object selection, connected components, filtering\n\n# description:\n# The input grid contains multiple colored objects scattered around. \n# The task is to identify all connected components (objects) and filter them based on their bounding box shape.\n# Specifically, we will retain only those objects whose bounding box is not a square.\n# The output will be a list of these selected objects, each represented by its cropped image.\n\ndef main(input_grid):\n    # Find all connected components (objects) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Initialize an empty list to store the selected objects\n    selected_objects = []\n\n    # Iterate over each object\n    for obj in objects:\n        # Crop the object to get its bounding box\n        cropped_obj = crop(obj, background=Color.BLACK)\n\n        # Check the shape of the bounding box\n        # Retain the object if the bounding box is not a square\n        if cropped_obj.shape[0] != cropped_obj.shape[1]:\n            selected_objects.append(cropped_obj)\n\n    return selected_objects\n\n\ndef generate_input():\n    # Create a grid with a random size between 15x15 and 20x20\n    n = random.randint(15, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate a number of random objects\n    num_objects = random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Create a random sprite with dimensions between 3x3 and 5x5\n        sprite_n = random.randint(3, 5)\n        sprite_m = random.randint(3, 5)\n        color_palette = random.sample(Color.NOT_BLACK, k=random.randint(1, 3))\n        sprite = random_sprite(sprite_n, sprite_m, color_palette=color_palette, connectivity=8)\n\n        # Try to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If there's no space, skip this sprite\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object selection, connected components, filtering\n\n# description:\n# In the input grid, you will see multiple colored objects on a black background. \n# Each object is a connected component of the same color.\n# To make the output, extract all connected components and apply a filter to select only the objects with an even number of pixels. \n# The output should be a list of the selected objects, each represented by its bounding box and constituent pixels. Non-selected objects are excluded from the output.\n\ndef main(input_grid):\n    # Get all unique colors except black\n    colors = [color for color in np.unique(input_grid) if color != Color.BLACK]\n\n    # List to store selected objects\n    selected_objects = []\n\n    # Process each color\n    for color in colors:\n        # Detect connected components of the current color\n        objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n        # Filter objects with even number of pixels\n        for obj in objects:\n            if np.sum(obj != Color.BLACK) % 2 == 0:\n                # Crop the object to get its bounding box and constituent pixels\n                cropped_obj = crop(obj, background=Color.BLACK)\n                selected_objects.append(cropped_obj)\n\n    return selected_objects\n\ndef generate_input():\n    # Create a grid with random dimensions\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Random number of objects\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Random object size\n        size = np.random.randint(2, 4)\n        # Random object color\n        obj_color = random.choice(list(Color.NOT_BLACK))\n\n        # Create a random sprite with the selected color\n        sprite = random_sprite(n=size, m=size, color_palette=[obj_color], connectivity=4)\n\n        # Try to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=4)\n        except ValueError:\n            continue\n\n        # Place the sprite in the grid\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object selection, connected components, filtering\n\n# description:\n# In the input grid, connected components (objects) of various sizes and colors are placed randomly.\n# The task is to filter and retain only those objects that have an area greater than a specified threshold.\n# The output should be a list of the selected objects, each represented by its bounding box and constituent pixels.\n\ndef main(input_grid):\n    # Define the area threshold for filtering\n    area_threshold = 5\n\n    # Find all connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # List to store selected objects\n    selected_objects = []\n\n    # Filter components based on the area criterion\n    for component in components:\n        # Calculate the area of the component by counting non-background pixels\n        area = np.sum(component != Color.BLACK)\n        \n        # Retain component if its area is greater than the threshold\n        if area > area_threshold:\n            # Crop the component to obtain its bounding box\n            cropped_component = crop(component, background=Color.BLACK)\n            selected_objects.append(cropped_component)\n\n    return selected_objects\n\n\ndef generate_input():\n    # Create a grid with random dimensions between 10 and 20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define a number of components to place\n    num_components = np.random.randint(3, 7)\n\n    for _ in range(num_components):\n        # Generate a random sprite with varied colors and size\n        n_sprite, m_sprite = np.random.randint(2, 5), np.random.randint(2, 5)\n        color_palette = random.sample(Color.NOT_BLACK, np.random.randint(1, 3))\n        sprite = random_sprite(n=n_sprite, m=m_sprite, color_palette=color_palette, connectivity=4)\n\n        # Try to place the sprite in the grid at a random location\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no suitable location is found, continue with the next sprite\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object selection, connected components, filtering\n\n# description:\n# The input is a grid with various colored objects. Extract all connected components from the grid.\n# Retain only those objects that are exactly 2x2 in size. The output is a list of these selected objects,\n# each represented by its bounding box and constituent pixels. Non-selected objects are excluded from the output.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Create a list to store the selected objects\n    selected_objects = []\n\n    # Iterate through each component and filter based on size\n    for component in components:\n        # Crop the component to get its bounding box\n        cropped_component = crop(component, background=Color.BLACK)\n        \n        # Check if the component is exactly 2x2 in size\n        if cropped_component.shape == (2, 2):\n            # Save the component and its position\n            selected_objects.append((cropped_component, object_position(component, background=Color.BLACK)))\n    \n    return selected_objects\n\n\ndef generate_input():\n    # Create a grid of size 10x10 filled with black color\n    grid_size = (10, 10)\n    grid = np.full(grid_size, Color.BLACK)\n\n    # Generate random 2x2 sprites and place them in the grid\n    num_sprites = np.random.randint(3, 6)\n    available_colors = [c for c in Color.NOT_BLACK]\n\n    for _ in range(num_sprites):\n        # Randomly choose a color for the sprite\n        color = random.choice(available_colors)\n        sprite = np.full((2, 2), color)\n\n        # Try to find a location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n        except ValueError:\n            continue\n\n        # Place the sprite on the grid\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Optionally add some larger or smaller objects to test filtering\n    for _ in range(np.random.randint(1, 3)):\n        n, m = np.random.randint(1, 4), np.random.randint(1, 4)\n        larger_sprite = random_sprite(n, m, color_palette=available_colors)\n        try:\n            x, y = random_free_location_for_sprite(grid, larger_sprite, border_size=1, padding=1)\n        except ValueError:\n            continue\n        blit_sprite(grid, larger_sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, object selection, filtering\n\n# description:\n# The input grid is a square grid with various colored objects scattered across a black background. Each object is a connected component.\n# The output should only include objects that are rectangular in shape. For each selected object, output its bounding box and constituent pixels.\n# Non-selected objects are excluded from the output.\n\ndef main(input_grid):\n    # Detect all objects in the input grid\n    all_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Initialize a list to store selected rectangular objects\n    selected_objects = []\n\n    # Iterate through all detected objects\n    for obj in all_objects:\n        # Crop the object to its bounding box\n        cropped_obj = crop(obj, background=Color.BLACK)\n        \n        # Check if the cropped object is rectangular\n        if is_rectangular(cropped_obj):\n            # Add the rectangular object to the selected list\n            selected_objects.append(cropped_obj)\n\n    # Create the output grid by placing selected objects\n    output_grid = assemble_output_grid(selected_objects, input_grid.shape)\n\n    return output_grid\n\ndef is_rectangular(obj):\n    \"\"\"Helper function to check if an object is rectangular.\"\"\"\n    # Crop the object to its bounding box\n    cropped = crop(obj, background=Color.BLACK)\n    # Check if all non-black pixels form a filled rectangle\n    return np.all(cropped[cropped != Color.BLACK] == cropped[0, 0])\n\ndef assemble_output_grid(objects, grid_shape):\n    \"\"\"Assemble the output grid from selected objects.\"\"\"\n    output_grid = np.full(grid_shape, Color.BLACK)\n    for obj in objects:\n        x, y = random_free_location_for_sprite(output_grid, obj, border_size=1, padding=1)\n        blit_sprite(output_grid, obj, x, y, background=Color.BLACK)\n    return output_grid\n\ndef generate_input():\n    # Create a random-sized grid with a black background\n    n = random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate random colored objects and place them in the grid\n    n_objects = random.randint(3, 6)\n    for _ in range(n_objects):\n        color = random.choice(list(Color.NOT_BLACK))\n        # Generate a random sprite with a 50% chance of being a rectangle\n        if random.random() > 0.5:\n            sprite = random_rectangular_sprite(color)\n        else:\n            sprite = random_sprite(n=random.randint(2, 5), m=random.randint(2, 5), color_palette=[color])\n\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n        except ValueError:\n            continue\n\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid\n\ndef random_rectangular_sprite(color):\n    \"\"\"Generate a rectangular sprite of random size.\"\"\"\n    n, m = random.randint(2, 5), random.randint(2, 5)\n    sprite = np.full((n, m), color)\n    return sprite", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object selection, connected components, filtering\n\n# description:\n# The input grid consists of various colored objects on a black background. Each object is a connected component of the same color.\n# The task is to extract all connected components and retain only those that fulfill a specific condition.\n# The output should be a list of selected objects, each represented by its bounding box and constituent pixels. Non-selected objects are excluded.\n\ndef main(input_grid):\n    # Extract connected components from the input grid\n    connected_components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Define the selection criterion: Select objects with an area greater than a specific threshold\n    area_threshold = 5  # Example threshold\n\n    selected_objects = []\n    for component in connected_components:\n        # Calculate the area of the component\n        area = np.sum(component != Color.BLACK)\n\n        # Apply the selection criterion\n        if area > area_threshold:\n            # Crop the component to its bounding box\n            cropped_component = crop(component, background=Color.BLACK)\n\n            # Add the cropped component to the list of selected objects\n            selected_objects.append(cropped_component)\n\n    return selected_objects\n\n\ndef generate_input():\n    # Create a grid of a random size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Generate a random sprite with random dimensions and color\n        sprite_n, sprite_m = np.random.randint(2, 5), np.random.randint(2, 5)\n        color = random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(n=sprite_n, m=sprite_m, color_palette=[color], connectivity=8)\n\n        # Try to find a random free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no space is found, skip this sprite\n\n    return grid"], "seeds": ["48d8fb45.py", "137eaa0f.py", "44d8ac46.py", "00d62c1b.py", "Concepts: \nobject selection, connected components, filtering\n\nDescription: \nExtract all connected components (objects) from the input grid. Apply a selection criterion to filter these objects, retaining only those that meet the specified condition. The output is a list of the selected objects, each represented by its bounding box and constituent pixels. Non-selected objects are excluded from the output."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, pathfinding\n\n# description:\n# Identify obstacles as distinct objects in the grid that block the path of line drawing. When drawing a line between two points,\n# the line must navigate around these obstacles, ensuring no part of the line overlaps with any obstacle. The output grid shows\n# the line drawn from start to end, avoiding obstacles, while all other grid content remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = input_grid.copy()\n\n    # Get the start and end points, which are the only two non-black pixels\n    start_point = None\n    end_point = None\n\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        if start_point is None:\n            start_point = (x, y)\n        else:\n            end_point = (x, y)\n            break  # We found both start and end points\n\n    # Check for obstacles and define the blocked regions\n    obstacles = (input_grid != Color.BLACK) & (input_grid != input_grid[start_point]) & (input_grid != input_grid[end_point])\n\n    # Perform a simple BFS to find a path from start to end avoiding obstacles\n    queue = [(start_point, [start_point])]\n    visited = set([start_point])\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n\n    while queue:\n        (current, path) = queue.pop(0)\n\n        if current == end_point:\n            # Draw the path on the output grid\n            for x, y in path:\n                output_grid[x, y] = input_grid[start_point]\n            break\n\n        for direction in directions:\n            next_x, next_y = current[0] + direction[0], current[1] + direction[1]\n            if (0 <= next_x < output_grid.shape[0] and 0 <= next_y < output_grid.shape[1] and\n                    not obstacles[next_x, next_y] and (next_x, next_y) not in visited):\n                visited.add((next_x, next_y))\n                queue.append(((next_x, next_y), path + [(next_x, next_y)]))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly place a start and end point\n    start_color = random.choice(list(Color.NOT_BLACK))\n    end_color = random.choice([color for color in Color.NOT_BLACK if color != start_color])\n\n    grid[0, 0] = start_color\n    grid[-1, -1] = end_color\n\n    # Scatter obstacle blocks randomly\n    num_obstacles = random.randint(10, 20)\n    obstacle_color = random.choice([color for color in Color.NOT_BLACK if color not in [start_color, end_color]])\n\n    for _ in range(num_obstacles):\n        x, y = np.random.randint(0, grid_size, size=2)\n        if (x, y) not in [(0, 0), (grid_size - 1, grid_size - 1)]:\n            grid[x, y] = obstacle_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing\n\n# description:\n# In the input grid, you will see two distinct points: a green start point and a red end point, along with multiple irregular-shaped obstacles in grey.\n# The task is to draw a continuous line from the green start point to the red end point, avoiding the grey obstacles. The line should not touch or pass through any obstacle.\n# The line should take the shortest possible path, moving horizontally or vertically, and it can only turn 90 degrees at a time.\n\ndef main(input_grid):\n    # The output grid is the same size as the input grid, and we are going to draw on top of the input, so we copy it\n    output_grid = input_grid.copy()\n    width, height = input_grid.shape\n\n    # Identify the start (green) and end (red) points\n    start_x, start_y = np.argwhere(input_grid == Color.GREEN)[0]\n    end_x, end_y = np.argwhere(input_grid == Color.RED)[0]\n\n    # Identify the grey obstacles\n    obstacles = (input_grid == Color.GREY)\n    \n    # Use BFS for shortest path finding, avoiding obstacles\n    from collections import deque\n    queue = deque([(start_x, start_y)])\n    visited = { (start_x, start_y): None }  # To track the path\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n\n    while queue:\n        x, y = queue.popleft()\n        if (x, y) == (end_x, end_y):\n            break\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and not obstacles[nx, ny]:\n                queue.append((nx, ny))\n                visited[(nx, ny)] = (x, y)\n\n    # Backtrack from end point to start point to draw the path on the grid\n    current = (end_x, end_y)\n    path = []\n    while current is not None:\n        path.append(current)\n        current = visited[current]\n\n    # Draw the path in a specific color (e.g., BLUE)\n    for x, y in path:\n        output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 15x15\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place the start (green) and end (red) points\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    while (end_x, end_y) == (start_x, start_y):\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    # Randomly scatter grey obstacles\n    obstacle_density = np.random.uniform(0.1, 0.3)  # 10% to 30% of the grid can be obstacles\n    randomly_scatter_points(grid, color=Color.GREY, density=obstacle_density, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing\n\n# description:\n# In the input grid, there are randomly placed colored obstacles and two distinct points marked with different colors (e.g., green and red).\n# The goal is to draw a line from the green point to the red point, navigating around the obstacles. \n# The line should not overlap any obstacles and should follow the shortest path possible. The output grid retains all other elements of the input grid unchanged.\n\ndef main(input_grid):\n    # The output grid is initialized as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Find the start (green) and end (red) points\n    start_pos = np.argwhere(input_grid == Color.GREEN)[0]\n    end_pos = np.argwhere(input_grid == Color.RED)[0]\n\n    # Identify obstacles: these are colors that are not black, green, or red\n    obstacles = {color for color in Color.NOT_BLACK if color not in (Color.GREEN, Color.RED)}\n\n    # Implement a simple BFS for pathfinding to navigate around obstacles\n    from collections import deque\n    queue = deque([(start_pos[0], start_pos[1], [])])\n    visited = set()\n    visited.add((start_pos[0], start_pos[1]))\n\n    while queue:\n        x, y, path = queue.popleft()\n\n        # If we reached the end point, draw the path and return the output\n        if (x, y) == (end_pos[0], end_pos[1]):\n            for px, py in path:\n                output_grid[px, py] = Color.GREEN\n            return output_grid\n\n        # Explore neighbors: up, down, left, right\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:\n                if input_grid[nx, ny] not in obstacles:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [(nx, ny)]))\n\n    # In case no path is found, return the original grid\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place a green start point and a red end point\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    while (end_x, end_y) == (start_x, start_y):\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    # Randomly scatter obstacles across the grid with a density of 0.2\n    randomly_scatter_points(grid, color=Color.GREY, density=0.2, background=Color.BLACK)\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# path finding, obstacle avoidance, line drawing\n\n# description:\n# In the input grid, you will see several randomly colored obstacles scattered throughout the grid, along with a distinct start point and end point.\n# The task is to draw a line from the start point to the end point while avoiding the obstacles. \n# The line should navigate around the obstacles and ensure no part of it overlaps with any obstacle.\n# The output grid will show the line drawn from the start to the end, avoiding obstacles, while all other grid content remains unchanged.\n\ndef main(input_grid):\n    # Copy input grid to output grid\n    output_grid = input_grid.copy()\n    width, height = input_grid.shape\n\n    # Identify the start and end points\n    start_point = np.argwhere(input_grid == Color.GREEN)[0]  # Assuming start point is marked with green\n    end_point = np.argwhere(input_grid == Color.RED)[0]      # Assuming end point is marked with red\n\n    # Obstacles are any other colored pixels\n    obstacle_colors = set(Color.ALL_COLORS) - {Color.GREEN, Color.RED, Color.BLACK}\n    \n    # Implement a simple pathfinding algorithm (e.g., A* or Dijkstra's) to find a path from start to end avoiding obstacles\n    def is_valid(x, y):\n        return 0 <= x < width and 0 <= y < height and input_grid[x, y] not in obstacle_colors\n\n    from heapq import heappush, heappop\n    open_set = []\n    heappush(open_set, (0, start_point))\n    came_from = {}\n    cost_so_far = {tuple(start_point): 0}\n\n    while open_set:\n        _, current = heappop(open_set)\n\n        if np.array_equal(current, end_point):\n            break\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_step = current + np.array([dx, dy])\n            if is_valid(*next_step):\n                new_cost = cost_so_far[tuple(current)] + 1\n                if tuple(next_step) not in cost_so_far or new_cost < cost_so_far[tuple(next_step)]:\n                    cost_so_far[tuple(next_step)] = new_cost\n                    priority = new_cost + np.linalg.norm(next_step - end_point)\n                    heappush(open_set, (priority, next_step))\n                    came_from[tuple(next_step)] = current\n\n    # Reconstruct path from end to start\n    current = tuple(end_point)\n    path = []\n    while current in came_from:\n        path.append(current)\n        current = tuple(came_from[current])\n    path.append(tuple(start_point))\n    path.reverse()\n\n    # Draw the path on the output grid\n    for x, y in path:\n        output_grid[x, y] = Color.BLUE  # Draw path in blue\n\n    return output_grid\n\ndef generate_input():\n    # Grid dimensions\n    n, m = 15, 15\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define start and end points\n    start_x, start_y = np.random.randint(0, n // 3), np.random.randint(0, m // 3)\n    end_x, end_y = np.random.randint(2 * n // 3, n), np.random.randint(2 * m // 3, m)\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    # Randomly scatter obstacles throughout the grid\n    obstacle_density = 0.2\n    randomly_scatter_points(grid, color=random.choice(list(set(Color.NOT_BLACK) - {Color.GREEN, Color.RED})), density=obstacle_density, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path finding, line drawing\n\n# description:\n# In the input, you will see a grid with obstacles represented by gray pixels. \n# There will be a blue pixel indicating the start point and a red pixel indicating the end point.\n# The task is to draw a path from the blue pixel to the red pixel, avoiding the gray obstacles.\n# The path should be drawn as a continuous green line.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the start and end points\n    start_point = np.argwhere(output_grid == Color.BLUE)[0]\n    end_point = np.argwhere(output_grid == Color.RED)[0]\n\n    # Find the obstacles\n    obstacles = np.argwhere(output_grid == Color.GREY)\n\n    def is_valid(x, y):\n        # Check if the point is inside the grid and not an obstacle\n        if 0 <= x < output_grid.shape[0] and 0 <= y < output_grid.shape[1]:\n            if output_grid[x, y] != Color.GREY:\n                return True\n        return False\n\n    # Implement a simple pathfinding algorithm (e.g., BFS) to find the path\n    from collections import deque\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 4-way connectivity\n    queue = deque([(*start_point, [])])\n    visited = set()\n    visited.add(tuple(start_point))\n\n    while queue:\n        x, y, path = queue.popleft()\n\n        if (x, y) == tuple(end_point):\n            # Draw the path in green\n            for px, py in path:\n                output_grid[px, py] = Color.GREEN\n            break\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [(nx, ny)]))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x n\n    n = np.random.randint(10, 15)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Randomly place the start point (blue) and the end point (red)\n    start_x, start_y = np.random.randint(0, n, size=2)\n    end_x, end_y = np.random.randint(0, n, size=2)\n    while (start_x, start_y) == (end_x, end_y):\n        end_x, end_y = np.random.randint(0, n, size=2)\n\n    grid[start_x, start_y] = Color.BLUE\n    grid[end_x, end_y] = Color.RED\n\n    # Randomly scatter obstacles (gray) on the grid\n    num_obstacles = np.random.randint(5, 15)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(0, n, size=2)\n        if grid[obs_x, obs_y] == 0:\n            grid[obs_x, obs_y] = Color.GREY\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing\n\n# description:\n# In the input, you will see a grid with a start point marked in green and an endpoint marked in red, along with several obstacles in grey.\n# Draw a path from the start point to the endpoint using blue, avoiding the obstacles by navigating around them.\n# The output grid should show the path drawn from the start to the endpoint while all other grid content remains unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start and end points\n    # 2. Use a pathfinding algorithm (e.g., BFS) to find a path from start to end avoiding obstacles\n    # 3. Draw the path on the grid using the color blue\n\n    # Identify the start (green) and end (red) points\n    start_point = np.argwhere(input_grid == Color.GREEN)[0]\n    end_point = np.argwhere(input_grid == Color.RED)[0]\n\n    # Identify obstacle positions\n    obstacle_positions = np.argwhere(input_grid == Color.GREY)\n\n    # Copy the grid to the output\n    output_grid = np.copy(input_grid)\n\n    # Pathfinding function\n    def bfs_find_path(start, end, obstacles):\n        # Queue for BFS\n        queue = [start]\n        visited = set()\n        paths = {tuple(start): []}\n\n        while queue:\n            current = queue.pop(0)\n            if tuple(current) in visited:\n                continue\n            visited.add(tuple(current))\n\n            # If we reach the endpoint, return the path\n            if np.array_equal(current, end):\n                return paths[tuple(current)]\n\n            # Explore neighboring positions\n            for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                neighbor = current + direction\n                if (0 <= neighbor[0] < input_grid.shape[0]) and (0 <= neighbor[1] < input_grid.shape[1]):\n                    if (tuple(neighbor) not in visited) and (tuple(neighbor) not in map(tuple, obstacles)):\n                        queue.append(neighbor)\n                        paths[tuple(neighbor)] = paths[tuple(current)] + [neighbor]\n\n        return None\n\n    # Find path avoiding obstacles\n    path = bfs_find_path(start_point, end_point, obstacle_positions)\n\n    # Draw the path on the output grid\n    if path:\n        for step in path:\n            output_grid[step[0], step[1]] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place the start point (green)\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[start_x, start_y] = Color.GREEN\n\n    # Randomly place the end point (red), ensuring it's not the same as the start point\n    end_x, end_y = start_x, start_y\n    while end_x == start_x and end_y == start_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[end_x, end_y] = Color.RED\n\n    # Scatter some obstacles (grey) on the grid, avoiding start and end points\n    obstacle_density = np.random.uniform(0.1, 0.2)\n    for _ in range(int(obstacle_density * n * m)):\n        while True:\n            obs_x, obs_y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[obs_x, obs_y] == Color.BLACK:\n                grid[obs_x, obs_y] = Color.GREY\n                break\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing\n\n# description:\n# Identify obstacles as distinct objects in the grid that block the path of line drawing. When drawing a line between two points, the line must navigate around these obstacles, ensuring no part of the line overlaps with any obstacle. The output grid shows the line drawn from start to end, avoiding obstacles, while all other grid content remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify obstacle objects\n    obstacles = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Find the start and end points for the line drawing\n    # Assume for simplicity that the start and end points are specific colors (e.g., start is GREEN and end is RED)\n    start_points = np.argwhere(input_grid == Color.GREEN)\n    end_points = np.argwhere(input_grid == Color.RED)\n\n    if len(start_points) == 0 or len(end_points) == 0:\n        return output_grid  # No valid start or end points\n\n    # Select the first start and end point for simplicity\n    start_x, start_y = start_points[0]\n    end_x, end_y = end_points[0]\n\n    # Implement a simple pathfinding algorithm avoiding obstacles\n    # We'll use a basic DFS or BFS for simplicity\n    def is_valid(x, y):\n        # Check if a position is valid (inside grid and not an obstacle)\n        if not (0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1]):\n            return False\n        return input_grid[x, y] != Color.BLACK and all(obj[x, y] == Color.BLACK for obj in obstacles)\n\n    def dfs_path(x, y, path):\n        if (x, y) == (end_x, end_y):\n            return path\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in path:\n                result = dfs_path(nx, ny, path + [(nx, ny)])\n                if result is not None:\n                    return result\n        return None\n\n    # Find a path from start to end\n    path = dfs_path(start_x, start_y, [(start_x, start_y)])\n    if path is not None:\n        for x, y in path:\n            output_grid[x, y] = Color.BLUE  # Color the path with a specific color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random obstacles and start/end points\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter obstacles randomly\n    randomly_scatter_points(grid, color=Color.GREY, density=0.2, background=Color.BLACK)\n\n    # Place start and end points\n    start_x, start_y = random.randint(0, n-1), random.randint(0, m-1)\n    end_x, end_y = random.randint(0, n-1), random.randint(0, m-1)\n    grid[start_x, start_y] = Color.GREEN\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing\n\n# description:\n# In the input, you will see a grid with various colored obstacles scattered across the grid, and two distinct points marked with specific colors (start and end).\n# To make the output grid, you need to draw a path connecting the start and end points, avoiding the obstacles. \n# The path should navigate around the obstacles, ensuring no part of the line overlaps with any obstacle.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the start and end points based on their unique colors.\n    # 2. Identify the obstacles in the grid.\n    # 3. Implement a pathfinding algorithm to draw a line from the start to the end, avoiding obstacles.\n    \n    # Copy the input grid to the output grid to perform operations\n    output_grid = np.copy(input_grid)\n    \n    # 1. Identify start and end points\n    start_color = Color.GREEN\n    end_color = Color.RED\n    start_point = np.argwhere(input_grid == start_color)[0]\n    end_point = np.argwhere(input_grid == end_color)[0]\n    \n    # 2. Identify obstacles\n    obstacles = input_grid != Color.BLACK\n    obstacles[start_point[0], start_point[1]] = False\n    obstacles[end_point[0], end_point[1]] = False\n    \n    # 3. Implement a simple pathfinding algorithm (e.g., BFS) to find a path from start to end\n    from collections import deque\n    \n    # Directions for moving: right, left, down, up\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(*start_point, None)])  # (x, y, direction)\n    visited = set()\n    parents = {}\n    \n    while queue:\n        x, y, direction = queue.popleft()\n        \n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        \n        if (x, y) == (end_point[0], end_point[1]):\n            # Reconstruct path\n            path = []\n            current = (x, y)\n            while current is not None:\n                path.append(current)\n                current = parents.get(current)\n            path.reverse()\n            break\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1] and not obstacles[nx, ny]:\n                if (nx, ny) not in visited:\n                    queue.append((nx, ny, (dx, dy)))\n                    parents[(nx, ny)] = (x, y)\n    \n    # Draw the path on the output grid\n    for (x, y) in path:\n        output_grid[x, y] = Color.BLUE  # Path color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a stochastic input grid\n    n = m = 10  # Size of the grid\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Randomly place the start (green) and end (red) points on the grid\n    start_position = (np.random.randint(n), np.random.randint(m))\n    end_position = (np.random.randint(n), np.random.randint(m))\n    while end_position == start_position:\n        end_position = (np.random.randint(n), np.random.randint(m))\n    \n    grid[start_position] = Color.GREEN\n    grid[end_position] = Color.RED\n    \n    # Randomly scatter obstacles (colored differently) on the grid\n    obstacle_colors = [Color.YELLOW, Color.GREY, Color.ORANGE, Color.PINK]\n    randomly_scatter_points(grid, color=random.choice(obstacle_colors), density=0.2, background=Color.BLACK)\n    \n    # Ensure start and end positions are not overwritten by obstacles\n    grid[start_position] = Color.GREEN\n    grid[end_position] = Color.RED\n\n    return grid"], "seeds": ["d9f24cd1.py", "2dd70a9a.py", "a78176bb.py", "8d510a79.py", "Concepts: \nobstacles, path blocking, line drawing\n\nDescription: \nIdentify obstacles as distinct objects in the grid that block the path of line drawing. When drawing a line between two points, the line must navigate around these obstacles, ensuring no part of the line overlaps with any obstacle. The output grid shows the line drawn from start to end, avoiding obstacles, while all other grid content remains unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# The input consists of multiple objects of various colors on a grid.\n# Identify and select all objects that are composed entirely of a specified target color.\n# Output a grid where only these selected objects are preserved in their original positions and colors,\n# while all other grid cells are set to the background color (0).\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Define the target color which we want to preserve in the output\n    target_color = Color.RED  # For example, assume the target color is RED\n\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Iterate over the detected objects\n    for obj in objects:\n        # Check if the object is composed entirely of the target color\n        if np.all(obj[obj != Color.BLACK] == target_color):\n            # Preserve the object in the output grid\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Create a grid of size 10x10 filled with the background color\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Define a random palette of colors including the target color\n    colors = list(Color.NOT_BLACK)\n    target_color = Color.RED  # Example target color\n    random_color_palette = [target_color] + [c for c in colors if c != target_color]\n\n    # Randomly place objects of various colors in the grid\n    for _ in range(5):  # Number of objects to place\n        # Randomly choose dimensions for the object\n        obj_height = np.random.randint(1, 4)\n        obj_width = np.random.randint(1, 4)\n\n        # Create the object\n        obj_color = random.choice(random_color_palette)\n        obj = random_sprite(obj_height, obj_width, color_palette=[obj_color], density=0.7)\n\n        # Try to place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, border_size=1, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no space is available, skip this object\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# The input consists of a grid with multiple objects of various colors. Identify and select all objects\n# that are composed entirely of a specified target color. Output a grid where only these selected objects\n# are preserved in their original positions and colors, while all other grid cells are set to the background color (0).\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Plan:\n    # 1. Detect all monochromatic objects in the input grid.\n    # 2. Filter objects, selecting only those composed entirely of the target color.\n    # 3. Create an output grid with only the selected objects, setting all other cells to background.\n\n    # Step 1: Detect monochromatic objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Step 2: Filter objects to select those composed entirely of the target color\n    selected_objects = [obj for obj in objects if np.all(obj[obj != Color.BLACK] == target_color)]\n\n    # Step 3: Create output grid with only the selected objects\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    for obj in selected_objects:\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with multiple colored objects\n    grid_size = (np.random.randint(10, 15), np.random.randint(10, 15))\n    grid = np.full(grid_size, Color.BLACK)\n\n    # Choose a target color for the puzzle\n    target_color = random.choice(list(Color.NOT_BLACK))\n\n    # Populate the grid with random objects, some of which are entirely of the target color\n    num_objects = np.random.randint(5, 10)\n    for _ in range(num_objects):\n        # Generate a random sprite with a mix of colors\n        sprite_color_palette = random.sample(list(Color.NOT_BLACK), np.random.randint(1, 4))\n        sprite = random_sprite(n=3, m=3, color_palette=sprite_color_palette)\n\n        # Randomly decide if this sprite should be of the target color\n        if np.random.rand() < 0.3:\n            sprite[sprite != Color.BLACK] = target_color\n\n        # Try to place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=4)\n            grid = blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# The input consists of multiple objects of various colors on a grid. \n# Identify and select all objects that are composed entirely of a specified target color.\n# Output a grid where only these selected objects are preserved in their original positions and colors,\n# while all other grid cells are set to background color (0).\n\ndef main(input_grid: np.ndarray, target_color) -> np.ndarray:\n    # Plan:\n    # 1. Detect all connected components in the grid using 4-way connectivity.\n    # 2. Filter out components that are not entirely the target color.\n    # 3. Create an output grid with only the selected objects preserved.\n\n    # Extract objects using 4-way connectivity\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n\n    # Create an empty grid for output\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Iterate over each object and check if it's composed entirely of the target color\n    for obj in objects:\n        if np.all(obj[obj != Color.BLACK] == target_color):\n            # If the object is entirely the target color, draw it onto the output grid\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Create a grid of size 10x10 filled with black\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Choose a random target color from available colors excluding black\n    target_color = random.choice(Color.NOT_BLACK)\n    other_colors = [color for color in Color.NOT_BLACK if color != target_color]\n\n    # Place a few objects of the target color\n    for _ in range(3):\n        obj = random_sprite(list(range(1, 4)), list(range(1, 4)), color_palette=[target_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    # Place some objects of other colors\n    for _ in range(3):\n        obj = random_sprite(list(range(1, 4)), list(range(1, 4)), color_palette=other_colors)\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# The input consists of multiple objects of various colors on a grid.\n# To create the output, identify and select all objects that are composed entirely of a specified target color.\n# Output a grid where only these selected objects are preserved in their original positions and colors, while all other grid cells are set to background color (0).\n\ndef main(input_grid: np.ndarray, target_color: int) -> np.ndarray:\n    # Plan:\n    # 1. Extract all connected components from the input grid.\n    # 2. Filter out components that are not entirely of the target color.\n    # 3. Create an output grid with only the selected components preserved.\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Filter components that are entirely of the target color\n    target_objects = [obj for obj in objects if np.all((obj[obj != Color.BLACK] == target_color))]\n\n    # Blit the target objects onto the output grid\n    for obj in target_objects:\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -> Tuple[np.ndarray, int]:\n    # Generate a grid with multiple colored objects\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select a target color\n    target_color = random.choice(Color.NOT_BLACK)\n\n    # Generate random objects and place them into the grid\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        color_palette = [random.choice(Color.NOT_BLACK) for _ in range(2)]\n        if target_color not in color_palette:\n            color_palette.append(target_color)\n        sprite = random_sprite(list(range(2, 5)), list(range(2, 5)), color_palette=color_palette)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n            grid = blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# The input consists of a grid with multiple objects of various colors.\n# A target color is specified, and the task is to identify and select all objects that are entirely composed of this target color.\n# The output is a grid where only these selected objects are preserved in their original positions and colors, \n# while all other grid cells are set to the background color (0).\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Plan:\n    # 1. Extract all connected components in the grid.\n    # 2. Filter out components that are not entirely composed of the target color.\n    # 3. Create an output grid where only the selected components are preserved.\n\n    # 1. Extract all connected components in the grid\n    components = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    # 2. Filter out components that are not entirely composed of the target color\n    selected_components = [comp for comp in components if np.all(comp[comp != Color.BLACK] == target_color)]\n\n    # 3. Create an output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Place the selected components into the output grid\n    for comp in selected_components:\n        output_grid = blit_object(output_grid, comp, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Create a grid with multiple objects of various colors\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Select a target color randomly\n    target_color = random.choice(list(Color.NOT_BLACK))\n\n    # Generate and place objects of various colors\n    for _ in range(np.random.randint(5, 10)):\n        color = random.choice(list(Color.NOT_BLACK))\n        obj = random_sprite(list(range(2, 4)), list(range(2, 4)), color_palette=[color])\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    # Add at least one object entirely composed of the target color\n    while True:\n        obj = random_sprite(list(range(2, 4)), list(range(2, 4)), color_palette=[target_color])\n        x, y = random_free_location_for_sprite(grid, obj, padding=1)\n        if not collision(object1=grid, object2=obj, x2=x, y2=y):\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n            break\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# Input consists of multiple objects of various colors on a grid. Identify and select all objects that are composed entirely of a specified target color.\n# Output a grid where only these selected objects are preserved in their original positions and colors, while all other grid cells are set to background color (0).\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Create an output grid initialized to the background color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Iterate through each object and check if it is composed entirely of the target color\n    for obj in objects:\n        if np.all((obj == target_color) | (obj == Color.BLACK)):\n            # If the object is entirely of the target color, place it on the output grid\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Select a random target color from Color.NOT_BLACK\n    target_color = random.choice(Color.NOT_BLACK)\n\n    # Number of objects to generate\n    num_objects = random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Randomly decide if the object will be of the target color or another color\n        if random.random() < 0.5:\n            obj_color = target_color\n        else:\n            obj_color = random.choice([color for color in Color.NOT_BLACK if color != target_color])\n\n        # Generate a random object of size between 2x2 to 4x4\n        obj = random_sprite(list(range(2, 5)), list(range(2, 5)), color_palette=[obj_color])\n\n        # Try to place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            # If there's no space to place the object, break the loop\n            break\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# The input consists of multiple objects of various colors on a grid.\n# Identify and select all objects that are composed entirely of a specified target color.\n# Output a grid where only these selected objects are preserved in their original positions and colors, while all other grid cells are set to background color (0).\n\ndef main(input_grid, target_color):\n    # Find all connected components with monochromatic=True\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Create an output grid initialized with the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Filter out objects that match the target color and blit them onto the output grid\n    for obj in objects:\n        if np.any(obj == target_color):  # Check if the object is composed of the target color\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose a random target color from available colors\n    target_color = random.choice(list(Color.NOT_BLACK))\n\n    # Place several objects of various colors in the grid\n    num_objects = np.random.randint(5, 10)\n    for _ in range(num_objects):\n        obj_color = random.choice(list(Color.NOT_BLACK))\n        obj = random_sprite(n=np.random.randint(1, 4), m=np.random.randint(1, 4), color_palette=[obj_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1, border_size=1)\n            grid = blit_sprite(grid, obj, x, y)\n        except ValueError:\n            continue\n\n    # Ensure at least one object of the target color is placed\n    obj = random_sprite(n=np.random.randint(1, 4), m=np.random.randint(1, 4), color_palette=[target_color])\n    try:\n        x, y = random_free_location_for_sprite(grid, obj, padding=1, border_size=1)\n        grid = blit_sprite(grid, obj, x, y)\n    except ValueError:\n        pass\n\n    return grid, target_color", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# specific color selection, connected components, filtering\n\n# description:\n# The input consists of multiple objects of various colors on a grid. \n# Identify and select all objects that are composed entirely of a specified target color.\n# Output a grid where only these selected objects are preserved in their original positions and colors, \n# while all other grid cells are set to the background color (0).\n\ndef main(input_grid: np.ndarray, target_color: str) -> np.ndarray:\n    # Plan:\n    # 1. Extract the objects from the input grid using find_connected_components.\n    # 2. Filter the objects to keep only those that are entirely composed of the target color.\n    # 3. Create an output grid with the same dimensions as the input grid.\n    # 4. Blit the selected objects onto the output grid, preserving their original positions and colors.\n\n    # Extract objects\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Filter objects to keep only those composed entirely of the target color\n    selected_objects = [obj for obj in objects if np.all(obj[obj != Color.BLACK] == target_color)]\n\n    # Create an output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Blit the selected objects onto the output grid\n    for obj in selected_objects:\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, str]:\n    # Create a grid with random objects of various colors\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose a target color\n    target_color = random.choice(list(Color.NOT_BLACK))\n    \n    # Add objects to the grid\n    num_objects = np.random.randint(5, 10)\n    for _ in range(num_objects):\n        # Randomly decide if this object will be the target color or not\n        is_target = random.choice([True, False])\n\n        # Choose color for the object\n        color = target_color if is_target else random.choice([c for c in Color.NOT_BLACK if c != target_color])\n\n        # Generate a random object\n        obj = random_sprite(list(range(2, 5)), list(range(2, 5)), color_palette=[color])\n\n        # Try to place the object on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1, border_size=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no location can be found, continue to the next object\n            continue\n\n    return grid, target_color"], "seeds": ["d2abd087.py", "31aa019c.py", "137eaa0f.py", "48d8fb45.py", "Concepts: \nspecific color selection, connected components, filtering\n\nDescription: \nInput consists of multiple objects of various colors on a grid. Identify and select all objects that are composed entirely of a specified target color. Output a grid where only these selected objects are preserved in their original positions and colors, while all other grid cells are set to background color (0)."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, position-based transformation, expansion\n\n# description:\n# In the input grid, there is a uniquely colored guide object (e.g., teal), which will act as the starting point.\n# The task is to expand this guide object in a specific direction determined by its position: \n# - If it's in the top half of the grid, expand upwards.\n# - If it's in the bottom half, expand downwards.\n# - If it's in the left half, expand leftwards.\n# - If it's in the right half, expand rightwards.\n# The expansion continues until it hits another object or the edge of the grid.\n\ndef main(input_grid):\n    # Find the guide object based on its unique color\n    guide_color = Color.TEAL\n    guide_object = detect_objects(input_grid, colors=[guide_color], monochromatic=True, connectivity=8)[0]\n    \n    # Determine the position of the guide object\n    x, y, width, height = bounding_box(guide_object)\n    grid_height, grid_width = input_grid.shape\n    \n    # Decide the direction based on the position of the guide object\n    direction = None\n    if y + height / 2 < grid_height / 2:\n        direction = 'up'\n    elif y + height / 2 >= grid_height / 2:\n        direction = 'down'\n    elif x + width / 2 < grid_width / 2:\n        direction = 'left'\n    elif x + width / 2 >= grid_width / 2:\n        direction = 'right'\n\n    # Create the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Perform the expansion in the chosen direction\n    if direction == 'up':\n        for i in range(y, -1, -1):\n            if np.any(input_grid[i, x:x+width] != Color.BLACK):\n                break\n            output_grid[i, x:x+width] = guide_color\n    elif direction == 'down':\n        for i in range(y + height, grid_height):\n            if np.any(input_grid[i, x:x+width] != Color.BLACK):\n                break\n            output_grid[i, x:x+width] = guide_color\n    elif direction == 'left':\n        for i in range(x, -1, -1):\n            if np.any(input_grid[y:y+height, i] != Color.BLACK):\n                break\n            output_grid[y:y+height, i] = guide_color\n    elif direction == 'right':\n        for i in range(x + width, grid_width):\n            if np.any(input_grid[y:y+height, i] != Color.BLACK):\n                break\n            output_grid[y:y+height, i] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place the guide object (teal) at a random position\n    guide_sprite = np.full((1, 1), Color.TEAL)\n    x, y = random_free_location_for_sprite(grid, guide_sprite, border_size=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Optionally add random objects to the grid\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.ALL_COLORS - {Color.TEAL, Color.BLACK}))\n        obj_sprite = random_sprite(2, 2, color_palette=[obj_color], symmetry='not_symmetric')\n        try:\n            x, y = random_free_location_for_sprite(grid, obj_sprite, border_size=1)\n            blit_sprite(grid, obj_sprite, x, y)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, starting point, position-based transformation\n\n# description:\n# In the input, you will see a grid with various colored objects.\n# One object will have a distinct guide color, which is unique and does not appear in any other object.\n# Starting from the guide object, you will perform a transformation that flips the position of each object vertically with respect to the guide's horizontal line.\n# The output grid should have all objects flipped vertically around the guide object's horizontal line.\n\ndef main(input_grid):\n    # Detect all objects in the grid, considering them to be monochromatic\n    objects = find_connected_components(grid=input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Find the guide object based on its unique color\n    all_colors = [object_colors(obj, background=Color.BLACK) for obj in objects]\n    guide_color = [color for color in all_colors if all_colors.count(color) == 1][0]\n    guide_object = [obj for obj in objects if guide_color in object_colors(obj, background=Color.BLACK)][0]\n    \n    # Determine the horizontal line of the guide object\n    guide_x, guide_y, guide_w, guide_h = bounding_box(guide_object)\n    guide_horizontal_line = guide_x + guide_h // 2\n    \n    output_grid = np.copy(input_grid)\n    \n    # Flip all objects vertically with respect to the guide's horizontal line\n    for obj in objects:\n        if guide_color not in object_colors(obj, background=Color.BLACK):\n            x, y, w, h = bounding_box(obj)\n            translated_obj = translate(obj, x=2 * (guide_horizontal_line - x) - h, y=0, background=Color.BLACK)\n            blit_object(output_grid, translated_obj, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n    \n    # Define possible colors excluding black\n    colors = list(Color.NOT_BLACK)\n    np.random.shuffle(colors)\n    \n    # Select a guide color\n    guide_color = colors.pop()\n    \n    # Create the guide object with a unique color\n    guide_sprite = random_sprite(2, 2, color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK)\n    blit_sprite(grid, guide_sprite, x, y)\n    \n    # Add random other objects with different colors\n    for _ in range(np.random.randint(3, 5)):\n        color = colors.pop()\n        sprite = random_sprite(np.random.randint(2, 3), np.random.randint(2, 3), color_palette=[color])\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y)\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, starting point, position-based transformation\n\n# description:\n# In the input, you will see a grid with multiple colored objects. One of these objects is distinct, colored in teal, and serves as a guide object.\n# The task is to find the guide object and use its position as a reference point to rotate all other objects 90 degrees clockwise around it in the grid.\n\ndef main(input_grid):\n    # Find the guide object, which is uniquely colored in teal\n    guide_objects = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=8)\n    assert len(guide_objects) == 1, \"There should be exactly one guide object\"\n    guide_object = guide_objects[0]\n\n    # Find the position of the guide object\n    guide_x, guide_y, _, _ = bounding_box(guide_object, background=Color.BLACK)\n\n    # Prepare the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all other objects in the grid\n    other_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK - {Color.TEAL}, monochromatic=False, connectivity=8)\n\n    # Rotate each object 90 degrees clockwise around the guide's position\n    for obj in other_objects:\n        x, y, _, _ = bounding_box(obj, background=Color.BLACK)\n        translated_obj = translate(obj, -guide_x, -guide_y, background=Color.BLACK)\n        rotated_obj = np.rot90(translated_obj, k=-1) # Rotate 90 degrees clockwise\n        translated_back_obj = translate(rotated_obj, guide_x, guide_y, background=Color.BLACK)\n        blit_object(output_grid, translated_back_obj, background=Color.BLACK)\n\n    # Add the guide object back into the output grid\n    blit_object(output_grid, guide_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with random dimensions\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create the guide object in teal\n    guide_sprite = random_sprite(2, 2, color_palette=[Color.TEAL], connectivity=4)\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, guide_sprite, x, y, background=Color.BLACK)\n\n    # Create other random objects\n    for _ in range(np.random.randint(2, 4)):  # 2 to 3 other objects\n        color = np.random.choice(list(Color.NOT_BLACK - {Color.TEAL}))\n        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[color], connectivity=4)\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# Concepts:\n# guide object, position-based transformation, row and column manipulation\n\n# Description:\n# In the input, you will see a grid with various colored pixels and a distinct guide object of a unique color (e.g., TEAL).\n# The task is to locate the guide object and transform all other pixels in the same row and column to a new color (e.g., RED),\n# leaving the guide object itself unchanged.\n\ndef main(input_grid):\n    # Find the guide object, which is the only one with the color TEAL\n    guide_objects = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=4)\n    assert len(guide_objects) == 1, \"There should be exactly one guide object\"\n    \n    guide_object = guide_objects[0]\n    guide_x, guide_y, _, _ = bounding_box(guide_object, background=Color.BLACK)\n\n    # Create the output grid as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Change all pixels in the same row and column as the guide object to RED\n    output_grid[guide_x, :] = Color.RED\n    output_grid[:, guide_y] = Color.RED\n\n    # Restore the guide object to its original color\n    output_grid[guide_x, guide_y] = Color.TEAL\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Randomly fill the grid with colors\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a random position for the guide object\n    guide_x, guide_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[guide_x, guide_y] = Color.TEAL\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, position-based transformation, pattern expansion\n\n# description:\n# In the input grid, you will find a distinct guide object with a unique color, which serves as the starting point.\n# From this guide position, expand a specific pattern outward, filling in a predetermined shape or pattern until a border or another object is encountered.\n\ndef main(input_grid):\n    # Detect all the objects in the grid to find the guide object\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Identify the guide object by its unique color\n    guide_color = None\n    for obj in objects:\n        colors = object_colors(obj)\n        if len(colors) == 1 and colors[0] != Color.BLACK:\n            guide_color = colors[0]\n            guide_object = obj\n            break\n\n    assert guide_color is not None, \"Guide object with a unique color not found\"\n\n    # Get the starting position of the guide object\n    guide_x, guide_y, _, _ = bounding_box(guide_object)\n\n    # Create a copy of the input grid to start the transformation\n    output_grid = np.copy(input_grid)\n\n    # Define the pattern to be expanded, e.g., a cross pattern\n    pattern = [\n        (0, 0),  # center\n        (-1, 0), (1, 0),  # vertical line\n        (0, -1), (0, 1)  # horizontal line\n    ]\n\n    # Expand the pattern from the guide position\n    for dx, dy in pattern:\n        x, y = guide_x + dx, guide_y + dy\n        if 0 <= x < output_grid.shape[0] and 0 <= y < output_grid.shape[1]:\n            if output_grid[x, y] == Color.BLACK:  # fill only empty spaces\n                output_grid[x, y] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select a unique color for the guide object\n    guide_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the guide object at a random location\n    guide_sprite = np.array([[guide_color]])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Optionally add some obstacles to make the transformation more interesting\n    obstacle_count = np.random.randint(1, 4)\n    for _ in range(obstacle_count):\n        obstacle_color = np.random.choice(Color.NOT_BLACK)\n        if obstacle_color != guide_color:\n            obstacle_sprite = random_sprite(1, 1, color_palette=[obstacle_color])\n            try:\n                x, y = random_free_location_for_sprite(grid, obstacle_sprite, background=Color.BLACK, padding=1)\n                blit_sprite(grid, obstacle_sprite, x, y)\n            except ValueError:\n                continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, guide object, position-based transformation\n\n# description:\n# In the input, you will see a grid with colored objects. One object has a unique color and acts as a guide.\n# Detect the guide object and use its position as the center to rotate all other objects 90 degrees clockwise around it.\n# The guide object remains unchanged.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Identify the guide object by its unique color (assuming it's the only object with that color)\n    guide_object = None\n    guide_color = None\n    for obj in objects:\n        colors = object_colors(obj, background=Color.BLACK)\n        if len(colors) == 1:\n            color = colors[0]\n            if guide_object is None or color != guide_color:\n                guide_object = obj\n                guide_color = color\n\n    if guide_object is None:\n        raise ValueError(\"No guide object found\")\n\n    # Calculate the guide object's center position\n    gx, gy, gw, gh = bounding_box(guide_object, background=Color.BLACK)\n    guide_center = (gx + gw // 2, gy + gh // 2)\n\n    # Prepare the output grid\n    output_grid = np.copy(input_grid)\n\n    for obj in objects:\n        if np.any(obj != guide_object):\n            # Calculate object's center\n            x, y, w, h = bounding_box(obj, background=Color.BLACK)\n            obj_center = (x + w // 2, y + h // 2)\n\n            # Calculate new position after 90-degree clockwise rotation\n            new_x = guide_center[0] - (obj_center[1] - guide_center[1])\n            new_y = guide_center[1] + (obj_center[0] - guide_center[0])\n\n            # Translate the object to the new position\n            translated_obj = translate(obj, new_x - x, new_y - y, background=Color.BLACK)\n            blit_object(output_grid, translated_obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select a unique color for the guide object\n    guide_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Generate the guide object\n    guide_sprite = random_sprite(2, 2, color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Generate other objects with different colors\n    for _ in range(np.random.randint(3, 6)):\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != guide_color])\n        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[color])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, starting point, rotation, position-based transformation\n\n# description:\n# In the input, you will see a grid with various colored objects. One of these objects is the guide, identified by its unique color.\n# To make the output, use the guide object's position as the pivot to rotate all other objects by 90 degrees clockwise around it.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # Identify the guide object by its unique color\n    color_counts = {}\n    for obj in objects:\n        color = object_colors(obj, background=Color.BLACK)[0]\n        if color not in color_counts:\n            color_counts[color] = 0\n        color_counts[color] += 1\n    \n    # The guide object is the one with a unique color\n    guide_color = next(color for color, count in color_counts.items() if count == 1)\n    guide_object = next(obj for obj in objects if guide_color in object_colors(obj, background=Color.BLACK))\n    \n    # Find the position of the guide object\n    guide_x, guide_y, _, _ = bounding_box(guide_object, background=Color.BLACK)\n\n    # Prepare the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Rotate each object around the guide object's position\n    for obj in objects:\n        if guide_color in object_colors(obj, background=Color.BLACK):\n            blit_object(output_grid, obj, background=Color.BLACK)\n        else:\n            # Calculate the object's center\n            x, y, w, h = bounding_box(obj, background=Color.BLACK)\n            center_x, center_y = x + w // 2, y + h // 2\n\n            # Calculate new position after 90 degrees clockwise rotation around the guide object\n            new_x = guide_x - (center_y - guide_y)\n            new_y = guide_y + (center_x - guide_x)\n\n            # Translate the object to the new position\n            translated_obj = translate(obj, new_x - x, new_y - y, background=Color.BLACK)\n            blit_object(output_grid, translated_obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select colors, ensuring one is unique\n    num_objects = np.random.randint(3, 6)\n    colors = np.random.choice(Color.NOT_BLACK, num_objects + 1, replace=False)\n    guide_color = colors[0]\n    other_colors = colors[1:]\n\n    # Create and place a guide object\n    guide_sprite = random_sprite(2, 2, color_palette=[guide_color], symmetry='not_symmetric')\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Create and place other objects\n    for color in other_colors:\n        sprite_size = np.random.randint(2, 4)\n        sprite = random_sprite(sprite_size, sprite_size, color_palette=[color], symmetry='not_symmetric')\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, starting point, position-based transformation\n\n# description:\n# In the input, you will see a grid with various colored objects. One of these objects is distinct in color and acts as a guide.\n# The transformation is to rotate all other objects around the guide object's center by 90 degrees clockwise.\n# The guide object does not change its position or orientation.\n\ndef main(input_grid):\n    # Step 1: Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Step 2: Identify the guide object by its unique color\n    guide_object = max(objects, key=lambda obj: max(np.sum(obj == color) for color in Color.NOT_BLACK))\n    guide_color = next(color for color in Color.NOT_BLACK if np.any(guide_object == color))\n\n    # Step 3: Identify the position of the guide object\n    guide_x, guide_y, _, _ = bounding_box(guide_object, background=Color.BLACK)\n\n    # Step 4: Create output grid and perform transformation on other objects\n    output_grid = np.copy(input_grid)\n\n    for obj in objects:\n        if np.any(obj == guide_color):\n            # Skip the guide object itself\n            continue\n\n        # Rotate the object 90 degrees clockwise around the guide's center\n        obj_sprite = crop(obj, background=Color.BLACK)\n        rotated_sprite = np.rot90(obj_sprite, k=-1)\n\n        # Find the center of the original object\n        obj_x, obj_y, obj_w, obj_h = bounding_box(obj, background=Color.BLACK)\n        obj_center_x, obj_center_y = obj_x + obj_w // 2, obj_y + obj_h // 2\n\n        # Calculate new position after rotation\n        new_x = guide_x + (obj_center_y - guide_y)\n        new_y = guide_y - (obj_center_x - guide_x)\n\n        # Blit the rotated object into the output grid\n        blit_sprite(output_grid, rotated_sprite, x=new_x - rotated_sprite.shape[0] // 2, y=new_y - rotated_sprite.shape[1] // 2)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random guide object with a unique color\n    guide_color = np.random.choice(Color.NOT_BLACK)\n    guide_sprite = random_sprite(3, 3, color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Generate other objects with random colors and place them on the grid\n    for _ in range(np.random.randint(3, 6)):\n        obj_color = np.random.choice([c for c in Color.NOT_BLACK if c != guide_color])\n        obj_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[obj_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj_sprite, background=Color.BLACK, border_size=1)\n            blit_sprite(grid, obj_sprite, x, y)\n        except ValueError:\n            continue\n\n    return grid"], "seeds": ["aedd82e4.py", "05f2a901.py", "57aa92db.py", "a8c38be5.py", "Concepts: \nguide object, starting point, position-based transformation\n\nDescription: \nIdentify a distinct guide object within the grid. Use the position of this guide object as a starting point for a transformation or operation. The specific transformation depends on the task context, but it consistently initiates from the guide's position. The guide's position is determined by its unique color or shape, and the transformation is deterministic based on this starting point."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# In the input grid, you will see one object with a unique color (the guide object) on a black background.\n# You need to draw a line from one edge of this guide object to another edge, following a path specified in the input grid.\n# The line should replace the black pixels along the path, using the guide object's color.\n# All other non-black pixels remain unchanged.\n\ndef main(input_grid):\n    # Step 1: Find the guide object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    guide_object = max(objects, key=lambda obj: len(np.argwhere(obj != Color.BLACK)))\n\n    # Step 2: Determine the color of the guide object\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Step 3: Determine the path for the line drawing\n    # Assume the path is represented by a series of coordinates in the input grid\n    path = np.argwhere(input_grid == guide_color)\n\n    # Step 4: Draw the line along the path using the guide object's color\n    output_grid = input_grid.copy()\n    for x, y in path:\n        output_grid[x, y] = guide_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a 10x10 grid as the base\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Generate a random guide object\n    guide_color = np.random.choice(Color.NOT_BLACK)\n    guide_object = random_sprite(3, 3, density=0.7, color_palette=[guide_color])\n\n    # Place the guide object at a random location on the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, border_size=1)\n    blit_sprite(grid, guide_object, x, y)\n\n    # Create a path using the guide object's color\n    # The path will be a simple L-shape or zigzag within the bounds of the grid\n    path_length = np.random.randint(3, 7)\n    for i in range(path_length):\n        grid[x + i, y] = guide_color\n        if i % 2 == 0:\n            grid[x + i, y + 1] = guide_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# In the input grid, identify a guide object with a unique color.\n# Use this color to draw a line from a start point to an end point.\n# The line should overwrite background cells only, leaving other cells unchanged.\n\ndef main(input_grid):\n    # Find the guide object with a unique color\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    guide_object = None\n    guide_color = None\n    for obj in objects:\n        unique_colors = np.unique(obj[obj != Color.BLACK])\n        if len(unique_colors) == 1:\n            guide_object = obj\n            guide_color = unique_colors[0]\n            break\n\n    assert guide_object is not None, \"No guide object found\"\n\n    # Determine the start and end points for the line\n    # For simplicity, let's assume they are selected randomly for this example\n    x1, y1 = np.random.randint(0, input_grid.shape[0]), np.random.randint(0, input_grid.shape[1])\n    x2, y2 = np.random.randint(0, input_grid.shape[0]), np.random.randint(0, input_grid.shape[1])\n\n    # Draw the line using the guide object's color\n    output_grid = np.copy(input_grid)\n    draw_line(output_grid, x1, y1, end_x=x2, end_y=y2, color=guide_color, stop_at_color=Color.NOT_BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a unique colored guide object\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Place a guide object with a unique color\n    guide_color = np.random.choice(list(Color.ALL_COLORS - {Color.BLACK}))\n    guide_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[guide_color])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, border_size=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# In the input grid, you will find a guide object with a unique color. Using this color, draw a line connecting two specified points or along a given path. \n# The path should be defined such that the line can overwrite background cells but should leave any non-background cells unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find all the connected components in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Assume the first non-background object is the guide object\n    guide_object = next(obj for obj in objects if np.any(obj != Color.BLACK))\n    guide_color = np.unique(guide_object[guide_object != Color.BLACK])[0]\n\n    # Determine two random points in the grid where we can draw the line\n    height, width = input_grid.shape\n    start_x, start_y = np.random.randint(0, height), np.random.randint(0, width)\n    end_x, end_y = np.random.randint(0, height), np.random.randint(0, width)\n\n    # Ensure the start and end points are on the background to allow line drawing\n    while input_grid[start_x, start_y] != Color.BLACK:\n        start_x, start_y = np.random.randint(0, height), np.random.randint(0, width)\n\n    while input_grid[end_x, end_y] != Color.BLACK:\n        end_x, end_y = np.random.randint(0, height), np.random.randint(0, width)\n\n    # Draw a line using the guide object's color from the start to the end point\n    draw_line(output_grid, start_x, start_y, end_x=end_x, end_y=end_y, color=guide_color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a guide object with a unique color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_object = random_sprite(2, 2, density=1, color_palette=[guide_color])\n\n    # Place the guide object randomly on the grid\n    x, y = random_free_location_for_sprite(grid, guide_object, padding=1)\n    blit_sprite(grid, guide_object, x=x, y=y)\n\n    # Optionally, add some obstacles with other colors\n    obstacle_colors = list(Color.NOT_BLACK - {guide_color})\n    for _ in range(np.random.randint(1, 5)):\n        obstacle_color = np.random.choice(obstacle_colors)\n        obstacle = random_sprite(np.random.randint(1, 3), np.random.randint(1, 3), density=0.5, color_palette=[obstacle_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obstacle, padding=1)\n            blit_sprite(grid, obstacle, x=x, y=y)\n        except ValueError:\n            continue\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# In the input grid, you will see a guide object colored in a unique color and two points marked with different colors.\n# Use the guide object's color to draw a straight line connecting the two points, overwriting the background cells.\n# Ensure that the line only passes through background cells and does not overwrite any non-background colored cells.\n\ndef main(input_grid):\n    # Identify the unique guide object color\n    unique_colors = set(np.unique(input_grid))\n    guide_color = next((color for color in unique_colors if np.sum(input_grid == color) == 1), None)\n\n    # Ensure guide color is identified\n    assert guide_color is not None, \"Guide object color not found\"\n\n    # Find the positions of the two points (assuming they are marked with different colors)\n    point_positions = [(x, y) for x, y in np.argwhere(input_grid != Color.BLACK) if input_grid[x, y] != guide_color]\n\n    # Ensure exactly two points are identified\n    assert len(point_positions) == 2, \"Exactly two points must be marked with different colors\"\n\n    # Extract the start and end points\n    (start_x, start_y), (end_x, end_y) = point_positions\n\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Draw the line between the two points using the guide object's color\n    draw_line(output_grid, start_x, start_y, end_x=end_x, end_y=end_y, color=guide_color, stop_at_color=list(Color.NOT_BLACK))\n\n    return output_grid\n\ndef generate_input():\n    # Define grid dimensions\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly choose a unique guide color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place the guide object (single pixel) at a random location\n    guide_x, guide_y = np.random.randint(0, grid_size, size=2)\n    grid[guide_x, guide_y] = guide_color\n\n    # Randomly choose two distinct colors for the points\n    point_colors = np.random.choice(list(Color.NOT_BLACK - {guide_color}), size=2, replace=False)\n\n    # Select random locations for the two points ensuring they are not the same or on the guide object\n    point1_x, point1_y = guide_x, guide_y\n    point2_x, point2_y = guide_x, guide_y\n    while (point1_x == guide_x and point1_y == guide_y) or (point2_x == guide_x and point2_y == guide_y) or (point1_x == point2_x and point1_y == point2_y):\n        point1_x, point1_y = np.random.randint(0, grid_size, size=2)\n        point2_x, point2_y = np.random.randint(0, grid_size, size=2)\n\n    # Place the points on the grid\n    grid[point1_x, point1_y] = point_colors[0]\n    grid[point2_x, point2_y] = point_colors[1]\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# In the input grid, you will find a unique guide object colored with a distinct color. The task is to use this guide object's color to draw a line between two specified points or along a specified path on the grid. The line should overwrite the background cells with the guide object's color, while all other non-background cells remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the grid, assuming one of them is the guide object\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Identify the guide object by its unique color\n    guide_object = None\n    guide_color = None\n    for obj in objects:\n        # Extract the unique color in the object\n        unique_color = np.unique(obj[obj != Color.BLACK])\n        if len(unique_color) == 1:\n            guide_object = obj\n            guide_color = unique_color[0]\n            break\n\n    if guide_object is None or guide_color is None:\n        raise ValueError(\"No unique guide object found.\")\n\n    # Define the start and end points of the line to be drawn\n    # For the sake of this puzzle, let's assume a specific start and end point\n    start_point = (1, 1)\n    end_point = (output_grid.shape[0] - 2, output_grid.shape[1] - 2)\n\n    # Draw the line using the guide object's color\n    draw_line(output_grid, x=start_point[0], y=start_point[1], end_x=end_point[0], end_y=end_point[1], color=guide_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random size grid\n    n = np.random.randint(10, 20)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Create a unique guide object with a random color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    guide_object = random_sprite(n=3, m=3, density=1, color_palette=[guide_color])\n\n    # Place the guide object in a random location on the grid\n    x, y = random_free_location_for_sprite(input_grid, guide_object, border_size=1, padding=1)\n    blit_sprite(input_grid, guide_object, x=x, y=y)\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# Identify a guide object with a unique color in the grid.\n# Use this color to draw a line between two specified points or along a specified path.\n# The line is drawn by overwriting the background cells with the guide object's color.\n# All other non-background cells remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Find all connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Identify the guide object by finding the unique colored component\n    for component in components:\n        color = np.unique(component[component != Color.BLACK])\n        if len(color) == 1:\n            guide_color = color[0]\n            break\n\n    # Define start and end points for the line\n    # For demonstration, we'll assume the start point is the top-left corner and the end point is the bottom-right corner of the grid\n    start_point = (0, 0)\n    end_point = (input_grid.shape[0] - 1, input_grid.shape[1] - 1)\n\n    # Use the guide color to draw the line\n    draw_line(output_grid, x=start_point[0], y=start_point[1], end_x=end_point[0], end_y=end_point[1], color=guide_color)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select a guide color from the available colors\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create a unique guide object\n    guide_obj = np.full((2, 2), guide_color)\n    \n    # Place the guide object in the grid at a random free location\n    x, y = random_free_location_for_sprite(grid, guide_obj, border_size=1)\n    blit_sprite(grid, guide_obj, x, y)\n\n    # Add random colored objects in the grid to increase complexity\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.NOT_BLACK - {guide_color}))\n        obj_size = np.random.randint(2, 4)\n        obj = random_sprite(obj_size, obj_size, density=0.5, color_palette=[obj_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, border_size=1)\n            blit_sprite(grid, obj, x, y)\n        except ValueError:\n            continue  # Skip adding this object if no space is available\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# In the input grid, there is a guide object of a unique color and two specific points marked in red and blue respectively.\n# The task is to draw a line from the red point to the blue point using the color of the guide object. \n# The line should overwrite any background cells but not affect other colored cells.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    # Identify the guide object by finding the unique color that isn't background, red, or blue\n    guide_color = None\n    for obj in objects:\n        unique_colors = set(np.unique(obj))\n        unique_colors -= {Color.BLACK, Color.RED, Color.BLUE}\n        if unique_colors:\n            guide_color = unique_colors.pop()\n            break\n    \n    assert guide_color is not None, \"Guide object not found\"\n\n    # Find the positions of the red and blue points\n    red_position = np.argwhere(input_grid == Color.RED)[0]\n    blue_position = np.argwhere(input_grid == Color.BLUE)[0]\n\n    # Copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n    \n    # Draw the line using the guide color\n    draw_line(output_grid, red_position[0], red_position[1], end_x=blue_position[0], end_y=blue_position[1], color=guide_color, stop_at_color=[Color.RED, Color.BLUE])\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random size between 10x10 and 20x20\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK, dtype=int)\n    \n    # Generate a random guide object\n    guide_sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[np.random.choice(list(Color.NOT_BLACK - {Color.RED, Color.BLUE}))])\n    x, y = random_free_location_for_sprite(grid, guide_sprite, border_size=1)\n    blit_sprite(grid, guide_sprite, x, y)\n\n    # Mark two points with red and blue\n    red_x, red_y = random_free_location_for_sprite(grid, np.ones((1, 1)), padding=1, border_size=1)\n    grid[red_x, red_y] = Color.RED\n    \n    blue_x, blue_y = random_free_location_for_sprite(grid, np.ones((1, 1)), padding=1, border_size=1)\n    grid[blue_x, blue_y] = Color.BLUE\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n\n# concepts:\n# guide object, color transfer, line drawing\n\n# description:\n# Identify a guide object with a unique color in the grid. Use this color to draw a line between two specified points or along a specified path.\n# The line is drawn by overwriting the background cells with the guide object's color. All other non-background cells remain unchanged.\n\ndef main(input_grid):\n    # Find all objects in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n    \n    # We assume there is exactly one object with a unique color that acts as the guide\n    guide_object = None\n    for obj in objects:\n        unique_colors = np.unique(obj[obj != Color.BLACK])\n        if len(unique_colors) == 1:\n            guide_object = obj\n            guide_color = unique_colors[0]\n            break\n\n    if guide_object is None:\n        raise ValueError(\"No guide object found\")\n\n    # Find the bounding box of the guide object to determine the start and end points for the line\n    x, y, w, h = bounding_box(guide_object)\n    \n    # For simplicity, draw a line from the top-left to the bottom-right corner of the bounding box\n    start_x, start_y = x, y\n    end_x, end_y = x + w - 1, y + h - 1\n    \n    # Create the output grid by copying the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Draw the line using the guide object's color\n    draw_line(output_grid, start_x, start_y, end_x=end_x, end_y=end_y, color=guide_color)\n    \n    return output_grid\n\n\ndef generate_input():\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a unique color for the guide object\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create a guide object with a random shape\n    guide_object = random_sprite(n=[2, 3], m=[2, 3], density=0.8, color_palette=[guide_color])\n\n    # Find a random location to place the guide object\n    x, y = random_free_location_for_sprite(grid, guide_object, border_size=1)\n    blit_sprite(grid, guide_object, x, y)\n    \n    # Optionally, add other random objects with different colors to the grid\n    num_other_objects = np.random.randint(1, 3)\n    for _ in range(num_other_objects):\n        color = np.random.choice(list(Color.NOT_BLACK - {guide_color}))\n        random_object = random_sprite(n=[2, 3], m=[2, 3], density=0.6, color_palette=[color])\n        try:\n            x, y = random_free_location_for_sprite(grid, random_object, border_size=1)\n            blit_sprite(grid, random_object, x, y)\n        except ValueError:\n            continue\n    \n    return grid"], "seeds": ["941d9a10.py", "6e19193c.py", "810b9b61.py", "2dd70a9a.py", "Concepts: \nguide object, color transfer, line drawing\n\nDescription: \nIdentify a guide object with a unique color in the grid. Use this color to draw a line between two specified points or along a specified path. The line is drawn by overwriting the background cells with the guide object's color. All other non-background cells remain unchanged."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# Input is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask,\n# where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template\n# for identifying the pattern in other grid regions.\n\ndef main(input_grid):\n    # Define a simple predicate function for demonstration.\n    # This predicate returns True if the color is not black.\n    def predicate(color):\n        return color != Color.BLACK\n\n    # Initialize an output grid with the same shape as the input grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Evaluate the predicate function on each cell of the input grid\n    mask = np.vectorize(predicate)(input_grid)\n\n    # Fill the corresponding cells in the output grid with a color (e.g., yellow) where the mask is True\n    output_grid[mask] = Color.YELLOW\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter a few colors into the grid\n    num_colors = np.random.randint(1, 5)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    for color in colors:\n        randomly_scatter_points(grid, color=color, density=0.3)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# Input is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for identifying the pattern in other grid regions.\n\ndef main(input_grid, predicate):\n    # Initialize a boolean mask with the same shape as the input grid\n    mask = np.full(input_grid.shape, False)\n    \n    # Apply the predicate function to each cell in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if predicate(input_grid[x, y]):\n                mask[x, y] = True\n    \n    return mask\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.random.choice(list(Color.NOT_BLACK), (n, m), replace=True)\n    \n    # Define a predicate function that checks if a color is in the first half of the color list\n    color_list = list(Color.NOT_BLACK)\n    predicate = lambda color: color_list.index(color) < len(color_list) // 2\n    \n    return grid, predicate", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# The input is a grid region (block) and a predicate function. For each cell in the block, evaluate the predicate to produce a boolean mask. \n# The mask will have True at locations where the predicate is satisfied, otherwise False. This mask acts as a template for identifying patterns.\n\ndef main(input_grid, predicate):\n    # Create a boolean mask of the same shape as the input grid\n    mask = np.full(input_grid.shape, False)\n\n    # Evaluate the predicate at each cell in the grid\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if predicate(input_grid[i, j]):\n                mask[i, j] = True\n\n    return mask\n\ndef generate_input():\n    # Generate a grid of random size between 5x5 and 20x20\n    n, m = np.random.randint(5, 20, size=2)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n\n    # Define a random predicate function\n    color_to_match = np.random.choice(list(Color.NOT_BLACK))\n    def predicate(color):\n        return color == color_to_match\n\n    return grid, predicate", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# The input is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask,\n# where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for\n# identifying the pattern in other grid regions.\n\ndef main(input_grid, predicate):\n    # Create a boolean mask of the same shape as the input grid\n    mask = np.zeros_like(input_grid, dtype=bool)\n\n    # Evaluate the predicate function at each cell in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            mask[x, y] = predicate(input_grid[x, y])\n\n    return mask\n\n\ndef generate_input():\n    # Randomly generate a grid size between 5x5 and 15x15\n    n, m = np.random.randint(5, 16), np.random.randint(5, 16)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n    \n    # Define a random predicate function based on a random color\n    target_color = np.random.choice(list(Color.NOT_BLACK))\n    predicate = lambda color: color == target_color\n    \n    return grid, predicate", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# The input is a grid and a predicate function. The task is to evaluate the predicate at each cell in the grid to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for identifying similar patterns in other grid regions.\n\ndef main(input_grid, predicate):\n    # Create the boolean mask by applying the predicate to each cell in the input grid\n    boolean_mask = np.array([[predicate(input_grid[x, y]) for y in range(input_grid.shape[1])] for x in range(input_grid.shape[0])])\n\n    # Find connected components in the boolean mask that are True\n    components = find_connected_components(boolean_mask, background=False, connectivity=8, monochromatic=False)\n\n    # Convert the components to patterns (sprites)\n    patterns = [crop(component) for component in components]\n\n    # Create an output grid to visualize the pattern recognition\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each pattern, find a matching region in the input grid and highlight it\n    for pattern in patterns:\n        pattern_height, pattern_width = pattern.shape\n        for x in range(input_grid.shape[0] - pattern_height + 1):\n            for y in range(input_grid.shape[1] - pattern_width + 1):\n                region = input_grid[x:x+pattern_height, y:y+pattern_width]\n                if np.array_equal(region, pattern):\n                    blit_sprite(output_grid, pattern, x, y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.random.choice(list(Color.NOT_BLACK), (n, m))\n\n    # Randomly select a color to satisfy the predicate, e.g., Color.RED\n    predicate_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Define a predicate function that returns True for the selected color\n    def predicate(color):\n        return color == predicate_color\n\n    # Return the grid and predicate function\n    return grid, predicate", "from common import *\n\nimport numpy as np\nfrom typing import Callable\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# The input is a grid and a predicate function. The predicate function is applied to each cell of the grid to determine if the condition is met. \n# The output is a boolean mask of the same size, where each cell is True if the predicate is satisfied at that location, otherwise False. \n# This mask can serve as a reusable template for identifying the pattern in other grid regions.\n\ndef main(input_grid: np.ndarray, predicate: Callable[[int], bool]) -> np.ndarray:\n    # Create a boolean mask with the same dimensions as the input grid\n    boolean_mask = np.zeros_like(input_grid, dtype=bool)\n\n    # Iterate over each cell in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Evaluate the predicate on the current cell's value\n            if predicate(input_grid[x, y]):\n                # Set the corresponding cell in the boolean mask to True\n                boolean_mask[x, y] = True\n\n    return boolean_mask\n\n\ndef generate_input() -> Tuple[np.ndarray, Callable[[int], bool]]:\n    # Randomly generate grid dimensions\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.random.choice(list(Color.NOT_BLACK), (n, m))\n\n    # Define a random predicate function\n    chosen_color = np.random.choice(list(Color.NOT_BLACK))\n    predicate = lambda color: color == chosen_color\n\n    return grid, predicate", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# The input is a grid region (block) and a predicate function. The task is to evaluate the predicate at each cell in the block \n# to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. \n# This mask serves as a reusable template for identifying the pattern in other grid regions.\n\ndef main(input_grid):\n    # Define a sample predicate function: Check if the color is not black\n    def predicate(color):\n        return color != Color.BLACK\n\n    # Create a boolean mask by evaluating the predicate at each grid cell\n    mask = np.array([\n        [predicate(input_grid[x, y]) for y in range(input_grid.shape[1])]\n        for x in range(input_grid.shape[0])\n    ])\n\n    return mask\n\ndef generate_input():\n    # Randomly generate a grid size\n    width, height = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly scatter colors across the grid\n    for color in np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(3, 6), replace=False):\n        randomly_scatter_points(grid, color=color, density=0.3)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# The input is a grid region (block) and a predicate function. The task is to evaluate the predicate at each cell in the block to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for identifying the pattern in other grid regions.\n\ndef main(input_grid, predicate):\n    # Create a boolean mask based on the predicate function\n    mask = np.zeros(input_grid.shape, dtype=bool)\n\n    # Evaluate predicate for each cell in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            mask[x, y] = predicate(input_grid[x, y])\n\n    return mask\n\ndef generate_input():\n    # Generate a grid of random size with a random color background\n    n = np.random.randint(5, 15)\n    m = np.random.randint(5, 15)\n    grid = np.random.choice(list(Color.NOT_BLACK), (n, m))\n\n    # Define a random predicate function\n    selected_color = np.random.choice(list(Color.NOT_BLACK))\n    predicate = lambda cell_color: cell_color == selected_color\n\n    return grid, predicate"], "seeds": ["00d62c1b.py", "90c28cc7.py", "bc1d5164.py", "780d0b14.py", "Concepts: \nboolean mask, predicate evaluation, pattern recognition, template creation\n\nDescription: \nInput is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for identifying the pattern in other grid regions."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# Given an input grid with specified 3x3 window coordinates and a predicate function, for each cell within the window,\n# check if it satisfies the predicate. If not, replace its value with a specified fill_value. \n# Cells that satisfy the predicate remain unchanged. This operation completes the pattern within the window by filling only the non-matching cells.\n\ndef main(input_grid: Tuple[np.ndarray, Tuple[int, int], Callable[[str], bool], str]) -> np.ndarray:\n    grid, (window_x, window_y), predicate, fill_value = input_grid\n    \n    # Extract the 3x3 window from the grid\n    window = grid[window_x:window_x+3, window_y:window_y+3]\n\n    # Create a new 3x3 window for the output\n    output_window = np.copy(window)\n\n    # Check each cell in the window\n    for i in range(3):\n        for j in range(3):\n            if not predicate(window[i, j]):\n                output_window[i, j] = fill_value\n\n    # Copy the modified window back to the grid\n    output_grid = np.copy(grid)\n    output_grid[window_x:window_x+3, window_y:window_y+3] = output_window\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, Tuple[int, int], Callable[[str], bool], str]:\n    # Create a random grid of size between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n\n    # Randomly choose a starting point for the 3x3 window such that it fits within the grid\n    window_x = np.random.randint(0, n - 2)\n    window_y = np.random.randint(0, m - 2)\n\n    # Define a predicate function that checks if a color is one of a specified set\n    valid_colors = {random.choice(list(Color.NOT_BLACK)) for _ in range(3)}\n    predicate = lambda color: color in valid_colors\n\n    # Choose a fill value that is not in the valid_colors set\n    fill_value = random.choice(list(Color.NOT_BLACK.difference(valid_colors)))\n\n    return grid, (window_x, window_y), predicate, fill_value", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# Input is a grid with specific 3x3 window coordinates and a predicate function. \n# For each cell within the specified 3x3 window, check if it satisfies the predicate. \n# If a cell does not satisfy the predicate, replace its value with a specified fill_value. \n# This operation completes the pattern within the window by filling only the non-matching cells.\n\ndef main(input_grid: np.ndarray, window_coords: Tuple[int, int], predicate: Callable[[int], bool], fill_value: int) -> np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    \n    # Extract the 3x3 window using the provided coordinates\n    x, y = window_coords\n    window = input_grid[x:x+3, y:y+3]\n    \n    # Process each cell in the window\n    for i in range(3):\n        for j in range(3):\n            cell_value = window[i, j]\n            if not predicate(cell_value):\n                # Replace the value if it does not satisfy the predicate\n                output_grid[x+i, y+j] = fill_value\n    \n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, Tuple[int, int], Callable[[int], bool], int]:\n    # Randomly generate a grid of size between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.random.choice(Color.NOT_BLACK, size=(n, m))\n    \n    # Randomly choose coordinates for a 3x3 window within the grid\n    x, y = np.random.randint(0, n-2), np.random.randint(0, m-2)\n    \n    # Define a simple predicate function\n    def predicate(color: int) -> bool:\n        # Example predicate: color should be even-indexed in the list of all colors\n        all_colors = list(Color.NOT_BLACK)\n        return all_colors.index(color) % 2 == 0\n    \n    # Randomly choose a fill_value that is not black\n    fill_value = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLACK])\n    \n    return grid, (x, y), predicate, fill_value", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# Input is a grid with specific 3x3 window coordinates and a predicate function.\n# For each cell within the specified 3x3 window, check if it satisfies the predicate.\n# If a cell does not satisfy the predicate, replace its value with a specified fill_value.\n# Cells that satisfy the predicate remain unchanged. This operation completes the pattern\n# within the window by filling only the non-matching cells.\n\ndef main(input_grid: np.ndarray, window_coords: Tuple[int, int], predicate: Callable[[int], bool], fill_value: int) -> np.ndarray:\n    # Copy the input_grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    \n    # Extracting the 3x3 window starting at window_coords\n    x_start, y_start = window_coords\n    x_end, y_end = x_start + 3, y_start + 3\n    \n    # Iterate over each cell in the 3x3 window\n    for x in range(x_start, x_end):\n        for y in range(y_start, y_end):\n            # Check if the current cell satisfies the predicate\n            if not predicate(output_grid[x, y]):\n                # If not, replace its value with the fill_value\n                output_grid[x, y] = fill_value\n    \n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, Tuple[int, int], Callable[[int], bool], int]:\n    # Create a random grid with dimensions between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n    \n    # Randomly choose a 3x3 window starting position, ensuring it fits within the grid\n    x_start = np.random.randint(0, n - 2)\n    y_start = np.random.randint(0, m - 2)\n    window_coords = (x_start, y_start)\n    \n    # Define a random predicate function\n    def random_predicate(value: int) -> bool:\n        # Example predicate: returns True if the value is even\n        return value % 2 == 0\n    \n    # Choose a fill_value different from the current grid colors\n    fill_value = np.random.choice(list(set(Color.NOT_BLACK) - {grid[x, y] for x in range(n) for y in range(m)}))\n    \n    return grid, window_coords, random_predicate, fill_value", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# Input is a grid with specific 3x3 window coordinates and a predicate function.\n# For each cell within the specified 3x3 window, check if it satisfies the predicate.\n# If a cell does not satisfy the predicate, replace its value with a specified fill_value.\n# Cells that satisfy the predicate remain unchanged.\n# This operation completes the pattern within the window by filling only the non-matching cells.\n\ndef main(input_data: Tuple[np.ndarray, Tuple[int, int], Callable[[int], bool], int]) -> np.ndarray:\n    input_grid, window_coords, predicate, fill_value = input_data\n\n    # Extract the 3x3 window coordinates\n    x_start, y_start = window_coords\n    x_end, y_end = x_start + 3, y_start + 3\n\n    # Make a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Process each cell within the 3x3 window\n    for x in range(x_start, x_end):\n        for y in range(y_start, y_end):\n            if not predicate(input_grid[x, y]):\n                # Replace the cell value with the fill_value if predicate is not satisfied\n                output_grid[x, y] = fill_value\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, Tuple[int, int], Callable[[int], bool], int]:\n    # Create a random grid of size 10x10 with colors from 0 to 9 (non-black)\n    grid_size = 10\n    grid = np.random.choice(Color.NOT_BLACK, size=(grid_size, grid_size))\n\n    # Randomly choose a top-left corner for the 3x3 window within the grid\n    x_start = np.random.randint(0, grid_size - 3)\n    y_start = np.random.randint(0, grid_size - 3)\n\n    # Define a random predicate function (e.g., check if color is even)\n    predicate = lambda color: color % 2 == 0\n\n    # Choose a random fill value from the color palette\n    fill_value = np.random.choice(Color.NOT_BLACK)\n\n    return grid, (x_start, y_start), predicate, fill_value", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# In the input, you will receive a grid, specific 3x3 window coordinates, and a predicate function.\n# For each cell within the specified 3x3 window, check if it satisfies the predicate.\n# If a cell does not satisfy the predicate, replace its value with a specified fill_value.\n# Cells that satisfy the predicate remain unchanged. The operation completes the pattern within the window by filling only the non-matching cells.\n\ndef main(input_grid: np.ndarray, window_coords: Tuple[int, int], predicate: Callable[[int], bool], fill_value: int) -> np.ndarray:\n    # Extract the 3x3 window from the input grid\n    x, y = window_coords\n    window = input_grid[x:x+3, y:y+3]\n\n    # Iterate through each cell in the 3x3 window\n    for i in range(3):\n        for j in range(3):\n            # Check if the cell satisfies the predicate\n            if not predicate(window[i, j]):\n                # If not, replace with fill_value\n                window[i, j] = fill_value\n\n    # Place the modified window back into the output grid\n    output_grid = np.copy(input_grid)\n    output_grid[x:x+3, y:y+3] = window\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, Tuple[int, int], Callable[[int], bool], int]:\n    # Create a grid filled with random colors\n    grid_size = np.random.randint(6, 10)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(grid_size, grid_size))\n\n    # Randomly select the top-left corner of a 3x3 window within the grid\n    window_x = np.random.randint(0, grid_size - 2)\n    window_y = np.random.randint(0, grid_size - 2)\n\n    # Define a random predicate function (e.g., checks if a color is 'BLUE')\n    def predicate(color):\n        return color == Color.BLUE\n\n    # Select a random fill_value different from 'BLUE'\n    fill_value = random.choice([color for color in Color.NOT_BLACK if color != Color.BLUE])\n\n    return grid, (window_x, window_y), predicate, fill_value", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# The input is a grid with specific 3x3 window coordinates and a predicate function.\n# For each cell within the specified 3x3 window, check if it satisfies the predicate.\n# If a cell does not satisfy the predicate, replace its value with a specified fill_value.\n# Cells that satisfy the predicate remain unchanged.\n\ndef main(input_grid, window_coords, predicate, fill_value):\n    # Extract the 3x3 window based on the provided coordinates\n    x_start, y_start = window_coords\n    x_end, y_end = x_start + 3, y_start + 3\n    \n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Process each cell within the 3x3 window\n    for x in range(x_start, x_end):\n        for y in range(y_start, y_end):\n            # Check if the cell satisfies the predicate\n            if not predicate(input_grid[x, y]):\n                # If not, replace its value with the fill_value\n                output_grid[x, y] = fill_value\n    \n    return output_grid\n\ndef generate_input():\n    # Define the grid size\n    grid_size = np.random.randint(5, 10)\n    grid = np.random.choice(Color.NOT_BLACK, size=(grid_size, grid_size))\n    \n    # Randomly pick a 3x3 window within the grid\n    x_start = np.random.randint(0, grid_size - 2)\n    y_start = np.random.randint(0, grid_size - 2)\n    window_coords = (x_start, y_start)\n    \n    # Define the predicate function (example: check if the color is in a specific subset)\n    colors_subset = np.random.choice(Color.NOT_BLACK, size=3, replace=False)\n    predicate = lambda color: color in colors_subset\n    \n    # Define the fill value (a random color not in the subset)\n    fill_value = np.random.choice([color for color in Color.NOT_BLACK if color not in colors_subset])\n    \n    return grid, window_coords, predicate, fill_value\n\n# Example usage:\n# input_grid, window_coords, predicate, fill_value = generate_input()\n# transformed_grid = main(input_grid, window_coords, predicate, fill_value)", "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# Input is a grid with specific 3x3 window coordinates and a predicate function. \n# For each cell within the specified 3x3 window, check if it satisfies the predicate. \n# If a cell does not satisfy the predicate, replace its value with a specified fill_value. \n# Cells that satisfy the predicate remain unchanged. This operation completes the pattern \n# within the window by filling only the non-matching cells.\n\ndef main(input_grid: np.ndarray, window_coords: Tuple[int, int], predicate: Callable[[int], bool], fill_value: int) -> np.ndarray:\n    \"\"\"\n    Apply the specified transformation to the input grid.\n    \"\"\"\n    # Extract the specified 3x3 window from the input grid\n    x, y = window_coords\n    window = input_grid[x:x+3, y:y+3]\n\n    # Process each cell in the window and apply the predicate\n    for i in range(window.shape[0]):\n        for j in range(window.shape[1]):\n            if not predicate(window[i, j]):\n                window[i, j] = fill_value\n\n    # Update the grid with the transformed window\n    output_grid = np.copy(input_grid)\n    output_grid[x:x+3, y:y+3] = window\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, Tuple[int, int], Callable[[int], bool], int]:\n    \"\"\"\n    Generate a new input for the puzzle including the grid, window coordinates, predicate function, and fill value.\n    \"\"\"\n    # Create a grid with random colors\n    grid_size = random.randint(6, 10)  # Ensure the grid is large enough for at least one 3x3 window\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(grid_size, grid_size))\n\n    # Choose random coordinates for a 3x3 window\n    x = random.randint(0, grid_size - 3)\n    y = random.randint(0, grid_size - 3)\n    window_coords = (x, y)\n\n    # Define a predicate function (e.g., check if the color is not black)\n    predicate = lambda color: color != Color.BLACK\n\n    # Choose a random fill value (different from black)\n    fill_value = random.choice([color for color in Color.ALL_COLORS if color != Color.BLACK])\n\n    return grid, window_coords, predicate, fill_value", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# window processing, predicate check, conditional fill, grid manipulation\n\n# description:\n# In the input you will see a grid with specific 3x3 window coordinates and a predicate function.\n# For each cell within the specified 3x3 window, check if it satisfies the predicate.\n# If a cell does not satisfy the predicate, replace its value with a specified fill_value.\n# Cells that satisfy the predicate remain unchanged.\n\ndef main(input_grid: np.ndarray, window_coords: Tuple[int, int], predicate: Callable[[Any], bool], fill_value: Any) -> np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    \n    # Extract the starting coordinates of the 3x3 window\n    start_x, start_y = window_coords\n    \n    # Process the 3x3 window\n    for i in range(3):\n        for j in range(3):\n            x = start_x + i\n            y = start_y + j\n\n            # Check if the cell satisfies the predicate\n            if not predicate(input_grid[x, y]):\n                # If not, replace with the fill_value\n                output_grid[x, y] = fill_value\n\n    return output_grid\n\ndef generate_input() -> Tuple[np.ndarray, Tuple[int, int], Callable[[Any], bool], Any]:\n    # Create a grid of random colors with size between 10x10 to 15x15\n    grid_size = np.random.randint(10, 16)\n    grid = np.random.choice(Color.NOT_BLACK, size=(grid_size, grid_size))\n\n    # Choose a random starting point for a 3x3 window within the grid\n    start_x = np.random.randint(0, grid_size - 3)\n    start_y = np.random.randint(0, grid_size - 3)\n    window_coords = (start_x, start_y)\n    \n    # Define a random predicate function, e.g., check if the color is not BLACK\n    predicate = lambda color: color != Color.BLACK\n    \n    # Choose a fill_value different from the colors in the grid\n    fill_value = Color.BLACK\n\n    return grid, window_coords, predicate, fill_value"], "seeds": ["90c28cc7.py", "25d8a9c8.py", "1e32b0e9.py", "09629e4f.py", "Concepts: \nwindow processing, predicate check, conditional fill, grid manipulation\n\nDescription: \nInput is a grid with specific 3x3 window coordinates and a predicate function. For each cell within the specified 3x3 window, check if it satisfies the predicate. If a cell does not satisfy the predicate, replace its value with a specified fill_value. Cells that satisfy the predicate remain unchanged. This operation completes the pattern within the window by filling only the non-matching cells."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sliding window, color presence, pattern matching, window selection\n\n# description:\n# Input is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n\ndef main(input_grid: np.ndarray, required_colors: Set[str]) -> Tuple[int, int]:\n    \"\"\"\n    Slide a 3x3 window over the grid and find the first window that contains at least one cell of each required color.\n    Return the top-left coordinates of this window.\n    \"\"\"\n\n    # Get the dimensions of the input grid\n    rows, cols = input_grid.shape\n\n    # Iterate over each possible 3x3 window in the grid\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            # Extract the 3x3 window\n            window = input_grid[i:i+3, j:j+3]\n            # Get the set of colors present in this window\n            window_colors = set(window.flatten())\n            # Check if all required colors are present in the window\n            if required_colors.issubset(window_colors):\n                return (i, j)\n    \n    # If no suitable window is found, return None\n    return None\n\ndef generate_input() -> Tuple[np.ndarray, Set[str]]:\n    \"\"\"\n    Generate a random input grid and a set of required colors.\n    \"\"\"\n    # Define grid size\n    grid_size = random.randint(5, 10)\n\n    # Create a random grid of colors excluding black\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(grid_size, grid_size))\n\n    # Randomly choose 3 to 5 required colors from the available color set\n    required_colors = set(random.sample(list(Color.NOT_BLACK), random.randint(3, 5)))\n\n    return grid, required_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sliding window, color presence, pattern matching, window selection\n\n# description:\n# Input is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n\ndef main(input_grid: np.ndarray, required_colors: Set[Color]) -> Tuple[int, int]:\n    rows, cols = input_grid.shape\n    \n    # Slide a 3x3 window over the grid\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            window = input_grid[i:i+3, j:j+3]\n            window_colors = set(window.flatten())\n            \n            # Check if the window contains all required colors\n            if required_colors.issubset(window_colors):\n                return (i, j)\n    \n    raise ValueError(\"No window contains all required colors\")\n\ndef generate_input() -> Tuple[np.ndarray, Set[Color]]:\n    # Generate a grid of size between 5x5 and 10x10\n    grid_size = np.random.randint(5, 11)\n    grid = np.random.choice(list(Color.NOT_BLACK), (grid_size, grid_size))\n    \n    # Randomly select a set of required colors\n    num_required_colors = np.random.randint(2, 4)\n    required_colors = set(np.random.choice(list(Color.NOT_BLACK), num_required_colors, replace=False))\n    \n    return grid, required_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sliding window, color presence, pattern matching, window selection\n\n# description:\n# The input is a grid with various colors. Slide a 3x3 window over the grid.\n# Identify the first window that contains at least one cell of every color specified in a given set of required colors.\n# Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n\ndef main(input_grid: np.ndarray, required_colors: Set[str]) -> Tuple[int, int]:\n    rows, cols = input_grid.shape\n\n    # Slide a 3x3 window over the grid\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            # Extract a 3x3 window\n            window = input_grid[i:i+3, j:j+3]\n\n            # Flatten the window and get a set of colors present in it\n            window_colors = set(window.flatten())\n\n            # Check if all required colors are present in the window\n            if required_colors.issubset(window_colors):\n                return (i, j)  # Return the top-left corner of the window\n\n    return (-1, -1)  # Return an invalid position if no such window is found\n\n\ndef generate_input() -> Tuple[np.ndarray, Set[str]]:\n    # Generate a grid of random size between 5x5 and 10x10\n    rows = np.random.randint(5, 11)\n    cols = np.random.randint(5, 11)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(rows, cols))\n\n    # Randomly select a subset of colors as the required colors\n    required_colors = set(np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(2, 5), replace=False))\n\n    return grid, required_colors", "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# sliding window, color presence, pattern matching, window selection\n\n# description:\n# Input is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n\ndef main(input_grid: np.ndarray, required_colors: Set[str]) -> Tuple[int, int]:\n    rows, cols = input_grid.shape\n    \n    # Slide a 3x3 window over the grid\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            # Extract the current 3x3 window\n            window = input_grid[i:i+3, j:j+3]\n            # Find unique colors in the current window\n            unique_colors_in_window = set(np.unique(window))\n            \n            # Check if all required colors are present in the window\n            if required_colors.issubset(unique_colors_in_window):\n                return (i, j)\n    \n    # Return None if no valid window is found (although it's assumed one will be present in the puzzle)\n    return None\n\ndef generate_input() -> Tuple[np.ndarray, Set[str]]:\n    # Define grid size\n    grid_size = random.randint(5, 10)\n    grid = np.empty((grid_size, grid_size), dtype=object)\n    \n    # Fill the grid with random colors\n    for i in range(grid_size):\n        for j in range(grid_size):\n            grid[i, j] = random.choice(list(Color.NOT_BLACK))\n    \n    # Select a random set of required colors\n    required_colors = set(random.sample(list(Color.NOT_BLACK), random.randint(3, 5)))\n    \n    # Ensure at least one 3x3 window meets the required colors condition\n    # Randomly choose a starting position for this window\n    start_x = random.randint(0, grid_size - 3)\n    start_y = random.randint(0, grid_size - 3)\n    \n    # Fill this window with at least the required colors\n    for color in required_colors:\n        rand_x = start_x + random.randint(0, 2)\n        rand_y = start_y + random.randint(0, 2)\n        grid[rand_x, rand_y] = color\n    \n    return grid, required_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sliding window, color presence, pattern matching, window selection\n\n# description:\n# Input is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n\ndef main(input_grid: np.ndarray, required_colors: Set[str]) -> Tuple[int, int]:\n    # Slide a 3x3 window over the grid\n    rows, cols = input_grid.shape\n    window_size = 3\n\n    for i in range(rows - window_size + 1):\n        for j in range(cols - window_size + 1):\n            # Extract the 3x3 window\n            window = input_grid[i:i+window_size, j:j+window_size]\n            # Get unique colors in the window\n            unique_colors_in_window = set(np.unique(window))\n            # Check if all required colors are present in the window\n            if required_colors.issubset(unique_colors_in_window):\n                return (i, j)\n    \n    # If no such window is found, return a sentinel value indicating failure\n    return (-1, -1)\n\ndef generate_input() -> Tuple[np.ndarray, Set[str]]:\n    # Randomly generate a grid with a size between 5x5 and 10x10\n    n = random.randint(5, 10)\n    grid = np.random.choice(list(Color.NOT_BLACK), (n, n))\n\n    # Select a random subset of colors to be the required colors\n    required_colors = set(random.sample(list(Color.NOT_BLACK), random.randint(2, 5)))\n\n    # Ensure at least one valid window exists\n    # Randomly choose a position to place a valid window\n    valid_x = random.randint(0, n - 3)\n    valid_y = random.randint(0, n - 3)\n    # Place required colors in this window\n    for idx, color in enumerate(required_colors):\n        # Ensure each color is placed within the window\n        grid[valid_x + idx % 3, valid_y + idx // 3] = color\n\n    return grid, required_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sliding window, color presence, pattern matching, window selection\n\n# description:\n# The input is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n\ndef main(input_grid: np.ndarray, required_colors: Set[int]) -> Tuple[int, int]:\n    \"\"\"Find the first 3x3 window containing all the required colors.\"\"\"\n    rows, cols = input_grid.shape\n    \n    # Iterate over each possible top-left corner of a 3x3 window\n    for x in range(rows - 2):\n        for y in range(cols - 2):\n            # Extract the 3x3 window\n            window = input_grid[x:x+3, y:y+3]\n            # Flatten the window and create a set of colors present in it\n            colors_in_window = set(window.flatten())\n            \n            # Check if all required colors are present in the window\n            if required_colors.issubset(colors_in_window):\n                return (x, y)  # Return the top-left corner of the first valid window\n    \n    return (-1, -1)  # Return invalid coordinates if no such window exists\n\n\ndef generate_input() -> Tuple[np.ndarray, Set[int]]:\n    \"\"\"Generate random input grid and required colors.\"\"\"\n    grid_size = np.random.randint(5, 10)  # Random grid size between 5x5 to 10x10\n    grid = np.random.choice(list(Color.NOT_BLACK), (grid_size, grid_size))\n    \n    # Randomly choose some colors from the available colors to be the required colors\n    required_colors_count = np.random.randint(1, 4)  # Random number of required colors between 1 and 3\n    required_colors = set(np.random.choice(list(Color.NOT_BLACK), required_colors_count, replace=False))\n    \n    return grid, required_colors", "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\ndef main(input_grid: np.ndarray, required_colors: Set[int]) -> Tuple[int, int]:\n    # Slide the 3x3 window over the input grid\n    rows, cols = input_grid.shape\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            window = input_grid[i:i+3, j:j+3]\n            colors_in_window = set(window.flatten())\n            if required_colors.issubset(colors_in_window):\n                return (i, j)\n    raise ValueError(\"No window contains all required colors\")\n\n\ndef generate_input() -> Tuple[np.ndarray, Set[int]]:\n    # Grid size should be at least 3x3\n    grid_size = random.randint(5, 10)\n    grid = np.random.choice(list(Color.NOT_BLACK), (grid_size, grid_size))\n    \n    # Randomly select a subset of colors as required\n    required_colors = set(random.sample(list(Color.NOT_BLACK), random.randint(2, 5)))\n\n    # Ensure at least one 3x3 window contains all required colors\n    x, y = random.randint(0, grid_size - 3), random.randint(0, grid_size - 3)\n    unique_required_colors = random.sample(list(required_colors), len(required_colors))\n    \n    for idx, color in enumerate(unique_required_colors):\n        grid[x + (idx // 3), y + (idx % 3)] = color\n\n    return grid, required_colors", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sliding window, color presence, pattern matching, window selection\n\n# description:\n# Given an input grid with various colors, slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors.\n# Output the coordinates of the top-left corner of this window. The task is to locate a heterogeneous anchor window based on color presence criteria.\n\ndef main(input_grid: np.ndarray, required_colors: Set[str]) -> Tuple[int, int]:\n    \"\"\"\n    Slide a 3x3 window over the grid and find the first window that contains all the required colors.\n    Return the coordinates of the top-left corner of this window.\n    \"\"\"\n\n    # Get dimensions of the grid\n    n, m = input_grid.shape\n\n    # Iterate over all possible 3x3 windows in the grid\n    for i in range(n - 2):\n        for j in range(m - 2):\n            # Extract the 3x3 window\n            window = input_grid[i:i+3, j:j+3]\n            \n            # Flatten the window to a 1D array and convert it to a set of colors\n            window_colors = set(window.flatten())\n            \n            # Check if this window contains all required colors\n            if required_colors.issubset(window_colors):\n                return (i, j)\n\n    # If no window matches the criteria, return an indication (e.g., (-1, -1))\n    return (-1, -1)\n\n\ndef generate_input() -> Tuple[np.ndarray, Set[str]]:\n    \"\"\"\n    Generates a random grid and a set of required colors for the puzzle.\n    The grid will have a size between 5x5 and 10x10, and the required colors will be a random subset of available colors.\n    \"\"\"\n\n    # Define possible grid size and colors\n    grid_size = random.randint(5, 10)\n    available_colors = list(Color.NOT_BLACK)\n\n    # Create an empty grid\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly fill the grid with colors\n    for i in range(grid_size):\n        for j in range(grid_size):\n            grid[i, j] = random.choice(available_colors)\n\n    # Select a random subset of colors as the required colors for the window\n    required_colors_count = random.randint(2, len(available_colors))\n    required_colors = set(random.sample(available_colors, required_colors_count))\n\n    return grid, required_colors"], "seeds": ["06df4c85.py", "00d62c1b.py", "09629e4f.py", "31aa019c.py", "Concepts: \nsliding window, color presence, pattern matching, window selection\n\nDescription: \nInput is a grid with various colors. Slide a 3x3 window over the grid. Identify the first window that contains at least one cell of every color specified in a given set of required colors. Output the coordinates of this window. The task is to locate a heterogeneous anchor window based on color presence criteria."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# You are given a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size.\n# A predicate function is applied to each cell in the window to create a boolean mask.\n# Return True if this generated mask exactly matches the given pattern_mask element-wise, with no rotations or flips allowed.\n# Otherwise, return False.\n\ndef main(input_data):\n    window, pattern_mask = input_data\n\n    # Define the predicate function\n    def predicate(cell_value):\n        # Example predicate: checking if the cell is a non-black color\n        return cell_value != Color.BLACK\n    \n    # Apply the predicate to the window to create a boolean mask\n    generated_mask = np.array([[predicate(cell) for cell in row] for row in window])\n\n    # Compare the generated mask with the pattern mask\n    match = np.array_equal(generated_mask, pattern_mask)\n\n    return match\n\ndef generate_input():\n    # Create a 3x3 window with random colors\n    window = np.random.choice(list(Color.NOT_BLACK), size=(3, 3))\n    \n    # Randomly generate a boolean pattern_mask\n    pattern_mask = np.random.choice([True, False], size=(3, 3))\n\n    # Adjust the mask to include at least one True value to ensure variability\n    if not np.any(pattern_mask):\n        x, y = np.random.randint(0, 3), np.random.randint(0, 3)\n        pattern_mask[x, y] = True\n\n    return window, pattern_mask", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# Input is a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size. A predicate function is applied to each cell in the window to create a boolean mask.\n# Return True if this generated mask exactly matches the given pattern_mask element-wise, with no rotations or flips allowed. Otherwise, return False.\n\ndef main(window: np.ndarray, pattern_mask: np.ndarray) -> bool:\n    # Define a predicate function, for example, checking if a cell is a non-black color\n    def predicate(color):\n        return color != Color.BLACK\n\n    # Apply the predicate function to each cell in the window\n    generated_mask = np.vectorize(predicate)(window)\n\n    # Compare the generated mask with the pattern mask\n    return np.array_equal(generated_mask, pattern_mask)\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray]:\n    # Create a random 3x3 grid (window) with random colors\n    window = np.random.choice(list(Color.NOT_BLACK), size=(3, 3))\n\n    # Define a predicate function, for example, checking if a cell is a non-black color\n    def predicate(color):\n        return color != Color.BLACK\n\n    # Apply the predicate function to create a pattern mask\n    pattern_mask = np.vectorize(predicate)(window)\n\n    # Randomly alter some elements in the pattern mask to introduce stochastic behavior\n    for _ in range(np.random.randint(1, 4)):  # Randomly flip 1 to 3 elements\n        x, y = np.random.randint(0, 3), np.random.randint(0, 3)\n        pattern_mask[x][y] = not pattern_mask[x][y]\n\n    return window, pattern_mask", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# Input is a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size. \n# A predicate function is applied to each cell in the window to create a boolean mask.\n# Return True if this generated mask exactly matches the given pattern_mask element-wise, with no rotations or flips allowed. Otherwise, return False.\n\ndef main(input_data: Tuple[np.ndarray, np.ndarray]) -> bool:\n    input_grid, pattern_mask = input_data\n\n    # Define a simple predicate function\n    def predicate(cell):\n        return cell == Color.RED\n\n    # Apply the predicate to each cell in the input grid to generate a boolean mask\n    generated_mask = np.vectorize(predicate)(input_grid)\n\n    # Check if the generated mask matches the pattern mask\n    return np.array_equal(generated_mask, pattern_mask)\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray]:\n    # Create a 3x3 grid with random colors\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(3, 3))\n\n    # Define a pattern mask by randomly generating True or False values\n    pattern_mask = np.random.choice([True, False], size=(3, 3))\n\n    return grid, pattern_mask", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# Input is a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size. \n# A predicate function is applied to each cell in the window to create a boolean mask. \n# Return True if this generated mask exactly matches the given pattern_mask element-wise, \n# with no rotations or flips allowed. Otherwise, return False.\n\ndef main(input_window: np.ndarray, pattern_mask: np.ndarray, predicate_function) -> bool:\n    # Apply the predicate function to each element in the input window to generate a boolean mask\n    generated_mask = np.array([[predicate_function(cell) for cell in row] for row in input_window])\n    \n    # Check if the generated mask matches the pattern_mask exactly\n    return np.array_equal(generated_mask, pattern_mask)\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray, callable]:\n    # Create a random 3x3 grid with random colors from Color.NOT_BLACK\n    input_window = np.random.choice(list(Color.NOT_BLACK), size=(3, 3))\n    \n    # Define a random predicate function that checks if a color is in a subset of colors\n    possible_colors = list(Color.NOT_BLACK)\n    selected_colors = np.random.choice(possible_colors, size=np.random.randint(1, len(possible_colors)), replace=False)\n    predicate_function = lambda color: color in selected_colors\n    \n    # Generate a pattern mask by applying the predicate function to the input window\n    pattern_mask = np.array([[predicate_function(cell) for cell in row] for row in input_window])\n    \n    return input_window, pattern_mask, predicate_function", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# Input is a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size. \n# A predicate function is applied to each cell in the window to create a boolean mask. \n# Return True if this generated mask exactly matches the given pattern_mask element-wise, \n# with no rotations or flips allowed. Otherwise, return False.\n\ndef main(input_data: Tuple[np.ndarray, np.ndarray]) -> bool:\n    window, pattern_mask = input_data\n    \n    # Define the predicate function. For this example, we will consider non-black pixels as True.\n    predicate = lambda color: color != Color.BLACK\n    \n    # Apply the predicate function to the window to generate the boolean mask\n    generated_mask = np.vectorize(predicate)(window)\n    \n    # Compare the generated mask with the pattern_mask\n    return np.array_equal(generated_mask, pattern_mask)\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray]:\n    # Create a 3x3 grid (window) with random colors\n    window = np.random.choice(list(Color.ALL_COLORS), size=(3, 3))\n\n    # Create a pattern_mask of the same size, with True for non-black colors\n    pattern_mask = np.vectorize(lambda color: color != Color.BLACK)(window)\n    \n    # Randomly flip some of the True/False values in the pattern_mask to create variability\n    random_mask = np.random.choice([True, False], size=(3, 3), p=[0.8, 0.2])\n    pattern_mask = np.logical_and(pattern_mask, random_mask)\n    \n    return window, pattern_mask", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# In the input, you will see a colored 3x3 grid (window) and a boolean mask (pattern_mask) of the same size.\n# Apply a predicate function to each cell in the window to create a boolean mask.\n# Return True (a 1x1 grid with a blue pixel) if this generated mask exactly matches the given pattern_mask element-wise, with no rotations or flips allowed. Otherwise, return False (a 1x1 grid with an orange pixel).\n\ndef main(window, pattern_mask):\n    # Define the predicate function: in this case, we'll check if the color is not black\n    predicate = lambda color: color != Color.BLACK\n\n    # Generate a boolean mask by applying the predicate to each cell in the window\n    generated_mask = np.vectorize(predicate)(window)\n\n    # Compare the generated mask with the pattern_mask\n    if np.array_equal(generated_mask, pattern_mask):\n        # If they match exactly, output a 1x1 grid with a blue pixel\n        return np.array([[Color.BLUE]])\n    else:\n        # Otherwise, output a 1x1 grid with an orange pixel\n        return np.array([[Color.ORANGE]])\n\ndef generate_input():\n    # Create a random 3x3 grid (window) of colors\n    window = np.random.choice(list(Color.ALL_COLORS), size=(3, 3))\n\n    # Create a random boolean mask (pattern_mask) of the same size\n    pattern_mask = np.random.choice([True, False], size=(3, 3))\n\n    return window, pattern_mask", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# You are given a 3x3 grid (window) of colors and a boolean mask (pattern_mask) of the same size.\n# A predicate function is applied to each cell in the window to create a boolean mask.\n# Return a 1x1 grid with a green pixel if the generated mask matches the given pattern_mask exactly.\n# Otherwise, return a 1x1 grid with a red pixel. No rotations or flips are allowed in matching.\n\ndef main(input_data: Tuple[np.ndarray, np.ndarray]) -> np.ndarray:\n    window, pattern_mask = input_data\n    # Define a predicate function; for example, check if the color is not black\n    predicate = lambda color: color != Color.BLACK\n    \n    # Create a boolean mask by applying the predicate to each cell in the window\n    generated_mask = np.vectorize(predicate)(window)\n    \n    # Check if the generated mask matches the pattern_mask exactly\n    if np.array_equal(generated_mask, pattern_mask):\n        # If they match, return a 1x1 grid with a green pixel\n        return np.full((1,1), Color.GREEN)\n    else:\n        # Otherwise, return a 1x1 grid with a red pixel\n        return np.full((1,1), Color.RED)\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray]:\n    # Generate a 3x3 grid with random colors\n    window = np.random.choice(list(Color.NOT_BLACK), size=(3, 3))\n    \n    # Generate a random boolean pattern mask\n    pattern_mask = np.random.choice([True, False], size=(3, 3))\n    \n    return window, pattern_mask", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, boolean mask, predicate evaluation, exact match\n\n# description:\n# The input consists of a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size.\n# The task is to apply a predicate function to each cell in the window to create a boolean mask.\n# If the generated mask matches the given pattern_mask element-wise exactly (with no rotations or flips allowed), return True.\n# Otherwise, return False.\n\ndef main(input_data: Tuple[np.ndarray, np.ndarray]) -> bool:\n    input_grid, pattern_mask = input_data\n    \n    # Define the predicate function (e.g., check if the color is red)\n    def predicate(color):\n        return color == Color.RED\n    \n    # Generate the boolean mask by applying the predicate to each cell in the input grid\n    generated_mask = np.vectorize(predicate)(input_grid)\n    \n    # Check if the generated mask matches the pattern mask exactly\n    return np.array_equal(generated_mask, pattern_mask)\n\ndef generate_input() -> Tuple[np.ndarray, np.ndarray]:\n    # Create a 3x3 grid of randomly chosen colors\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(3, 3))\n    \n    # Randomly generate a boolean pattern mask of the same size\n    # The pattern mask indicates the shape we are trying to match\n    pattern_mask = np.random.choice([True, False], size=(3, 3))\n    \n    return grid, pattern_mask"], "seeds": ["25d8a9c8.py", "bc1d5164.py", "1e32b0e9.py", "44f52bb0.py", "Concepts: \npattern matching, boolean mask, predicate evaluation, exact match\n\nDescription: \nInput is a 3x3 grid (window) and a boolean mask (pattern_mask) of the same size. A predicate function is applied to each cell in the window to create a boolean mask. Return True if this generated mask exactly matches the given pattern_mask element-wise, with no rotations or flips allowed. Otherwise, return False."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# The input is a grid with various colors, including a target color (cyan).\n# For each row and column, detect and extract maximal contiguous runs of the target color.\n# Output these runs as lists of coordinates representing the start and end of each contiguous sequence of the target color.\n# Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal cyan runs in the grid.\n\ndef main(input_grid: np.ndarray) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    target_color = Color.TEAL\n    runs = []\n\n    # Scan rows for contiguous runs\n    for i in range(input_grid.shape[0]):\n        start = None\n        for j in range(input_grid.shape[1]):\n            if input_grid[i, j] == target_color:\n                if start is None:\n                    start = (i, j)\n            else:\n                if start is not None:\n                    end = (i, j - 1)\n                    if end[1] > start[1]:  # Ensure it's a run\n                        runs.append((start, end))\n                    start = None\n        # Check if the last segment in the row was a run\n        if start is not None:\n            end = (i, input_grid.shape[1] - 1)\n            if end[1] > start[1]:\n                runs.append((start, end))\n\n    # Scan columns for contiguous runs\n    for j in range(input_grid.shape[1]):\n        start = None\n        for i in range(input_grid.shape[0]):\n            if input_grid[i, j] == target_color:\n                if start is None:\n                    start = (i, j)\n            else:\n                if start is not None:\n                    end = (i - 1, j)\n                    if end[0] > start[0]:  # Ensure it's a run\n                        runs.append((start, end))\n                    start = None\n        # Check if the last segment in the column was a run\n        if start is not None:\n            end = (input_grid.shape[0] - 1, j)\n            if end[0] > start[0]:\n                runs.append((start, end))\n\n    return runs\n\n\ndef generate_input() -> np.ndarray:\n    # Create a grid size between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Fill the grid with random colors, including the target color (cyan)\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n\n    # Add some guaranteed runs of the target color (cyan)\n    num_runs = np.random.randint(1, 4)\n    for _ in range(num_runs):\n        if np.random.rand() < 0.5:  # Horizontal run\n            row = np.random.randint(0, n)\n            start_col = np.random.randint(0, m - 1)\n            end_col = np.random.randint(start_col + 1, m)\n            grid[row, start_col:end_col] = Color.TEAL\n        else:  # Vertical run\n            col = np.random.randint(0, m)\n            start_row = np.random.randint(0, n - 1)\n            end_row = np.random.randint(start_row + 1, n)\n            grid[start_row:end_row, col] = Color.TEAL\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# The input is a grid containing various colors, including a target color (green).\n# For each row and column, detect and extract maximal contiguous runs of the target color.\n# Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color.\n# Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal green runs in the grid.\n\ndef main(input_grid):\n    target_color = Color.GREEN\n    rows, cols = input_grid.shape\n    runs = []\n\n    # Scan each row for contiguous runs of the target color\n    for r in range(rows):\n        c = 0\n        while c < cols:\n            if input_grid[r, c] == target_color:\n                start_col = c\n                while c < cols and input_grid[r, c] == target_color:\n                    c += 1\n                if c - start_col > 1:\n                    runs.append((r, start_col, r, c - 1))\n            c += 1\n\n    # Scan each column for contiguous runs of the target color\n    for c in range(cols):\n        r = 0\n        while r < rows:\n            if input_grid[r, c] == target_color:\n                start_row = r\n                while r < rows and input_grid[r, c] == target_color:\n                    r += 1\n                if r - start_row > 1:\n                    runs.append((start_row, c, r - 1, c))\n            r += 1\n\n    return runs\n\ndef generate_input():\n    # Generate a grid of arbitrary size with a random background color and random colors scattered\n    n = random.randint(10, 15)\n    m = random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter various colors\n    num_colors = random.randint(3, 5)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n    for color in colors:\n        randomly_scatter_points(grid, color=color, density=0.1)\n\n    # Ensure there are some maximal contiguous runs of the green color\n    num_green_runs = random.randint(1, 3)\n    for _ in range(num_green_runs):\n        # Choose to create a run either in a row or a column\n        if random.choice([True, False]):\n            # Create a horizontal run\n            row = random.randint(0, n - 1)\n            start_col = random.randint(0, m - 4)\n            length = random.randint(2, m - start_col)\n            grid[row, start_col:start_col + length] = Color.GREEN\n        else:\n            # Create a vertical run\n            col = random.randint(0, m - 1)\n            start_row = random.randint(0, n - 4)\n            length = random.randint(2, n - start_row)\n            grid[start_row:start_row + length, col] = Color.GREEN\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# The input grid consists of various colors, including some pixels of a target color (red).\n# For each row and column, detect and extract maximal contiguous runs of the target color.\n# Output these runs as lists of coordinates, representing the start and end of each contiguous sequence of the target color.\n# Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal red runs in the grid.\n\ndef main(input_grid):\n    # Define the target color\n    target_color = Color.RED\n\n    # Initialize list to store maximal contiguous runs\n    contiguous_runs = []\n\n    # Scan each row for contiguous runs\n    for r in range(input_grid.shape[0]):\n        start = None\n        for c in range(input_grid.shape[1]):\n            if input_grid[r, c] == target_color:\n                if start is None:\n                    start = c\n            else:\n                if start is not None:\n                    if c - start > 1:  # Ensure it's more than an isolated pixel\n                        contiguous_runs.append(((r, start), (r, c - 1)))\n                    start = None\n\n        # Check at the end of the row\n        if start is not None and input_grid.shape[1] - start > 1:\n            contiguous_runs.append(((r, start), (r, input_grid.shape[1] - 1)))\n\n    # Scan each column for contiguous runs\n    for c in range(input_grid.shape[1]):\n        start = None\n        for r in range(input_grid.shape[0]):\n            if input_grid[r, c] == target_color:\n                if start is None:\n                    start = r\n            else:\n                if start is not None:\n                    if r - start > 1:\n                        contiguous_runs.append(((start, c), (r - 1, c)))\n                    start = None\n\n        # Check at the end of the column\n        if start is not None and input_grid.shape[0] - start > 1:\n            contiguous_runs.append(((start, c), (input_grid.shape[0] - 1, c)))\n\n    return contiguous_runs\n\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter various colors\n    for color in Color.NOT_BLACK:\n        randomly_scatter_points(grid, color=color, density=0.1, background=Color.BLACK)\n\n    # Ensure some contiguous runs of red\n    num_red_runs = np.random.randint(2, 5)\n    for _ in range(num_red_runs):\n        if np.random.rand() < 0.5:  # horizontal run\n            r = np.random.randint(0, n)\n            c_start = np.random.randint(0, m - 3)\n            length = np.random.randint(2, min(5, m - c_start))\n            draw_line(grid, x=r, y=c_start, length=length, direction=(0, 1), color=Color.RED)\n        else:  # vertical run\n            c = np.random.randint(0, m)\n            r_start = np.random.randint(0, n - 3)\n            length = np.random.randint(2, min(5, n - r_start))\n            draw_line(grid, x=r_start, y=c, length=length, direction=(1, 0), color=Color.RED)\n\n    return grid", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# Input is a grid containing various colors, including a target color (cyan). \n# For each row and column, detect and extract maximal contiguous runs of the target color. \n# Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color. \n# Non-target colors and isolated target pixels are ignored. \n# The result is a collection of all maximal cyan runs in the grid.\n\ndef main(input_grid: np.ndarray) -> List[Tuple[int, int, int, int]]:\n    target_color = Color.TEAL\n    runs = []\n\n    # Detect horizontal runs\n    for row in range(input_grid.shape[0]):\n        start = None\n        for col in range(input_grid.shape[1]):\n            if input_grid[row, col] == target_color:\n                if start is None:\n                    start = col\n            else:\n                if start is not None:\n                    if col - start > 1:\n                        runs.append((row, start, row, col - 1))\n                    start = None\n        if start is not None and input_grid.shape[1] - start > 1:\n            runs.append((row, start, row, input_grid.shape[1] - 1))\n\n    # Detect vertical runs\n    for col in range(input_grid.shape[1]):\n        start = None\n        for row in range(input_grid.shape[0]):\n            if input_grid[row, col] == target_color:\n                if start is None:\n                    start = row\n            else:\n                if start is not None:\n                    if row - start > 1:\n                        runs.append((start, col, row - 1, col))\n                    start = None\n        if start is not None and input_grid.shape[0] - start > 1:\n            runs.append((start, col, input_grid.shape[0] - 1, col))\n\n    return runs\n\ndef generate_input() -> np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors\n    randomly_scatter_points(grid, color=np.random.choice(Color.NOT_BLACK, replace=False), density=0.7)\n\n    # Add some contiguous runs of the target color (cyan)\n    num_runs = np.random.randint(3, 6)\n    for _ in range(num_runs):\n        direction = np.random.choice(['horizontal', 'vertical'])\n        length = np.random.randint(2, min(n, m))\n        if direction == 'horizontal':\n            row = np.random.randint(0, n)\n            start_col = np.random.randint(0, m - length)\n            draw_line(grid, row, start_col, length=length, direction=(0, 1), color=Color.TEAL)\n        else:\n            col = np.random.randint(0, m)\n            start_row = np.random.randint(0, n - length)\n            draw_line(grid, start_row, col, length=length, direction=(1, 0), color=Color.TEAL)\n\n    return grid", "from common import *\nimport numpy as np\nfrom typing import *\n\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# The input is a grid containing various colors, including a target color (cyan).\n# For each row and column, we need to detect maximal contiguous runs of the target color.\n# Output these runs as lists of coordinates, representing the start and end of each contiguous sequence of the target color.\n# Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal cyan runs in the grid.\n\ndef main(input_grid: np.ndarray) -> List[List[Tuple[int, int]]]:\n    target_color = Color.TEAL  # Using TEAL as cyan representation\n    output = []\n\n    # Check each row for contiguous runs of the target color\n    for i, row in enumerate(input_grid):\n        j = 0\n        while j < len(row):\n            if row[j] == target_color:\n                start = j\n                while j < len(row) and row[j] == target_color:\n                    j += 1\n                end = j - 1\n                if end > start:\n                    output.append([(i, start), (i, end)])\n            j += 1\n\n    # Check each column for contiguous runs of the target color\n    for j in range(input_grid.shape[1]):\n        i = 0\n        while i < input_grid.shape[0]:\n            if input_grid[i][j] == target_color:\n                start = i\n                while i < input_grid.shape[0] and input_grid[i][j] == target_color:\n                    i += 1\n                end = i - 1\n                if end > start:\n                    output.append([(start, j), (end, j)])\n            i += 1\n\n    return output\n\n\ndef generate_input() -> np.ndarray:\n    # Create a grid with random dimensions between 10x10 to 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter different colors including the target color (cyan)\n    randomly_scatter_points(grid, color=Color.TEAL, density=0.2)\n    for color in np.random.choice(Color.NOT_BLACK - {Color.TEAL}, 3, replace=False):\n        randomly_scatter_points(grid, color=color, density=0.1)\n\n    # Manually create a few contiguous runs for guaranteed test cases\n    for _ in range(np.random.randint(2, 5)):\n        direction = (1, 0) if np.random.rand() > 0.5 else (0, 1)\n        length = np.random.randint(2, min(n, m) // 2)\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        draw_line(grid, x, y, length=length, direction=direction, color=Color.TEAL)\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# Input is a grid containing various colors, including a target color (cyan). For each row and column, detect and extract maximal contiguous runs of the target color. \n# Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color. \n# Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal cyan runs in the grid.\n\ndef main(input_grid: np.ndarray) -> List[Tuple[int, int, int]]:\n    target_color = Color.TEAL\n    \n    # Function to find contiguous runs in a 1D array\n    def find_runs(line):\n        runs = []\n        start = None\n        for i, color in enumerate(line):\n            if color == target_color:\n                if start is None:\n                    start = i\n            else:\n                if start is not None:\n                    if i - start > 1:  # Ensure it's a maximal run\n                        runs.append((start, i - 1))\n                    start = None\n        if start is not None and len(line) - start > 1:\n            runs.append((start, len(line) - 1))\n        return runs\n\n    output_runs = []\n\n    # Check rows for contiguous runs\n    for row_idx, row in enumerate(input_grid):\n        row_runs = find_runs(row)\n        for start, end in row_runs:\n            output_runs.append((row_idx, start, end))\n\n    # Check columns for contiguous runs\n    for col_idx in range(input_grid.shape[1]):\n        column = input_grid[:, col_idx]\n        col_runs = find_runs(column)\n        for start, end in col_runs:\n            output_runs.append((start, col_idx, end))\n\n    return output_runs\n\ndef generate_input() -> np.ndarray:\n    # Create a grid of random size (5-10 x 5-10) with random colors including target color (cyan)\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n    \n    # Introduce some random contiguous runs of the target color\n    num_runs = np.random.randint(1, 4)\n    for _ in range(num_runs):\n        orientation = np.random.choice(['horizontal', 'vertical'])\n        if orientation == 'horizontal':\n            row = np.random.randint(n)\n            start_col = np.random.randint(m // 2)\n            end_col = np.random.randint(start_col + 1, m)\n            grid[row, start_col:end_col] = Color.TEAL\n        else:  # vertical\n            col = np.random.randint(m)\n            start_row = np.random.randint(n // 2)\n            end_row = np.random.randint(start_row + 1, n)\n            grid[start_row:end_row, col] = Color.TEAL\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# Input is a grid containing various colors, including a target color (cyan).\n# For each row and column, detect and extract maximal contiguous runs of the target color.\n# Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color.\n# Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal cyan runs in the grid.\n\ndef main(input_grid: np.ndarray) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    runs = []\n\n    target_color = Color.TEAL\n\n    # Function to detect runs in a line (1D array)\n    def detect_runs(line):\n        runs_in_line = []\n        start = None\n\n        for i, color in enumerate(line):\n            if color == target_color:\n                if start is None:\n                    start = i\n            else:\n                if start is not None:\n                    runs_in_line.append((start, i - 1))\n                    start = None\n\n        # Check if the run ends at the last element\n        if start is not None:\n            runs_in_line.append((start, len(line) - 1))\n\n        return runs_in_line\n\n    # Check rows\n    for row_index, row in enumerate(input_grid):\n        row_runs = detect_runs(row)\n        for start_col, end_col in row_runs:\n            runs.append(((row_index, start_col), (row_index, end_col)))\n\n    # Check columns\n    for col_index in range(input_grid.shape[1]):\n        column = input_grid[:, col_index]\n        col_runs = detect_runs(column)\n        for start_row, end_row in col_runs:\n            runs.append(((start_row, col_index), (end_row, col_index)))\n\n    return runs\n\n\ndef generate_input() -> np.ndarray:\n    # Generate a grid with random dimensions between 10x10 and 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter points of various colors including the target color (cyan)\n    for color in Color.NOT_BLACK:\n        if color == Color.TEAL:\n            density = 0.3  # Higher density for the target color to ensure some runs\n        else:\n            density = 0.1  # Lower density for other colors\n        \n        randomly_scatter_points(grid, color=color, density=density, background=Color.BLACK)\n\n    # Optionally draw some horizontal or vertical lines of the target color\n    num_lines = np.random.randint(1, 4)\n    for _ in range(num_lines):\n        if np.random.rand() > 0.5:  # Decide to draw horizontal or vertical line\n            # Horizontal Line\n            x = np.random.randint(0, n)\n            y_start = np.random.randint(0, m - 3)\n            length = np.random.randint(3, m - y_start + 1)\n            draw_line(grid, x, y_start, length=length, direction=(0, 1), color=Color.TEAL)\n        else:\n            # Vertical Line\n            y = np.random.randint(0, m)\n            x_start = np.random.randint(0, n - 3)\n            length = np.random.randint(3, n - x_start + 1)\n            draw_line(grid, x_start, y, length=length, direction=(1, 0), color=Color.TEAL)\n    \n    return grid", "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contiguous run detection, row/column scanning, maximal sequences, color filtering\n\n# description:\n# Input is a grid containing various colors, including a target color (cyan). For each row and column, detect and extract maximal contiguous runs of the target color.\n# Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color. Non-target colors and isolated target pixels are ignored. \n# The result is a collection of all maximal cyan runs in the grid.\n\ndef main(input_grid: np.ndarray) -> List[Tuple[int, int, int, int]]:\n    target_color = Color.TEAL\n    contiguous_runs = []\n\n    # Check each row for contiguous runs of the target color\n    for i in range(input_grid.shape[0]):\n        start = None\n        for j in range(input_grid.shape[1]):\n            if input_grid[i, j] == target_color:\n                if start is None:\n                    start = j\n            else:\n                if start is not None:\n                    if j - start > 1:  # Ensure the run is maximal\n                        contiguous_runs.append((i, start, i, j - 1))\n                    start = None\n        # Handle case where run goes till end of row\n        if start is not None and input_grid.shape[1] - start > 1:\n            contiguous_runs.append((i, start, i, input_grid.shape[1] - 1))\n\n    # Check each column for contiguous runs of the target color\n    for j in range(input_grid.shape[1]):\n        start = None\n        for i in range(input_grid.shape[0]):\n            if input_grid[i, j] == target_color:\n                if start is None:\n                    start = i\n            else:\n                if start is not None:\n                    if i - start > 1:  # Ensure the run is maximal\n                        contiguous_runs.append((start, j, i - 1, j))\n                    start = None\n        # Handle case where run goes till end of column\n        if start is not None and input_grid.shape[0] - start > 1:\n            contiguous_runs.append((start, j, input_grid.shape[0] - 1, j))\n\n    return contiguous_runs\n\ndef generate_input() -> np.ndarray:\n    # Generate a grid with random size between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter points of various colors, including the target color (cyan)\n    for color in np.random.choice(list(Color.NOT_BLACK), size=5, replace=False):\n        randomly_scatter_points(grid, color=color, density=0.2)\n\n    # Add some maximal cyan runs to the grid\n    num_runs = np.random.randint(1, 4)\n    for _ in range(num_runs):\n        if np.random.rand() > 0.5:  # Horizontal run\n            row = np.random.randint(n)\n            start_col = np.random.randint(m - 3)  # Ensure room for a run\n            length = np.random.randint(2, m - start_col)\n            draw_line(grid, row, start_col, length=length, direction=(0, 1), color=Color.TEAL)\n        else:  # Vertical run\n            col = np.random.randint(m)\n            start_row = np.random.randint(n - 3)  # Ensure room for a run\n            length = np.random.randint(2, n - start_row)\n            draw_line(grid, start_row, col, length=length, direction=(1, 0), color=Color.TEAL)\n\n    return grid"], "seeds": ["00d62c1b.py", "9af7a82c.py", "5daaa586.py", "3f7978a0.py", "Concepts: \ncontiguous run detection, row/column scanning, maximal sequences, color filtering\n\nDescription: \nInput is a grid containing various colors, including a target color (cyan). For each row and column, detect and extract maximal contiguous runs of the target color. Output these runs as lists of coordinates or slices, representing the start and end of each contiguous sequence of the target color. Non-target colors and isolated target pixels are ignored. The result is a collection of all maximal cyan runs in the grid."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. \n# For each run, compute k as the minimum of 3 or half the run's length (rounded down). \n# Recolor the first k and last k cells of each run to yellow (color=3), \n# leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Define cyan and yellow\n    cyan = 4\n    yellow = 3\n\n    # Process each row for horizontal runs\n    for row in range(output_grid.shape[0]):\n        col = 0\n        while col < output_grid.shape[1]:\n            if output_grid[row, col] == cyan:\n                start = col\n                while col < output_grid.shape[1] and output_grid[row, col] == cyan:\n                    col += 1\n                end = col\n                run_length = end - start\n                k = min(3, run_length // 2)\n                output_grid[row, start:start + k] = yellow\n                output_grid[row, end - k:end] = yellow\n            col += 1\n\n    # Process each column for vertical runs\n    for col in range(output_grid.shape[1]):\n        row = 0\n        while row < output_grid.shape[0]:\n            if output_grid[row, col] == cyan:\n                start = row\n                while row < output_grid.shape[0] and output_grid[row, col] == cyan:\n                    row += 1\n                end = row\n                run_length = end - start\n                k = min(3, run_length // 2)\n                output_grid[start:start + k, col] = yellow\n                output_grid[end - k:end, col] = yellow\n            row += 1\n\n    return output_grid\n\ndef generate_input():\n    # Random size of input grid\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n\n    # Initialize grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide on the number of cyan runs\n    n_runs = np.random.randint(1, 4)\n\n    for _ in range(n_runs):\n        # Randomly decide if the run is horizontal or vertical\n        if np.random.choice(['horizontal', 'vertical']) == 'horizontal':\n            row = np.random.randint(0, n)\n            start_col = np.random.randint(0, m - 2)\n            run_length = np.random.randint(2, m - start_col + 1)\n            grid[row, start_col:start_col + run_length] = 4  # cyan\n        else:\n            col = np.random.randint(0, m)\n            start_row = np.random.randint(0, n - 2)\n            run_length = np.random.randint(2, n - start_row + 1)\n            grid[start_row:start_row + run_length, col] = 4  # cyan\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k \n# as the minimum of 3 or half the run's length (rounded down). Recolor the first k and last k cells of each run \n# to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends \n# of each cyan run, capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    cyan_color = 4\n    yellow_color = 3\n\n    # Process horizontal runs\n    for i in range(output_grid.shape[0]):\n        j = 0\n        while j < output_grid.shape[1]:\n            if output_grid[i, j] == cyan_color:\n                start = j\n                while j < output_grid.shape[1] and output_grid[i, j] == cyan_color:\n                    j += 1\n                end = j\n                length = end - start\n                k = min(3, length // 2)\n                # Color the first k and last k cells of the run yellow\n                output_grid[i, start:start + k] = yellow_color\n                output_grid[i, end - k:end] = yellow_color\n            j += 1\n\n    # Process vertical runs\n    for j in range(output_grid.shape[1]):\n        i = 0\n        while i < output_grid.shape[0]:\n            if output_grid[i, j] == cyan_color:\n                start = i\n                while i < output_grid.shape[0] and output_grid[i, j] == cyan_color:\n                    i += 1\n                end = i\n                length = end - start\n                k = min(3, length // 2)\n                # Color the first k and last k cells of the run yellow\n                output_grid[start:start + k, j] = yellow_color\n                output_grid[end - k:end, j] = yellow_color\n            i += 1\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Define grid dimensions\n    n = np.random.randint(5, 15)\n    m = np.random.randint(5, 15)\n    \n    # Initialize grid with black\n    grid = np.zeros((n, m), dtype=int)\n\n    # Determine number of cyan runs\n    num_runs = np.random.randint(1, 5)\n\n    for _ in range(num_runs):\n        is_horizontal = np.random.choice([True, False])\n        if is_horizontal:\n            row = np.random.randint(0, n)\n            start_col = np.random.randint(0, m - 1)\n            run_length = np.random.randint(2, m - start_col + 1)\n            grid[row, start_col:start_col + run_length] = 4  # Cyan\n        else:\n            col = np.random.randint(0, m)\n            start_row = np.random.randint(0, n - 1)\n            run_length = np.random.randint(2, n - start_row + 1)\n            grid[start_row:start_row + run_length, col] = 4  # Cyan\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of teal (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down).\n# Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each teal run, capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Check each row for horizontal teal runs\n    for row in range(output_grid.shape[0]):\n        start = None\n        for col in range(output_grid.shape[1]):\n            if output_grid[row, col] == Color.TEAL and start is None:\n                start = col\n            elif output_grid[row, col] != Color.TEAL and start is not None:\n                length = col - start\n                k = min(3, length // 2)\n                output_grid[row, start:start + k] = Color.YELLOW\n                output_grid[row, start + length - k:start + length] = Color.YELLOW\n                start = None\n        if start is not None:\n            length = output_grid.shape[1] - start\n            k = min(3, length // 2)\n            output_grid[row, start:start + k] = Color.YELLOW\n            output_grid[row, start + length - k:start + length] = Color.YELLOW\n\n    # Check each column for vertical teal runs\n    for col in range(output_grid.shape[1]):\n        start = None\n        for row in range(output_grid.shape[0]):\n            if output_grid[row, col] == Color.TEAL and start is None:\n                start = row\n            elif output_grid[row, col] != Color.TEAL and start is not None:\n                length = row - start\n                k = min(3, length // 2)\n                output_grid[start:start + k, col] = Color.YELLOW\n                output_grid[start + length - k:start + length, col] = Color.YELLOW\n                start = None\n        if start is not None:\n            length = output_grid.shape[0] - start\n            k = min(3, length // 2)\n            output_grid[start:start + k, col] = Color.YELLOW\n            output_grid[start + length - k:start + length, col] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Random grid size between 5x5 and 10x10\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    \n    # Initialize grid with random colors\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n    \n    # Introduce some teal runs in the grid\n    num_runs = np.random.randint(1, 4)\n    for _ in range(num_runs):\n        if np.random.rand() > 0.5:\n            # Horizontal run\n            row = np.random.randint(n)\n            start_col = np.random.randint(0, m - 3)\n            length = np.random.randint(3, m - start_col)\n            grid[row, start_col:start_col + length] = Color.TEAL\n        else:\n            # Vertical run\n            col = np.random.randint(m)\n            start_row = np.random.randint(0, n - 3)\n            length = np.random.randint(3, n - start_row)\n            grid[start_row:start_row + length, col] = Color.TEAL\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid.\n# For each run, compute k as the minimum of 3 or half the run's length (rounded down).\n# Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged.\n# This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Create a copy of the input grid to modify and return as output\n    output_grid = np.copy(input_grid)\n    \n    # Identify horizontal and vertical runs of cyan\n    for axis in [0, 1]:  # 0 for horizontal runs, 1 for vertical runs\n        for idx in range(input_grid.shape[axis]):\n            # Extract the line (row or column)\n            line = input_grid[idx, :] if axis == 0 else input_grid[:, idx]\n            \n            # Find runs of cyan (color=4)\n            start = None\n            for pos, color in enumerate(line):\n                if color == 4:  # Cyan\n                    if start is None:\n                        start = pos\n                else:\n                    if start is not None:\n                        end = pos\n                        length = end - start\n                        k = min(3, length // 2)\n                        \n                        # Recolor the ends of the run to yellow (color=3)\n                        if axis == 0:\n                            output_grid[idx, start:start+k] = 3\n                            output_grid[idx, end-k:end] = 3\n                        else:\n                            output_grid[start:start+k, idx] = 3\n                            output_grid[end-k:end, idx] = 3\n                        \n                        start = None\n            # Handle the case where a run extends to the end of the line\n            if start is not None:\n                end = len(line)\n                length = end - start\n                k = min(3, length // 2)\n                if axis == 0:\n                    output_grid[idx, start:start+k] = 3\n                    output_grid[idx, end-k:end] = 3\n                else:\n                    output_grid[start:start+k, idx] = 3\n                    output_grid[end-k:end, idx] = 3\n\n    return output_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Random grid size between 5x5 and 10x10\n    width, height = np.random.randint(5, 11), np.random.randint(5, 11)\n    \n    # Initialize the grid with random colors\n    grid = np.random.choice(list(Color.ALL_COLORS), size=(width, height))\n    \n    # Introduce random horizontal and vertical cyan runs\n    for _ in range(np.random.randint(1, 5)):  # Random number of runs\n        if np.random.rand() > 0.5:  # Randomly choose horizontal or vertical\n            row = np.random.randint(height)\n            start_col = np.random.randint(width - 2)\n            end_col = start_col + np.random.randint(2, width - start_col)\n            grid[row, start_col:end_col] = 4  # Cyan\n        else:\n            col = np.random.randint(width)\n            start_row = np.random.randint(height - 2)\n            end_row = start_row + np.random.randint(2, height - start_row)\n            grid[start_row:end_row, col] = 4  # Cyan\n    \n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of gray (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down).\n# Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. \n# This transformation applies symmetrically to both ends of each gray run, capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Function to process a single line (row or column) for color runs\n    def process_line(line):\n        start = None\n        for i in range(len(line)):\n            if line[i] == Color.GRAY:\n                if start is None:\n                    start = i\n            else:\n                if start is not None:\n                    end = i\n                    process_run(line, start, end)\n                    start = None\n        if start is not None:\n            process_run(line, start, len(line))\n\n    # Function to recolor the ends of a color run\n    def process_run(line, start, end):\n        run_length = end - start\n        k = min(3, run_length // 2)\n        for i in range(start, start + k):\n            line[i] = Color.YELLOW\n        for i in range(end - k, end):\n            line[i] = Color.YELLOW\n\n    # Process all rows\n    for row in output_grid:\n        process_line(row)\n\n    # Process all columns\n    for col in output_grid.T:\n        process_line(col)\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Randomly choose dimensions for the grid\n    n, m = np.random.randint(5, 15, size=2)\n    grid = np.random.choice(\n        [Color.BLACK, Color.GRAY],\n        size=(n, m),\n        p=[0.7, 0.3]  # Adjust the probability to control the density of gray\n    )\n    return grid", "from common import *\nimport numpy as np\nimport random\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k as the minimum of 3 or half the\n# run's length (rounded down). Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged.\n# This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    # Copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Function to recolor the ends of a run\n    def recolor_run(run: np.ndarray, start: int, end: int):\n        run_length = end - start + 1\n        k = min(3, run_length // 2)\n        if k > 0:\n            # Recolor first k and last k cells of the run\n            run[start:start+k] = Color.YELLOW\n            run[end-k+1:end+1] = Color.YELLOW\n\n    # Process horizontal runs\n    for y in range(input_grid.shape[0]):\n        x = 0\n        while x < input_grid.shape[1]:\n            if input_grid[y, x] == Color.TEAL:\n                # Start of a run\n                start_x = x\n                while x < input_grid.shape[1] and input_grid[y, x] == Color.TEAL:\n                    x += 1\n                # End of a run\n                end_x = x - 1\n                recolor_run(output_grid[y], start_x, end_x)\n            else:\n                x += 1\n\n    # Process vertical runs\n    for x in range(input_grid.shape[1]):\n        y = 0\n        while y < input_grid.shape[0]:\n            if input_grid[y, x] == Color.TEAL:\n                # Start of a run\n                start_y = y\n                while y < input_grid.shape[0] and input_grid[y, x] == Color.TEAL:\n                    y += 1\n                # End of a run\n                end_y = y - 1\n                recolor_run(output_grid[:, x], start_y, end_y)\n            else:\n                y += 1\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    # Randomly choose dimensions for the grid\n    height = random.randint(5, 10)\n    width = random.randint(5, 10)\n\n    # Create an empty grid\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly create horizontal and vertical runs of cyan\n    num_runs = random.randint(1, 5)\n    for _ in range(num_runs):\n        # Decide if the run is horizontal or vertical\n        if random.choice([True, False]):\n            # Horizontal run\n            y = random.randint(0, height - 1)\n            start_x = random.randint(0, width - 1)\n            end_x = random.randint(start_x, width - 1)\n            grid[y, start_x:end_x+1] = Color.TEAL\n        else:\n            # Vertical run\n            x = random.randint(0, width - 1)\n            start_y = random.randint(0, height - 1)\n            end_y = random.randint(start_y, height - 1)\n            grid[start_y:end_y+1, x] = Color.TEAL\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of teal (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down).\n# Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each teal run,\n# effectively capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Iterate over each row and column to find teal runs\n    for i in range(output_grid.shape[0]):\n        j = 0\n        while j < output_grid.shape[1]:\n            if output_grid[i, j] == Color.TEAL:\n                start = j\n                while j < output_grid.shape[1] and output_grid[i, j] == Color.TEAL:\n                    j += 1\n                end = j\n                length = end - start\n                k = min(3, length // 2)\n                output_grid[i, start:start+k] = Color.YELLOW\n                output_grid[i, end-k:end] = Color.YELLOW\n            else:\n                j += 1\n\n    for j in range(output_grid.shape[1]):\n        i = 0\n        while i < output_grid.shape[0]:\n            if output_grid[i, j] == Color.TEAL:\n                start = i\n                while i < output_grid.shape[0] and output_grid[i, j] == Color.TEAL:\n                    i += 1\n                end = i\n                length = end - start\n                k = min(3, length // 2)\n                output_grid[start:start+k, j] = Color.YELLOW\n                output_grid[end-k:end, j] = Color.YELLOW\n            else:\n                i += 1\n\n    return output_grid\n\n\ndef generate_input() -> np.ndarray:\n    # Randomly determine the size of the grid\n    rows = np.random.randint(5, 10)\n    cols = np.random.randint(5, 10)\n\n    # Initialize the grid with a random color\n    grid = np.random.choice(list(Color.ALL_COLORS), (rows, cols))\n\n    # Introduce some contiguous teal runs\n    num_runs = np.random.randint(1, 5)\n    for _ in range(num_runs):\n        # Decide if the run is horizontal or vertical\n        if np.random.rand() > 0.5:\n            # Horizontal run\n            i = np.random.randint(0, rows)\n            start_j = np.random.randint(0, cols - 3)\n            run_length = np.random.randint(3, cols - start_j)\n            grid[i, start_j:start_j+run_length] = Color.TEAL\n        else:\n            # Vertical run\n            j = np.random.randint(0, cols)\n            start_i = np.random.randint(0, rows - 3)\n            run_length = np.random.randint(3, rows - start_i)\n            grid[start_i:start_i+run_length, j] = Color.TEAL\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down). \n# Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, \n# capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Process horizontal runs\n    for i in range(input_grid.shape[0]):\n        j = 0\n        while j < input_grid.shape[1]:\n            if input_grid[i, j] == Color.TEAL:\n                start = j\n                while j < input_grid.shape[1] and input_grid[i, j] == Color.TEAL:\n                    j += 1\n                end = j\n                run_length = end - start\n                k = min(3, run_length // 2)\n                output_grid[i, start:start+k] = Color.YELLOW\n                output_grid[i, end-k:end] = Color.YELLOW\n            else:\n                j += 1\n\n    # Process vertical runs\n    for j in range(input_grid.shape[1]):\n        i = 0\n        while i < input_grid.shape[0]:\n            if input_grid[i, j] == Color.TEAL:\n                start = i\n                while i < input_grid.shape[0] and input_grid[i, j] == Color.TEAL:\n                    i += 1\n                end = i\n                run_length = end - start\n                k = min(3, run_length // 2)\n                output_grid[start:start+k, j] = Color.YELLOW\n                output_grid[end-k:end, j] = Color.YELLOW\n            else:\n                i += 1\n\n    return output_grid\n\ndef generate_input() -> np.ndarray:\n    n, m = np.random.randint(5, 15, size=2)  # Random grid size between 5x5 and 15x15\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly place some horizontal and vertical runs of TEAL\n    num_runs = np.random.randint(1, 6)  # Random number of runs between 1 and 5\n    run_length_min, run_length_max = 4, 10  # Run lengths between 4 and 10\n    \n    for _ in range(num_runs):\n        if np.random.rand() < 0.5:  # 50% chance to place a horizontal run\n            row = np.random.randint(0, n)\n            start_col = np.random.randint(0, m - run_length_min)\n            length = np.random.randint(run_length_min, min(run_length_max, m - start_col + 1))\n            grid[row, start_col:start_col+length] = Color.TEAL\n        else:  # 50% chance to place a vertical run\n            col = np.random.randint(0, m)\n            start_row = np.random.randint(0, n - run_length_min)\n            length = np.random.randint(run_length_min, min(run_length_max, n - start_row + 1))\n            grid[start_row:start_row+length, col] = Color.TEAL\n\n    return grid"], "seeds": ["10fcaaa3.py", "7447852a.py", "09629e4f.py", "3428a4f5.py", "Concepts: \ncolor runs, recolor, bounding box, symmetry\n\nDescription: \nIdentify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down). Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion."]}
{"code": ["from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (magenta).\n# Return the index of this stripe (0-based) that contains the target 2x2 block.\n# Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    target_color = Color.MAROON  # assuming magenta is represented by maroon in the library\n\n    # Find the connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Iterate over the objects to find the stripe with the target 2x2 block\n    for stripe_index, stripe in enumerate(objects):\n        stripe_cropped = crop(stripe, background=Color.BLACK)\n\n        # Check for the presence of a 2x2 target color block in the stripe\n        for x in range(stripe_cropped.shape[0] - 1):\n            for y in range(stripe_cropped.shape[1] - 1):\n                if (stripe_cropped[x, y] == stripe_cropped[x + 1, y] ==\n                        stripe_cropped[x, y + 1] == stripe_cropped[x + 1, y + 1] == target_color):\n                    return stripe_index\n\n    raise ValueError(\"No stripe contains a 2x2 block of the target color.\")\n\ndef generate_input():\n    # Define grid size\n    n = np.random.randint(10, 15)  # number of stripes\n    m = np.random.randint(5, 10)   # width of each stripe\n    stripe_height = 3\n    grid_height = n * (stripe_height + 1) - 1  # accounting for black separators\n    grid_width = m\n\n    # Create the grid\n    grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    # Randomly select one stripe to contain the target 2x2 block\n    target_stripe_index = np.random.randint(n)\n\n    # Fill each stripe with random colors, ensuring one contains the target block\n    for stripe_index in range(n):\n        # Stripe starting y position\n        y_start = stripe_index * (stripe_height + 1)\n\n        # Fill the stripe with random colors\n        for y in range(y_start, y_start + stripe_height):\n            color = np.random.choice(list(Color.NOT_BLACK))\n            draw_line(grid, x=0, y=y, end_x=grid_width - 1, end_y=y, color=color)\n\n        # Place the target 2x2 block in the selected stripe\n        if stripe_index == target_stripe_index:\n            x_pos = np.random.randint(0, grid_width - 1)\n            y_pos = np.random.randint(y_start, y_start + stripe_height - 1)\n            grid[y_pos:y_pos + 2, x_pos:x_pos + 2] = Color.MAROON\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (magenta). Return the index of this stripe (0-based) that contains the target 2x2 block.\n# Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    # Define the target color\n    target_color = Color.PINK\n\n    # Find the connected components (stripes) in the input grid\n    stripes = find_connected_components(input_grid, connectivity=8, monochromatic=False, background=Color.BLACK)\n\n    # Iterate over each stripe to find the one containing the 2x2 block of the target color\n    for index, stripe in enumerate(stripes):\n        # Get the bounding box of the stripe\n        x, y, width, height = bounding_box(stripe, background=Color.BLACK)\n\n        # Scan the stripe for 2x2 blocks of the target color\n        for i in range(x, x + width - 1):\n            for j in range(y, y + height - 1):\n                if (stripe[i, j] == stripe[i + 1, j] == stripe[i, j + 1] == stripe[i + 1, j + 1] == target_color):\n                    return index\n\n    raise ValueError(\"No stripe contains a 2x2 block of the target color\")\n\ndef generate_input():\n    # Create the input grid with multiple horizontal stripes\n    stripe_height = np.random.randint(3, 6)\n    num_stripes = np.random.randint(3, 6)\n    grid_width = np.random.randint(10, 15)\n    grid_height = num_stripes * (stripe_height + 1) - 1  # Account for black rows between stripes\n    grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    # Randomly fill each stripe with blocks of random colors\n    for stripe_index in range(num_stripes):\n        stripe_y = stripe_index * (stripe_height + 1)\n        stripe_colors = np.random.choice(list(Color.NOT_BLACK), size=(stripe_height, grid_width))\n        grid[stripe_y:stripe_y + stripe_height, :] = stripe_colors\n\n    # Choose a random stripe and position to place a 2x2 block of the target color\n    target_stripe_index = np.random.randint(num_stripes)\n    target_stripe_y = target_stripe_index * (stripe_height + 1)\n    block_x = np.random.randint(0, grid_width - 1)\n    block_y = np.random.randint(0, stripe_height - 1)\n\n    # Place the 2x2 block of the target color (magenta)\n    grid[target_stripe_y + block_y:target_stripe_y + block_y + 2, block_x:block_x + 2] = Color.PINK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# The input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (magenta).\n# Return the index of this stripe (0-based) that contains the target 2x2 block.\n# Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    target_color = Color.PINK  # Assuming magenta is represented by Color.PINK\n\n    # Find all the stripes by detecting connected components separated by black rows\n    stripes = find_connected_components(input_grid, connectivity=8, background=Color.BLACK)\n\n    # Iterate over each stripe to check for the 2x2 block of the target color\n    for index, stripe in enumerate(stripes):\n        for x in range(stripe.shape[0] - 1):\n            for y in range(stripe.shape[1] - 1):\n                # Check if there is a 2x2 block of the target color\n                if (stripe[x, y] == stripe[x+1, y] == stripe[x, y+1] == stripe[x+1, y+1] == target_color):\n                    return index  # Return the index of the stripe containing the target block\n\n    return None  # Should never reach here as per problem description\n\ndef generate_input():\n    # Parameters for input generation\n    num_stripes = np.random.randint(3, 7)\n    stripe_height = np.random.randint(3, 6)\n    stripe_width = np.random.randint(8, 12)\n    grid_height = num_stripes * stripe_height + (num_stripes - 1)  # Include black row separators\n    grid_width = stripe_width\n    grid = np.full((grid_height, grid_width), Color.BLACK, dtype=int)\n\n    # Randomly generate colored stripes\n    for stripe_index in range(num_stripes):\n        stripe_start_row = stripe_index * (stripe_height + 1)\n        stripe_colors = np.random.choice(list(Color.NOT_BLACK), size=(stripe_height, stripe_width))\n        grid[stripe_start_row:stripe_start_row + stripe_height, :] = stripe_colors\n\n    # Randomly choose one stripe to contain the target 2x2 block\n    target_stripe_index = np.random.randint(num_stripes)\n    target_stripe_start_row = target_stripe_index * (stripe_height + 1)\n\n    # Ensure there's enough space for a 2x2 block\n    x = np.random.randint(0, stripe_height - 1)\n    y = np.random.randint(0, stripe_width - 1)\n\n    # Place the 2x2 magenta block in the chosen stripe\n    grid[target_stripe_start_row + x:target_stripe_start_row + x + 2, y:y + 2] = Color.PINK\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (yellow).\n# Return the index of this stripe (0-based) that contains the target 2x2 block.\n# Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    # Target color for the 2x2 block\n    target_color = Color.YELLOW\n\n    # Identify stripes by finding connected components separated by black rows\n    stripes = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n\n    # Iterate over each stripe and look for a 2x2 block of the target color\n    for index, stripe in enumerate(stripes):\n        stripe_height, stripe_width = stripe.shape\n        for x in range(stripe_height - 1):\n            for y in range(stripe_width - 1):\n                # Check for 2x2 block of target color\n                if (stripe[x, y] == stripe[x + 1, y] == stripe[x, y + 1] == stripe[x + 1, y + 1] == target_color):\n                    return index\n\n    # If no 2x2 block is found, raise an error\n    raise ValueError(\"No stripe contains a 2x2 block of the target color\")\n\ndef generate_input():\n    # Define grid dimensions\n    num_stripes = np.random.randint(3, 6)\n    stripe_height = 3\n    stripe_width = np.random.randint(5, 10)\n    grid_height = num_stripes * (stripe_height + 1) - 1  # Including black rows\n    grid_width = stripe_width\n\n    # Create an empty grid\n    grid = np.full((grid_height, grid_width), Color.BLACK)\n\n    # Fill each stripe with random colors\n    available_colors = list(Color.NOT_BLACK)\n    target_color = Color.YELLOW\n    target_stripe_index = np.random.randint(num_stripes)\n\n    for i in range(num_stripes):\n        # Determine the start row for this stripe\n        start_row = i * (stripe_height + 1)\n\n        # Fill the stripe with random colors\n        for x in range(stripe_height):\n            for y in range(stripe_width):\n                grid[start_row + x, y] = np.random.choice(available_colors)\n\n        # If this is the target stripe, ensure it contains a 2x2 block of the target color\n        if i == target_stripe_index:\n            x = np.random.randint(stripe_height - 1)\n            y = np.random.randint(stripe_width - 1)\n            grid[start_row + x:start_row + x + 2, y:y + 2] = target_color\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (orange).\n# Return the index of this stripe (0-based) that contains the target 2x2 block.\n# Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    target_color = Color.ORANGE\n\n    # Identify connected components that represent stripes\n    stripes = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Sort the stripes based on their y-coordinate to maintain order\n    stripes.sort(key=lambda stripe: object_position(stripe, background=Color.BLACK, anchor=\"upper left\")[1])\n\n    # Iterate through each stripe\n    for index, stripe in enumerate(stripes):\n        # Check for the presence of a 2x2 block of the target color\n        stripe_cropped = crop(stripe, background=Color.BLACK)\n        for x in range(stripe_cropped.shape[0] - 1):\n            for y in range(stripe_cropped.shape[1] - 1):\n                if (stripe_cropped[x, y] == stripe_cropped[x+1, y] == \n                    stripe_cropped[x, y+1] == stripe_cropped[x+1, y+1] == target_color):\n                    return index\n\n    raise ValueError(\"No stripe contains the target 2x2 orange block\")\n\ndef generate_input():\n    # Create a grid with multiple horizontal stripes\n    num_stripes = np.random.randint(3, 7)\n    stripe_height = np.random.randint(2, 4)\n    grid_width = np.random.randint(10, 15)\n\n    # Calculate total grid height considering black separators\n    grid_height = num_stripes * (stripe_height + 1) - 1\n    grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    # Generate stripes with random colors\n    for i in range(num_stripes):\n        y = i * (stripe_height + 1)\n        random_colors = np.random.choice(list(Color.NOT_BLACK), size=(stripe_height, grid_width))\n        grid[y:y+stripe_height, :] = random_colors\n\n    # Randomly select one stripe to contain a 2x2 block of the target color (orange)\n    target_stripe_index = np.random.randint(num_stripes)\n    target_y = target_stripe_index * (stripe_height + 1)\n\n    # Ensure there is enough space in the stripe to place the 2x2 block\n    if grid_width < 2:\n        raise ValueError(\"Grid width too small to place a 2x2 block\")\n\n    block_x = np.random.randint(0, grid_width - 1)\n    block_y = np.random.randint(0, stripe_height - 1)\n\n    # Place the orange 2x2 block in the selected stripe\n    grid[target_y + block_y:target_y + block_y + 2, block_x:block_x + 2] = Color.ORANGE\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (teal).\n# Return the index of this stripe (0-based) that contains the target 2x2 block.\n# Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    target_color = Color.TEAL\n    \n    # Scan through the input grid to find horizontal stripes\n    stripe_indices = []\n    is_in_stripe = False\n    current_stripe_start = 0\n    \n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i] == Color.BLACK):\n            if is_in_stripe:\n                stripe_indices.append((current_stripe_start, i))\n                is_in_stripe = False\n        else:\n            if not is_in_stripe:\n                current_stripe_start = i\n                is_in_stripe = True\n    \n    if is_in_stripe:\n        stripe_indices.append((current_stripe_start, input_grid.shape[0]))\n    \n    # Check each stripe for the presence of a 2x2 block of the target color\n    for stripe_index, (start, end) in enumerate(stripe_indices):\n        for x in range(start, end - 1):\n            for y in range(input_grid.shape[1] - 1):\n                if (input_grid[x, y] == target_color and \n                    input_grid[x+1, y] == target_color and\n                    input_grid[x, y+1] == target_color and \n                    input_grid[x+1, y+1] == target_color):\n                    return stripe_index\n\n    # If no such block is found, return -1 (this should not happen as per the problem statement)\n    return -1\n\ndef generate_input():\n    # Create a grid with horizontal stripes separated by black rows\n    num_stripes = np.random.randint(3, 6)\n    height_per_stripe = np.random.randint(3, 6)\n    width = np.random.randint(10, 15)\n    \n    total_height = num_stripes * (height_per_stripe + 1) - 1\n    grid = np.zeros((total_height, width), dtype=int)\n\n    # Fill each stripe with random colors\n    for stripe_index in range(num_stripes):\n        start_row = stripe_index * (height_per_stripe + 1)\n        for x in range(start_row, start_row + height_per_stripe):\n            grid[x, :] = np.random.choice(list(Color.NOT_BLACK), width)\n\n    # Choose a random stripe to contain the 2x2 teal block\n    target_stripe = np.random.randint(num_stripes)\n    start_row = target_stripe * (height_per_stripe + 1)\n    teal_x = np.random.randint(start_row, start_row + height_per_stripe - 1)\n    teal_y = np.random.randint(width - 1)\n    \n    # Set a 2x2 block of teal in the chosen stripe\n    grid[teal_x, teal_y] = Color.TEAL\n    grid[teal_x + 1, teal_y] = Color.TEAL\n    grid[teal_x, teal_y + 1] = Color.TEAL\n    grid[teal_x + 1, teal_y + 1] = Color.TEAL\n\n    return grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (red). Return the index of this stripe (0-based)\n# that contains the target 2x2 block. Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    target_color = Color.RED\n    stripe_index = -1\n\n    # Start iterating over rows to identify stripes\n    rows, cols = input_grid.shape\n    current_stripe_index = -1\n\n    for row in range(rows):\n        # Detect a new stripe (row not completely black)\n        if np.any(input_grid[row, :] != Color.BLACK):\n            current_stripe_index += 1\n\n            # Check for 2x2 target color block in this stripe\n            for col in range(cols - 1):\n                if (input_grid[row, col] == target_color and\n                    input_grid[row, col + 1] == target_color and\n                    input_grid[row + 1, col] == target_color and\n                    input_grid[row + 1, col + 1] == target_color):\n                    stripe_index = current_stripe_index\n                    break\n\n            # Stop search if stripe with target block is found\n            if stripe_index != -1:\n                break\n\n    return stripe_index\n\ndef generate_input():\n    # Create a grid with random number of horizontal stripes\n    grid_height = np.random.randint(10, 20)\n    grid_width = np.random.randint(10, 20)\n    input_grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    # Number of stripes\n    num_stripes = np.random.randint(3, 6)\n\n    # Height of each stripe\n    stripe_height = grid_height // num_stripes\n\n    # Define colors\n    colors = list(Color.NOT_BLACK)\n    colors.remove(Color.RED)\n\n    # Populate stripes with colors\n    for stripe_index in range(num_stripes):\n        stripe_start_row = stripe_index * stripe_height\n\n        # Fill stripe with random colors\n        for row in range(stripe_start_row, stripe_start_row + stripe_height):\n            color = np.random.choice(colors)\n            draw_line(input_grid, x=0, y=row, end_x=grid_width - 1, color=color)\n\n    # Choose a random stripe to contain the target 2x2 block\n    target_stripe_index = np.random.randint(0, num_stripes)\n    target_row = target_stripe_index * stripe_height + np.random.randint(0, stripe_height - 1)\n    target_col = np.random.randint(0, grid_width - 1)\n\n    # Place the target 2x2 block\n    input_grid[target_row:target_row + 2, target_col:target_col + 2] = Color.RED\n\n    return input_grid", "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stripe detection, 2x2 block search, color matching, index retrieval\n\n# description:\n# Input consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks.\n# Identify the stripe containing a 2x2 block of a specific target color (maroon). Return the index of this stripe (0-based) that contains the target 2x2 block.\n# Only one stripe will contain the target block, ensuring a unique index is returned.\n\ndef main(input_grid):\n    # Separate the stripes using connected components, considering black as the background\n    stripes = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    \n    # Iterate over each stripe to find the presence of a 2x2 maroon block\n    for index, stripe in enumerate(stripes):\n        stripe_height, stripe_width = stripe.shape\n        \n        # Search for a 2x2 maroon block within the stripe\n        for i in range(stripe_height - 1):\n            for j in range(stripe_width - 1):\n                if (stripe[i, j] == stripe[i + 1, j] == stripe[i, j + 1] == stripe[i + 1, j + 1] == Color.MAROON):\n                    return index\n    \n    # If no maroon block is found in any stripe, raise an error (as per description, this should never happen)\n    raise ValueError(\"No stripe contains a 2x2 maroon block\")\n\ndef generate_input():\n    # Create a grid with a random number of horizontal stripes\n    num_stripes = np.random.randint(3, 6)\n    stripe_height = np.random.randint(3, 5)\n    stripe_width = np.random.randint(10, 15)\n    total_height = num_stripes * stripe_height + (num_stripes - 1)\n    \n    # Initialize the grid\n    grid = np.full((total_height, stripe_width), Color.BLACK, dtype=int)\n    \n    # Randomly choose one stripe to contain a 2x2 maroon block\n    target_stripe_index = np.random.randint(num_stripes)\n    \n    # Fill each stripe with random colors and ensure one has the maroon block\n    for i in range(num_stripes):\n        start_row = i * (stripe_height + 1)\n        stripe = random_sprite(stripe_height, stripe_width, density=0.5, color_palette=Color.NOT_BLACK)\n        \n        if i == target_stripe_index:\n            # Place a 2x2 maroon block at a random position within the stripe\n            block_x = np.random.randint(0, stripe_height - 1)\n            block_y = np.random.randint(0, stripe_width - 1)\n            stripe[block_x:block_x + 2, block_y:block_y + 2] = Color.MAROON\n        \n        grid[start_row:start_row + stripe_height, :] = stripe\n    \n    return grid"], "seeds": ["1fad071e.py", "746b3537.py", "8e1813be.py", "f8b3ba0a.py", "Concepts: \nstripe detection, 2x2 block search, color matching, index retrieval\n\nDescription: \nInput consists of multiple horizontal stripes separated by black rows. Each stripe may contain various colored blocks. Identify the stripe containing a 2x2 block of a specific target color (magenta). Return the index of this stripe (0-based) that contains the target 2x2 block. Only one stripe will contain the target block, ensuring a unique index is returned."]}
