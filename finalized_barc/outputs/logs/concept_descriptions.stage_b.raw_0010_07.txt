Let's create a puzzle based on the description provided:

**Concepts:**
- Guide Object, Starting Point, Position-based Transformation

**Description:**
The puzzle involves finding a unique colored object (guide object) within a grid and using its position to transform the entire grid. The transformation consists of rotating the grid around the guide object's position by 90 degrees clockwise. The input grid contains various colored objects, but only one guide object with a distinct color (not found elsewhere in the grid). The output grid is the result of rotating the input grid around the guide object's position.

Here is the implementation:

```python
from common import *

import numpy as np
from typing import *

# concepts:
# guide object, position-based transformation, rotation

# description:
# In the input grid, find the guide object with a unique color. Use its position as the pivot point to rotate
# the entire grid 90 degrees clockwise. The output grid will reflect this transformation.

def main(input_grid):
    # Step 1: Identify the guide object
    unique_colors = [color for color in np.unique(input_grid) if np.sum(input_grid == color) == 1]
    assert len(unique_colors) == 1, "There should be exactly one guide object with a unique color"
    guide_color = unique_colors[0]
    
    # Find the guide object's position
    guide_position = np.argwhere(input_grid == guide_color)[0]

    # Step 2: Rotate the grid around the guide object's position
    output_grid = rotate_around_point(input_grid, guide_position)

    return output_grid

def rotate_around_point(grid, point):
    n, m = grid.shape
    x, y = point
    output_grid = np.full((n, m), Color.BLACK, dtype=int)

    # Rotate each pixel around the guide object's position (x, y)
    for i in range(n):
        for j in range(m):
            # Calculate the new position after 90-degree clockwise rotation
            new_x = x + (j - y)
            new_y = y - (i - x)
            
            # Check bounds and assign the color
            if 0 <= new_x < n and 0 <= new_y < m:
                output_grid[new_x, new_y] = grid[i, j]

    return output_grid

def generate_input():
    # Generate a grid with various objects and one guide object with a unique color
    n, m = np.random.randint(5, 10), np.random.randint(5, 10)
    grid = np.full((n, m), Color.BLACK, dtype=int)

    # Place random objects with random colors
    num_objects = np.random.randint(3, 6)
    for _ in range(num_objects):
        sprite = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=Color.NOT_BLACK - {Color.MAROON})
        try:
            x, y = random_free_location_for_sprite(grid, sprite)
            blit_sprite(grid, sprite, x, y)
        except ValueError:
            continue

    # Add the guide object with a unique color
    guide_color = Color.MAROON  # Assume MAROON is not used in other objects
    while True:
        x, y = np.random.randint(0, n), np.random.randint(0, m)
        if grid[x, y] == Color.BLACK:
            grid[x, y] = guide_color
            break

    return grid
```

### Explanation:

1. **Guide Object Detection**: We find the guide object by identifying a color that appears only once in the grid. This ensures it's unique.

2. **Rotation Logic**: The grid is rotated 90 degrees clockwise around the guide object's position. We calculate the new position for each pixel relative to the guide object's position.

3. **Input Generation**: The `generate_input` function creates a grid with randomly placed objects of various colors and ensures the inclusion of a guide object with a unique color (MAROON in this case).

This puzzle requires students to understand concepts like unique object detection, pivot-based transformations, and grid manipulation.