You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
obstacle navigation, fixed direction turn, pathfinding

Description: 
Input is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered. When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear. Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, always turning the same way as specified.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def draw_line(grid, x, y, end_x=None, end_y=None, length=None, direction=None, color=None, stop_at_color=[]):
    """
    Draws a line starting at (x, y) extending to (end_x, end_y) or of the specified length in the specified direction
    Direction should be a vector with elements -1, 0, or 1.
    If length is None, then the line will continue until it hits the edge of the grid.

    stop_at_color: optional list of colors that the line should stop at. If the line hits a pixel of one of these colors, it will stop.

    Returns the endpoint of the line.

    Example:
    # blue diagonal line from (0, 0) to (2, 2)
    stop_x, stop_y = draw_line(grid, 0, 0, length=3, color=blue, direction=(1, 1))
    draw_line(grid, 0, 0, end_x=2, end_y=2, color=blue)
    assert (stop_x, stop_y) == (2, 2)
    """

def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_object(grid, obj, background=Color.BLACK):
    """
    Draws an object onto the grid using its current location.

    Example usage:
    blit_object(output_grid, an_object, background=background_color)
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def bounding_box(grid, background=Color.BLACK):
    """
    Find the bounding box of the non-background pixels in the grid.
    Returns a tuple (x, y, width, height) of the bounding box.

    Example usage:
    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=8)
    teal_object = [ obj for obj in objects if np.any(obj == Color.TEAL) ][0]
    teal_x, teal_y, teal_w, teal_h = bounding_box(teal_object)
    """

def object_position(obj, background=Color.BLACK, anchor='upper left'):
    """
    (x,y) position of the provided object. By default, the upper left corner.

    anchor: "upper left", "upper right", "lower left", "lower right", "center", "upper center", "lower center", "left center", "right center"

    Example usage:
    x, y = object_position(obj, background=background_color, anchor="upper left")
    middle_x, middle_y = object_position(obj, background=background_color, anchor="center")
    """

def object_colors(obj, background=Color.BLACK):
    """
    Returns a list of colors in the object.

    Example usage:
    colors = object_colors(obj, background=background_color)
    """

def crop(grid, background=Color.BLACK):
    """
    Crop the grid to the smallest bounding box that contains all non-background pixels.

    Example usage:
    # Extract a sprite from an object
    sprite = crop(an_object, background=background_color)
    """

def translate(obj, x, y, background=Color.BLACK):
    """
    Translate by the vector (x, y). Fills in the new pixels with the background color.

    Example usage:
    red_object = ... # extract some object
    shifted_red_object = translate(red_object, x=1, y=1)
    blit_object(output_grid, shifted_red_object, background=background_color)
    """

def collision(_=None, object1=None, object2=None, x1=0, y1=0, x2=0, y2=0, background=Color.BLACK):
    """
    Check if object1 and object2 collide when object1 is at (x1, y1) and object2 is at (x2, y2).

    Example usage:

    # Check if a sprite can be placed onto a grid at (X,Y)
    collision(object1=output_grid, object2=a_sprite, x2=X, y2=Y)

    # Check if two objects collide
    collision(object1=object1, object2=object2, x1=X1, y1=Y1, x2=X2, y2=Y2)
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

def random_sprite(n, m, density=0.5, symmetry=None, color_palette=None, connectivity=4, background=Color.BLACK):
    """
    Generate a sprite (an object), represented as a numpy array.

    n, m: dimensions of the sprite. If these are lists, then a random value will be chosen from the list.
    symmetry: optional type of symmetry to apply to the sprite. Can be 'horizontal', 'vertical', 'diagonal', 'radial', 'mirror', 'not_symmetric'. If None, a random symmetry type will be chosen.
    color_palette: optional list of colors to use in the sprite. If None, a random color palette will be chosen.

    Returns an (n,m) NumPy array representing the sprite.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *
import time

# concepts:
# path finding


# description:
# In the input you will see teal pixels and a short green line and a short red line.
# Find a path starting from the green line and ending at the red line and color that path green, with the following constraints:
# You can't go through a teal pixel; you can only change direction when you hit a teal pixel; you have to start in the direction of the green line.

def main(input_grid):
    # Plan:
    # 1. Find the start and end points of the pathfinding problem
    # 2. Define the state space, initial state(s), successor function, and goal test
    # 3. Run bfs to find the shortest path from start to end
    # 4. Color the path green

    # 1. Parse the input, based on color
    # There is the start object, end object, and barriers object
    background = Color.BLACK
    start_object = input_grid.copy()
    start_object[start_object != Color.GREEN] = background
    end_object = input_grid.copy()
    end_object[end_object != Color.RED] = background
    barriers_object = input_grid.copy()
    barriers_object[barriers_object != Color.TEAL] = background

    # Determine the orientation of the start object
    x_coordinates = {x for x, y in np.argwhere(start_object == Color.GREEN)}
    y_coordinates = {y for x, y in np.argwhere(start_object == Color.GREEN)}
    # vertical line?
    if len(x_coordinates) == 1:
        possible_orientations = [(0, 1), (0, -1)]
    # horizontal line?
    elif len(y_coordinates) == 1:
        possible_orientations = [(1, 0), (-1, 0)]
    else:
        assert False, "Start object is not horizontal/vertical"
    
    # 2. Define the state space, initial state(s), successor function, and goal test
    # A state is a tuple of (x, y, orientation)
    # orientation is a tuple of (dx, dy)
        
    # Initially we begin at a point on the line, along the orientation of the line
    initial_states = [(x, y, orientation)
                      for x, y in np.argwhere(start_object == Color.GREEN)
                      for orientation in possible_orientations]
    

    def successors(state):
        x, y, orientation = state
        dx, dy = orientation

        if not (0 <= x + dx < input_grid.shape[0] and 0 <= y + dy < input_grid.shape[1]):
            return

        if barriers_object[x + dx, y + dy] == background:
            yield (x + dx, y + dy, orientation)
        if barriers_object[x + dx, y + dy] != background:
            # right angle turns
            new_orientations = [(dy, dx), (-dy, -dx)]
            for new_orientation in new_orientations:
                yield (x, y, new_orientation)
    
    def is_goal(state):
        x, y, (dx, dy) = state
        if not (0 <= x + dx < end_object.shape[0] and 0 <= y + dy < end_object.shape[1]):
            return False
        return end_object[x + dx, y + dy] == Color.RED
    
    # 3. Run bfs to find the shortest path from start to end
    queue = list(initial_states)
    visited = set(initial_states)
    parent = {}
    while queue:
        state = queue.pop(0)        
        if is_goal(state):
            break        
        for successor in successors(state):
            if successor not in visited:
                visited.add(successor)
                parent[successor] = state
                queue.append(successor)

    assert is_goal(state), "No path found"
    
    path = []
    while state in parent:
        path.append(state)
        state = parent[state]

    # 4. Color the path green
    # draw on top of the input grid
    output_grid = input_grid.copy()
    for x, y, _ in path:
        output_grid[x, y] = Color.GREEN

    return output_grid

def generate_input():
    # We want to first generate a successful path and add some noise teal pixels.
    # Finally, we will remove the intermediate pixels in the path.
    # Because the problem never uses the color 42, we will draw the path in that color, but finally erase it before returning the grid.

    # Initialize grid
    n = random.randint(14, 20)
    grid = np.zeros((n, n), dtype=int)

    # Generate start sprite, making it vertical (1x2 dimensions). We will rotate the final grid randomly to get a variety of orientations.
    start_sprite = random_sprite(1, 2, density=1, color_palette=[Color.GREEN])

    # Draw start sprite
    start_x, start_y = random_free_location_for_sprite(grid, start_sprite, border_size=4)
    blit_sprite(grid, start_sprite, start_x, start_y)

    # Make a random path from the start to the end, leaving color 42 along the path, and leaving teal pixels at each turn
    x,y = start_x, start_y-1
    orientation = (0, -1)
    target_length = random.randint(10, 20)
    for _ in range(target_length):
        # Draw the path
        grid[x, y] = 42        

        if random.random() < 0.2:
            # right angle turn
            dx, dy = orientation
            new_orientation = random.choice([(dy, dx), (-dy, -dx)])
            grid[x+dx, y+dy] = Color.TEAL
            orientation = new_orientation
        
        dx, dy = orientation
        x += dx
        y += dy

        if x < 0 or x >= n or y < 0 or y >= n: return generate_input()
    
    # Color the ending red
    grid[x, y] = Color.RED
    grid[x-dx, y-dy] = Color.RED

    # randomly sprinkle teal in unoccupied locations
    for x, y in np.argwhere(grid == Color.BLACK):
        if random.random() < 0.3:
            grid[x, y] = Color.TEAL

    # Replace the path with black
    grid[grid == 42] = Color.BLACK

    # Randomly rotate
    grid = np.rot90(grid, k=random.randint(0, 3))

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# maze, path finding

# description:
# In the input you will see a maze with a path that has two indicator pixels of different colors.
# To make the output, fill all reachable parts of the maze starting with the indicator pixels and alternating colors.

def main(input_grid):
    # Output grid draws on top of the input grid
    output_grid = input_grid.copy()

    # Parse the input
    maze_color = Color.TEAL
    indicator_colors = [ color for color in object_colors(input_grid, background=Color.BLACK) if color != maze_color]
    assert len(indicator_colors) == 2, "expected exactly two indicator colors"
    
    # Fill the path with alternating colors in turn
    def fill_maze(cur_color, next_color, x, y, grid):
        width, height = grid.shape
        # Search outward in four directions
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for direction in directions:
            new_x, new_y = x + direction[0], y + direction[1]
            if 0 <= new_x < width and 0 <= new_y < height and grid[new_x, new_y] == Color.BLACK:
                grid[new_x, new_y] = next_color
                # Change the next color to the current color: swap current and next
                fill_maze(next_color, cur_color, new_x, new_y, grid)
    
    # Fill the path with two colors
    # Start to fill the path with the pixel that already has the path_color
    for x, y in np.argwhere((input_grid != Color.BLACK) & (input_grid != maze_color)):
        cur_color = input_grid[x, y]
        next_color = indicator_colors[0] if cur_color == indicator_colors[1] else indicator_colors[1]
        fill_maze(cur_color, next_color, x, y, output_grid)

    return output_grid

def generate_input():
    # Create the background grid
    width, height = np.random.randint(15, 30), np.random.randint(15, 30)
    grid = np.full((width, height), Color.BLACK)

    # function to check if the surrounding pixels are all black
    def check_available(x, y, grid, directions):
        for direction in directions:
            new_x, new_y = x + direction[0], y + direction[1]
            if 0 <= new_x and new_x < grid.shape[0] and 0 <= new_y and new_y < grid.shape[1] and grid[new_x, new_y] != Color.BLACK:
                return False
        return True
    
    # function for random walk to generate the maze
    def random_walk(color, grid, x, y):
        # Four walking directions
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        # Randomly choose one available direction
        random.shuffle(directions)
        for direction in directions:
            cur_x, cur_y = x + direction[0], y + direction[1]
            # Check if the next position is out of the grid
            if cur_x < 0 or cur_x >= width or cur_y < 0 or cur_y >= height:
                continue

            # Check if the next position touch other maze path
            rest_directions = [d for d in directions if d != (-direction[0], -direction[1])]
            if check_available(cur_x, cur_y, grid, rest_directions):
                # If not, mark the next position as the maze path
                # And continue the random walking
                grid[cur_x, cur_y] = color
                random_walk(color, grid, cur_x, cur_y)
                break

    # The color for the maze path        
    maze_color = Color.TEAL

    # Iterate over the grid to generate the maze
    for x, y in np.argwhere(grid == Color.BLACK):
        # If the current position is not empty, skip
        if grid[x, y] != Color.BLACK:
            continue

        # Check if the surrounding pixels are all black, which means we can start the random walking
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        if check_available(x, y, grid, directions):
            # Start the random walking
            grid[x, y] = maze_color

            # Avoid the exception `maximum recursion depth exceeded`
            try:
                random_walk(maze_color, grid, x, y)
            except:
                continue
    
    # The path has two colors which appear in turn
    path_color = np.random.choice([color for color in Color.NOT_BLACK if color != maze_color], 2, replace=False)

    # Mark the longest path to be colored to the path_color in turn
    objects = find_connected_components(grid, background=maze_color, connectivity=4, monochromatic=True)
    path = max(objects, key=lambda x: np.sum(x == Color.BLACK))

    # Find one empty position to start the path
    x, y = random.choice(np.argwhere(path == Color.BLACK))

    # Color the position with one of the path_color
    grid[x, y] = path_color[0]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    for direction in directions:
        if 0 <= x + direction[0] < width and 0 <= y + direction[1] < height and grid[x + direction[0], y + direction[1]] == Color.BLACK:
            # Color the surrounding pixels with the other path_color
            # Which indicates the color should be changed in the next step
            grid[x + direction[0], y + direction[1]] = path_color[1]

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# direction, lines, pointing

# description:
# In the input, you will see several objects of the same color that are in an arrowhead shape and facing different directions.
# The goal is to find the directions of the arrowheads and draw lines that would represent the path they had been moving in to go in that direction.

def main(input_grid):
    # copy the input grid to the output grid
    output_grid = np.copy(input_grid)

    # find the objects in the input grid
    objects = find_connected_components(input_grid, connectivity=8)

    # for each object, find the direction the arrowhead is pointing in by finding the relative mean position of colored and black pixels in the bounding box of the object
    for obj in objects:
        # find the bounding box of the object
        x, y, w, h = bounding_box(obj)

        # crop the object to extract the sprite
        sprite = crop(obj)

        # find the color of the object
        color = np.unique(obj[obj != Color.BLACK])[0]

        # find the mean position of the colored pixels
        mean_pos = np.mean(np.argwhere(sprite != Color.BLACK), axis=0)

        # find the mean position of all the black pixels
        mean_black_pos = np.mean(np.argwhere(sprite == Color.BLACK), axis=0)

        # find the direction the arrowhead is pointing in, it is from the mean position of the colored pixels to the mean position of the black pixels
        direction = np.sign(mean_black_pos - mean_pos).astype(int)

        # draw a line in the direction the arrowhead is pointing in from the corresponding corner of the bounding box
        # list the corners of the bounding box
        corners = [(x - 1, y - 1), (x + w, y - 1), (x - 1, y + h), (x + w, y + h)]
        # compute the center of the object
        center = (x + w / 2, y + h / 2)
        # if the direction of the corner from the center of the object matches the direction we want to draw a line in, then draw a line
        for corner in corners:
            # check if the corner is in the direction that the arrowhead is pointing
            vector_to_corner = np.array(corner) - np.array(center)
            if np.all(np.sign(vector_to_corner) == direction):
                draw_line(output_grid, corner[0], corner[1], length=None, color=color, direction=direction)

    return output_grid

def generate_input():
    # make a 10x10 grid as background
    grid = np.zeros((10, 10), dtype=int)

    # choose the color of the arrowheads
    color = np.random.choice(Color.NOT_BLACK)

    # make the arrowheads by making a 2x2 square then removing one of the corners randomly and placing it randomly on the grid
    for i in range(4):
        # make at arrowhead
        arrowhead = np.full((2, 2), color)
        corner = np.random.randint(4)
        arrowhead[corner // 2, corner % 2] = Color.BLACK
        
        # place it in a random free location with 1 cell padding
        x, y = random_free_location_for_sprite(grid, arrowhead, padding=1)
        blit_sprite(grid, arrowhead, x=x, y=y)
 
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# collision, translation

# description:
# In the input you will see a red object overlaid on a track of green dots.
# To make the output, move the red object one green dot to the right (if the track is horizontal) or one green dot down (if the track is vertical).

def main(input_grid):
    # Plan:
    # 1. Detect the objects
    # 2. Determine the orientation of the track of green dots
    # 3. Move in the appropriate direction until it perfectly fits over the next green dot, meaning there are no collisions

    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=True)

    red_objects = [ obj for obj in objects if Color.RED in object_colors(obj, background=Color.BLACK) ]
    green_objects = [ obj for obj in objects if Color.GREEN in object_colors(obj, background=Color.BLACK) ]

    assert len(red_objects) == 1, "There should be exactly one red object"
    assert len(green_objects) >= 1, "There should be at least one green object"

    red_object = red_objects[0]

    # Determine the orientation of the track of green dots by comparing the positions of two dots
    x1,y1 = min( object_position(obj, anchor="center") for obj in green_objects )
    x2,y2 = max( object_position(obj, anchor="center") for obj in green_objects )
    if x1 == x2:
        # vertical track
        dx, dy = 0, 1
    elif y1 == y2:
        # horizontal track
        dx, dy = 1, 0
    
    # Make the output grid: Start with all the greens, then put the red in the right spot by moving it one-by-one
    output_grid = np.full_like(input_grid, Color.BLACK)
    for green_object in green_objects:
        blit_object(output_grid, green_object)

    for distance in range(1, 100):
        translated_red_object = translate(red_object, dx*distance, dy*distance)
        if not collision(object1=translated_red_object, object2=output_grid):
            blit_object(output_grid, translated_red_object)
            break

    return output_grid

def generate_input():
    # Make a grid with a red rectangle on the bottom and a teal diagonal line at the top pointing at it
    # Then randomly rotate to get a variety of orientations

    width, height = np.random.randint(10, 25), np.random.randint(10, 25)
    grid = np.full((width, height), Color.BLACK)

    # the red object will be a rectangle with a hole in the middle that the green dot fits into
    # for the hole to fit perfectly in the middle, it needs to be of odd dimension
    rectangle_width, rectangle_height = random.choice([3, 5]), random.choice([3, 5])
    red_rectangle = np.full((rectangle_width, rectangle_height), Color.RED)

    # randomly place the red rectangle at least 5 pixels away from the edge
    x, y = random_free_location_for_sprite(grid, red_rectangle, background=Color.BLACK, border_size=5)
    blit_sprite(grid, red_rectangle, x, y, background=Color.BLACK)

    # Create a row of green dots, starting with the center of the rectangle
    center_x, center_y = object_position(grid, anchor="center", background=Color.BLACK)
    grid[center_x, center_y] = Color.GREEN

    # create a horizontal row of green dots
    for i in range(-10, 10):
        dx = rectangle_width
        if 0 <= center_x + i*dx < width:
            grid[center_x + i*dx, center_y] = Color.GREEN
    
    # randomly flip/rotate
    grid = np.rot90(grid, np.random.randint(0, 4))

    return grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
