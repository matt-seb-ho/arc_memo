You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
unique color selection, connected components, object identification, guide object

Description: 
Identify all connected components in the grid and determine their colors. Select the object whose color is unique (not shared by any other object) as the guide object. The output is the grid with the guide object highlighted or isolated based on its unique color, while all other objects remain unchanged.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def draw_line(grid, x, y, end_x=None, end_y=None, length=None, direction=None, color=None, stop_at_color=[]):
    """
    Draws a line starting at (x, y) extending to (end_x, end_y) or of the specified length in the specified direction
    Direction should be a vector with elements -1, 0, or 1.
    If length is None, then the line will continue until it hits the edge of the grid.

    stop_at_color: optional list of colors that the line should stop at. If the line hits a pixel of one of these colors, it will stop.

    Returns the endpoint of the line.

    Example:
    # blue diagonal line from (0, 0) to (2, 2)
    stop_x, stop_y = draw_line(grid, 0, 0, length=3, color=blue, direction=(1, 1))
    draw_line(grid, 0, 0, end_x=2, end_y=2, color=blue)
    assert (stop_x, stop_y) == (2, 2)
    """

def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_object(grid, obj, background=Color.BLACK):
    """
    Draws an object onto the grid using its current location.

    Example usage:
    blit_object(output_grid, an_object, background=background_color)
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def bounding_box(grid, background=Color.BLACK):
    """
    Find the bounding box of the non-background pixels in the grid.
    Returns a tuple (x, y, width, height) of the bounding box.

    Example usage:
    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=8)
    teal_object = [ obj for obj in objects if np.any(obj == Color.TEAL) ][0]
    teal_x, teal_y, teal_w, teal_h = bounding_box(teal_object)
    """

def crop(grid, background=Color.BLACK):
    """
    Crop the grid to the smallest bounding box that contains all non-background pixels.

    Example usage:
    # Extract a sprite from an object
    sprite = crop(an_object, background=background_color)
    """

def contact(_=None, object1=None, object2=None, x1=0, y1=0, x2=0, y2=0, background=Color.BLACK, connectivity=4):
    """
    Check if object1 and object2 touch each other (have contact) when object1 is at (x1, y1) and object2 is at (x2, y2).
    They are touching each other if they share a border, or if they overlap. Collision implies contact, but contact does not imply collision.

    connectivity: 4 or 8, for 4-way or 8-way connectivity. (8-way counts diagonals as touching, 4-way only counts cardinal directions as touching)

    Example usage:

    # Check if a sprite touches anything if it were to be placed at (X,Y)
    contact(object1=output_grid, object2=a_sprite, x2=X, y2=Y)

    # Check if two objects touch each other
    contact(object1=object1, object2=object2)
    """

def randomly_spaced_indices(max_len, n_indices, border_size=1, padding=1):
    """
    Generate randomly-spaced indices guaranteed to not be adjacent.
    Useful for generating random dividers.

    padding: guaranteed empty space in between indices
    border_size: guaranteed empty space at the border

    Example usage:
    x_indices = randomly_spaced_indices(grid.shape[0], num_dividers, border_size=1, padding=2) # make sure each region is at least 2 pixels wide
    for x in x_indices:
        grid[x, :] = divider_color
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

def object_interior(grid, background=Color.BLACK):
    """
    Computes the interior of the object (including edges)

    returns a new grid of `bool` where True indicates that the pixel is part of the object's interior.

    Example usage:
    interior = object_interior(obj, background=Color.BLACK)
    for x, y in np.argwhere(interior):
        # x,y is either inside the object or at least on its edge
    """

def random_sprite(n, m, density=0.5, symmetry=None, color_palette=None, connectivity=4, background=Color.BLACK):
    """
    Generate a sprite (an object), represented as a numpy array.

    n, m: dimensions of the sprite. If these are lists, then a random value will be chosen from the list.
    symmetry: optional type of symmetry to apply to the sprite. Can be 'horizontal', 'vertical', 'diagonal', 'radial', 'mirror', 'not_symmetric'. If None, a random symmetry type will be chosen.
    color_palette: optional list of colors to use in the sprite. If None, a random color palette will be chosen.

    Returns an (n,m) NumPy array representing the sprite.
    """

def detect_objects(grid, _=None, predicate=None, background=Color.BLACK, monochromatic=False, connectivity=None, allowed_dimensions=None, colors=None, can_overlap=False):
    """
    Detects and extracts objects from the grid that satisfy custom specification.

    predicate: a function that takes a candidate object as input and returns True if it counts as an object
    background: color treated as transparent
    monochromatic: if True, each object is assumed to have only one color. If False, each object can include multiple colors.
    connectivity: 4 or 8, for 4-way or 8-way connectivity. If None, the connectivity is determined automatically.
    allowed_dimensions: a list of tuples (n, m) specifying the allowed dimensions of the objects. If None, objects of any size are allowed.
    colors: a list of colors that the objects are allowed to have. If None, objects of any color are allowed.
    can_overlap: if True, objects can overlap. If False, objects cannot overlap.

    Returns a list of objects, where each object is a numpy array.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# objects, topology

# description:
# In the input grid, you will see various blue objects. Some are "hollow" and contain a fully-enclosed region, while others do not have a middle that is separate from outside the object, and fully enclosed.
# To create the output grid, copy the input grid. Then, change the color of all "hollow" shapes to be green.

def main(input_grid):
    objects = find_connected_components(input_grid, connectivity=4)
    output_grid = input_grid.copy()
    for object in objects:
        if is_hollow(object):
            object[object != Color.BLACK] = Color.GREEN
        blit_object(output_grid, object, background=Color.BLACK)

    return output_grid

def is_hollow(object):
    # to check if it contains a fully enclosed region, find everything that is enclosed by the object (in its interior), but not actually part of the object
    interior_mask = object_interior(object)
    object_mask = object != Color.BLACK
    hollow_mask = interior_mask & ~object_mask
    return np.any(hollow_mask)


def generate_input():
    n = np.random.randint(10, 28)
    input_grid = np.full((n, n), Color.BLACK)
    # create a bunch of random objects. all objects are either (1) hollow, in which case they are the border of a rectangle of some size, or (2) not hollow, in which case they are a subset of a border of a rectangle of some size.
    # make sure we place at least one hollow and nonhollow object. then add random objects until somewhat full.

    def random_hollow_object():
        n, m = np.random.randint(3, 7), np.random.randint(3, 7)
        obj = np.full((n, m), Color.BLUE)
        obj[1:n-1, 1:m-1] = Color.BLACK
        return obj

    def random_nonhollow_object():
        obj = random_hollow_object()
        # remove a random number of dots from it
        size = np.count_nonzero(obj)
        new_size = np.random.randint(1, size)
        xs, ys = np.where(obj != Color.BLACK)
        for i in range(size - new_size):
            obj[xs[i], ys[i]] = Color.BLACK

        return obj

    try:
        # add one hollow and one nonhollow object, then add random objects until somewhat full.
        obj = random_hollow_object()
        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)
        blit_sprite(input_grid, obj, x=x, y=y)

        obj = random_nonhollow_object()
        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)
        blit_sprite(input_grid, obj, x=x, y=y)
    except ValueError:
        return generate_input()

    while True:
        obj = random_hollow_object() if np.random.rand() < 0.5 else random_nonhollow_object()
        try:
            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)
            blit_sprite(input_grid, obj, x=x, y=y)
        except ValueError:
            return input_grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# object detection, color change

# description:
# In the input you will see a grid with a red pattern
# To make the output grid, you should find out any single isolated red objects with size of 1x1 and change them to blue.

def main(input_grid):
    # Detect all the red objects in the grid, ignoring objects of other colors
    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)

    # Convert 1x1 objects (isolated pixels) into blue
    output_grid = input_grid.copy()
    for object in red_objects:
        x, y, length, width = bounding_box(object, background=Color.BLACK)
        # Find out the single isolated red object with size of 1x1 and change it to blue.
        if length == 1 and width == 1:
            output_grid[x, y] = Color.BLUE

    return output_grid

def generate_input():
    # Generate the background grid with size of n x m.
    n, m = np.random.randint(3, 6), np.random.randint(3, 6)
    grid = np.zeros((n, m), dtype=int)

    colored = 0
    # Randomly scatter density of red pixels on the grid.
    density = 0.4
    while colored < density * n * m:
        x = np.random.randint(0, n)
        y = np.random.randint(0, m)
        if grid[x, y] == Color.BLACK:
            grid[x, y] = Color.RED
            colored += 1

    # Ensure there is at least one 1x1 single isolated red object in the grid.
    red_objects = detect_objects(grid=grid, colors=[Color.RED], monochromatic=True, connectivity=4)
    if not any(np.sum(object != Color.BLACK) == 1 for object in red_objects):
        return generate_input()
    
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# objects separated by lines, color correspond to position

# description:
# In the input you will see several gray lines that separate the grid into several parts.
# To make the output grid, you should color the upper left part with blue, the lower right part with green,
# and the middle part with red.

def main(input_grid):
    # Find all the black rectangles separated by gray lines
    black_rectangles = find_connected_components(grid=input_grid, connectivity=4, monochromatic=False, background=Color.GRAY)

    # Get the bounding box of each black rectangle
    rectangles_lists = []
    for rectangle in black_rectangles:
        x, y, w, h = bounding_box(grid=rectangle, background=Color.GRAY)
        rectangles_lists.append({'x': x, 'y': y, 'w': w, 'h': h})

    # Sort the rectangles by x and y position
    rectangles_lists = sorted(rectangles_lists, key=lambda rec: rec['x'])
    rectangles_lists = sorted(rectangles_lists, key=lambda rec: rec['y'])
    
    left_upper_rectangle, middle_rectangle, right_bottom_rectangle = rectangles_lists[0], rectangles_lists[len(rectangles_lists) // 2], rectangles_lists[-1]

    # Color the left upper part with blue
    blue_grid = np.full((left_upper_rectangle['w'], left_upper_rectangle['h']), Color.BLUE)

    # Color the right lower part with green
    green_grid = np.full((right_bottom_rectangle['w'], right_bottom_rectangle['h']), Color.GREEN)

    # Color the middle part with red
    red_grid = np.full((middle_rectangle['w'], middle_rectangle['h']), Color.RED)

    # Place the blue, green, and red grid on the input grid
    output_grid = input_grid.copy()
    output_grid = blit_sprite(grid=input_grid, sprite=blue_grid, x=left_upper_rectangle['x'], y=left_upper_rectangle['y'])
    output_grid = blit_sprite(grid=input_grid, sprite=green_grid, x=right_bottom_rectangle['x'], y=right_bottom_rectangle['y'])
    output_grid = blit_sprite(grid=input_grid, sprite=red_grid, x=middle_rectangle['x'], y=middle_rectangle['y'])
            
    return output_grid

def generate_input():
    # Generate a square grid as the black background
    grid_len = np.random.randint(10, 20)
    n, m = grid_len, grid_len
    grid = np.zeros((n, m), dtype=int)

    # Get the number of horizontal and vertical lines
    line_nums = [2, 4]
    line_num = np.random.choice(line_nums)

    # Generate the gray lines' positions with interval between each line to form several rectangles
    # If padding is True, the lines will be padded with 1 grid on both sides
    vertical_lines = randomly_spaced_indices(max_len=n, n_indices=line_num, border_size=1, padding=4)
    horizontal_lines = randomly_spaced_indices(max_len=m, n_indices=line_num, border_size=1, padding=2)

    # Draw the gray vertical and horizontal lines on the grid
    for vertical_line in vertical_lines:
        draw_line(grid=grid, x=vertical_line, y=0, direction=(0, 1), color=Color.GRAY)
    
    for horizontal_line in horizontal_lines:
        draw_line(grid=grid, x=0, y=horizontal_line, direction=(1, 0), color=Color.GRAY)

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# object extraction, contact, cropping

# description:
# In the input you will see several objects with same color placed in a 10x10 grid, only one of 
# them contact a gray pixel.
# To make the output grid, you should select the object contact the gray pixel, crop it, and then output it.

def main(input_grid):
    # Get the color of the pattern
    pattern_color = [color for color in np.unique(input_grid) if color != Color.BLACK and color != Color.GRAY][0]

    # Detect all the patterns with pattern color in the input grid
    pattern_list = detect_objects(grid=input_grid, colors=[pattern_color], connectivity=8, monochromatic=True)

    # Detect the indicator gray pixel
    gray_pixel = detect_objects(grid=input_grid, colors=[Color.GRAY], connectivity=8, monochromatic=True)[0]

    # Find out which pattern has contact the gray pixel
    for pattern in pattern_list:
        cropped_pattern = crop(grid=pattern)
        # Check if the gray pixel contact the pattern
        if contact(object1=pattern, object2=gray_pixel, connectivity=4):
            # Crop the pattern and output it
            output_grid = cropped_pattern
            break

    return output_grid

def generate_input():
    # Generate a 10x10 grid with several objects with same color placed in it
    n, m = 10, 10
    grid = np.zeros((n, m), dtype=int)
    
    # Select a color for the objects and the number of objects.
    available_colors = [c for c in Color.NOT_BLACK if c != Color.GRAY]
    obj_color = random.choice(available_colors)
    num_sprite = np.random.randint(2,4)

    # Place the objects in the grid.
    for i in range(num_sprite):
        # Create a 3x3 object with the selected color and random pattern.
        sprite = random_sprite(n=3, m=3, color_palette=[obj_color], density=0.4)
        # Place the object in the grid.
        try:
            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8, border_size=1)
        except:
            continue
        # Add a gray pixel to contact one of the object.
        if i == 0:
            grid[x + 1, y - 1] = Color.GRAY
            # Make sure the grey pixel contact the object.
            grid[x + 1, y] = obj_color
        # Place the object in the grid.
        grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)
            
    return grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
