Here's a new puzzle implementation, involving obstacles and line drawing:

```python
from common import *

import numpy as np
from typing import *

# concepts:
# obstacles, path blocking, line drawing

# description:
# In the input grid, there are randomly placed colored obstacles and two distinct points marked with different colors (e.g., green and red).
# The goal is to draw a line from the green point to the red point, navigating around the obstacles. 
# The line should not overlap any obstacles and should follow the shortest path possible. The output grid retains all other elements of the input grid unchanged.

def main(input_grid):
    # The output grid is initialized as a copy of the input grid
    output_grid = input_grid.copy()

    # Find the start (green) and end (red) points
    start_pos = np.argwhere(input_grid == Color.GREEN)[0]
    end_pos = np.argwhere(input_grid == Color.RED)[0]

    # Identify obstacles: these are colors that are not black, green, or red
    obstacles = {color for color in Color.NOT_BLACK if color not in (Color.GREEN, Color.RED)}

    # Implement a simple BFS for pathfinding to navigate around obstacles
    from collections import deque
    queue = deque([(start_pos[0], start_pos[1], [])])
    visited = set()
    visited.add((start_pos[0], start_pos[1]))

    while queue:
        x, y, path = queue.popleft()

        # If we reached the end point, draw the path and return the output
        if (x, y) == (end_pos[0], end_pos[1]):
            for px, py in path:
                output_grid[px, py] = Color.GREEN
            return output_grid

        # Explore neighbors: up, down, left, right
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if (nx, ny) not in visited and 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:
                if input_grid[nx, ny] not in obstacles:
                    visited.add((nx, ny))
                    queue.append((nx, ny, path + [(nx, ny)]))

    # In case no path is found, return the original grid
    return output_grid

def generate_input():
    # Create a grid of size 10x10
    n, m = 10, 10
    grid = np.zeros((n, m), dtype=int)

    # Randomly place a green start point and a red end point
    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)
    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)
    while (end_x, end_y) == (start_x, start_y):
        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)

    grid[start_x, start_y] = Color.GREEN
    grid[end_x, end_y] = Color.RED

    # Randomly scatter obstacles across the grid with a density of 0.2
    randomly_scatter_points(grid, color=Color.GREY, density=0.2, background=Color.BLACK)
    return grid
```

### Explanation:

- **Concepts**: The puzzle involves identifying and navigating around obstacles to draw a line between two points without overlapping the obstacles.
- **Description**: The grid has colored obstacles, and two distinct points marked with green and red. The task is to determine a path from the green point to the red point while navigating around obstacles, ensuring the line does not overlap any obstacles. The path drawn is the shortest possible path avoiding obstacles, and all other grid elements remain unchanged.