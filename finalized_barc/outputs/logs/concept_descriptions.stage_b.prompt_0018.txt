You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
recolor, guide object, connected components

Description: 
Input consists of a grid with at least two distinct objects: a target object and a guide object. Identify the target object and change its color to match the color of the guide object. The guide object is distinct and serves as the reference for the new color. All other grid elements remain unchanged.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def flood_fill(grid, x, y, color, connectivity=4):
    """
    Fill the connected region that contains the point (x, y) with the specified color.

    connectivity: 4 or 8, for 4-way or 8-way connectivity. 8-way counts diagonals as connected, 4-way only counts cardinal directions as connected.
    """

def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_object(grid, obj, background=Color.BLACK):
    """
    Draws an object onto the grid using its current location.

    Example usage:
    blit_object(output_grid, an_object, background=background_color)
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def bounding_box(grid, background=Color.BLACK):
    """
    Find the bounding box of the non-background pixels in the grid.
    Returns a tuple (x, y, width, height) of the bounding box.

    Example usage:
    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=8)
    teal_object = [ obj for obj in objects if np.any(obj == Color.TEAL) ][0]
    teal_x, teal_y, teal_w, teal_h = bounding_box(teal_object)
    """

def translate(obj, x, y, background=Color.BLACK):
    """
    Translate by the vector (x, y). Fills in the new pixels with the background color.

    Example usage:
    red_object = ... # extract some object
    shifted_red_object = translate(red_object, x=1, y=1)
    blit_object(output_grid, shifted_red_object, background=background_color)
    """

def collision(_=None, object1=None, object2=None, x1=0, y1=0, x2=0, y2=0, background=Color.BLACK):
    """
    Check if object1 and object2 collide when object1 is at (x1, y1) and object2 is at (x2, y2).

    Example usage:

    # Check if a sprite can be placed onto a grid at (X,Y)
    collision(object1=output_grid, object2=a_sprite, x2=X, y2=Y)

    # Check if two objects collide
    collision(object1=object1, object2=object2, x1=X1, y1=Y1, x2=X2, y2=Y2)
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

def random_sprite(n, m, density=0.5, symmetry=None, color_palette=None, connectivity=4, background=Color.BLACK):
    """
    Generate a sprite (an object), represented as a numpy array.

    n, m: dimensions of the sprite. If these are lists, then a random value will be chosen from the list.
    symmetry: optional type of symmetry to apply to the sprite. Can be 'horizontal', 'vertical', 'diagonal', 'radial', 'mirror', 'not_symmetric'. If None, a random symmetry type will be chosen.
    color_palette: optional list of colors to use in the sprite. If None, a random color palette will be chosen.

    Returns an (n,m) NumPy array representing the sprite.
    """

def detect_objects(grid, _=None, predicate=None, background=Color.BLACK, monochromatic=False, connectivity=None, allowed_dimensions=None, colors=None, can_overlap=False):
    """
    Detects and extracts objects from the grid that satisfy custom specification.

    predicate: a function that takes a candidate object as input and returns True if it counts as an object
    background: color treated as transparent
    monochromatic: if True, each object is assumed to have only one color. If False, each object can include multiple colors.
    connectivity: 4 or 8, for 4-way or 8-way connectivity. If None, the connectivity is determined automatically.
    allowed_dimensions: a list of tuples (n, m) specifying the allowed dimensions of the objects. If None, objects of any size are allowed.
    colors: a list of colors that the objects are allowed to have. If None, objects of any color are allowed.
    can_overlap: if True, objects can overlap. If False, objects cannot overlap.

    Returns a list of objects, where each object is a numpy array.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# counting

# description:
# The input consists of several grey objects in a 10x10 grid.
# To create the output, change the color of all objects of area 6 to red, and all other objects to blue.

def main(input_grid):
    # extract objects
    objects = find_connected_components(input_grid, connectivity=4)

    # convert each object to the desired color
    for obj in objects:
        if np.sum(obj != Color.BLACK) == 6:
            obj[obj != Color.BLACK] = Color.RED
        else:
            obj[obj != Color.BLACK] = Color.BLUE

    # place new objects back into a grid
    output_grid = np.zeros_like(input_grid)
    for obj in objects:
        output_grid = blit_object(output_grid, obj, background=Color.BLACK)

    return output_grid


def generate_input():
    # create a 10x10 grid
    grid = np.full((10, 10), Color.BLACK)

    # generate objects and place into the grid until it is filled
    # we want some area six objects, and some non-area six objects.
    # to do so, first place a couple area six objects, then fill up the remaining space with random objects

    # place two area six objects
    for _ in range(2):
        while True:
            obj = random_sprite(list(range(1, 5)), list(range(1, 5)), color_palette=[Color.GREY])
            if np.sum(obj != Color.BLACK) == 6:
                break
        x, y = random_free_location_for_sprite(grid, obj, padding=1)
        grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)

    # now fill up the remaining space with random objects.
    while True:
        obj = random_sprite(list(range(1, 5)), list(range(1, 5)), color_palette=[Color.GREY])

        # try to place the object. if we can't, we're done
        try:
            x, y = random_free_location_for_sprite(grid, obj, padding=1)
            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)
        except ValueError:
            break

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# object detection, color change

# description:
# In the input you will see a grid with a red pattern
# To make the output grid, you should find out any single isolated red objects with size of 1x1 and change them to blue.

def main(input_grid):
    # Detect all the red objects in the grid, ignoring objects of other colors
    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)

    # Convert 1x1 objects (isolated pixels) into blue
    output_grid = input_grid.copy()
    for object in red_objects:
        x, y, length, width = bounding_box(object, background=Color.BLACK)
        # Find out the single isolated red object with size of 1x1 and change it to blue.
        if length == 1 and width == 1:
            output_grid[x, y] = Color.BLUE

    return output_grid

def generate_input():
    # Generate the background grid with size of n x m.
    n, m = np.random.randint(3, 6), np.random.randint(3, 6)
    grid = np.zeros((n, m), dtype=int)

    colored = 0
    # Randomly scatter density of red pixels on the grid.
    density = 0.4
    while colored < density * n * m:
        x = np.random.randint(0, n)
        y = np.random.randint(0, m)
        if grid[x, y] == Color.BLACK:
            grid[x, y] = Color.RED
            colored += 1

    # Ensure there is at least one 1x1 single isolated red object in the grid.
    red_objects = detect_objects(grid=grid, colors=[Color.RED], monochromatic=True, connectivity=4)
    if not any(np.sum(object != Color.BLACK) == 1 for object in red_objects):
        return generate_input()
    
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# alignment, copy to object border

# description:
# In the input you will see a teal object on a black background, and several colored pixels on the border of canvas.
# To make the output grid, you should copy the colored pixels horizontally/vertically so that they are just barely overlapping/colliding with the teal object.

def main(input_grid):
    # Plan:
    # 1. Detect the teal object
    # 2. Detect the colored pixels on the border
    # 3. Slide the colored pixels in the 4 cardinal directions until we find how to make them overlapping with the teal object

    output_grid = np.copy(input_grid)

    # Detects the rectangle in the input grid that is TEAL
    teal_objects = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=4)
    
    # There should only be one rectangle of the color TEAL has been detected in the grid.
    assert len(teal_objects) == 1
    teal_object = teal_objects[0]

    # colored pixels are NOT black and NOT TEAL.
    colors_except_teal = [c for c in Color.NOT_BLACK if c != Color.TEAL]
    
    # Detects all other colored pixels in the grid 
    pixels = detect_objects(grid=input_grid,
                            # Exclude teal from the search
                            colors=colors_except_teal, 
                            # only consider single pixels
                            allowed_dimensions=[(1,1)], 
                            monochromatic=True, connectivity=4)

    # Copy the colored pixels to the teal object by moving them either vertically or horizontally.
    for pixel in pixels:
        # consider translating the pixel in the 4 cardinal directions, and consider translating as far as possible
        possible_displacements = [ (slide_distance*dx, slide_distance*dy)
                                   # We could slide as far as the maximum grid extent
                                   for slide_distance in range(max(input_grid.shape))
                                   # (dx, dy) ranges over 4 cardinal directions
                                   for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)] ]
        for dx, dy in possible_displacements:
            # check if the objects are colliding/overlapping after translating
            translated_pixel = translate(pixel, dx, dy, background=Color.BLACK)
            if collision(object1=teal_object, object2=translated_pixel):
                # put the red object where it belongs
                blit_object(output_grid, translated_pixel, background=Color.BLACK)
                break
    
    return output_grid


def generate_input():
    # Initialize a 10x10 grid representing a black background.
    n = m = 10
    grid = np.zeros((n, m), dtype=int)
    
    # Randomly determine the width and height of the TEAL rectangle between 2 and 5.
    width, height = np.random.randint(2, 6), np.random.randint(2, 6)
    teal_sprite = np.full((width, height), Color.TEAL)

    # Find a free location for this sprite and blit it to the grid
    x, y = random_free_location_for_sprite(grid, teal_sprite, background=Color.BLACK, padding=1, border_size=1)
    blit_sprite(grid, teal_sprite, x, y, background=Color.BLACK)

    # list to hold the available positions, which are all on the border of the canvas
    border_locations = [ (0, y) for y in range(n) ] + [ (m-1, y) for y in range(n) ] + [ (x, 0) for x in range(1, m-1) ] + [ (x, n-1) for x in range(1, m-1) ]
    
    # Put a random number of colored pixels on the border of the canvas
    for _ in range(np.random.randint(3, 8)):
        # Pick a random location on the border
        x, y = random.choice(border_locations)
        # Pick a random color that is not black or teal
        color = random.choice([c for c in Color.NOT_BLACK if c != Color.TEAL])

        grid[x, y] = color
    
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# rectangular cells, flood fill, connecting same color

# description:
# In the input you will see horizontal and vertical bars that divide the grid into rectangular cells
# To make the output, find any pair of rectangular cells that are in the same row and column and have the same color, then color all the rectangular cells between them with that color

def main(input_grid: np.ndarray) -> np.ndarray:

    # find the color of the horizontal and vertical bars that divide the rectangular cells
    # this is the color of any line that extends all the way horizontally or vertically
    jail_color = None
    for i in range(input_grid.shape[0]):
        for j in range(input_grid.shape[1]):
            color = input_grid[i][j]
            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):
                jail_color = color
                break
    
    assert jail_color is not None, "No jail color found"

    output_grid = input_grid.copy()

    # color all the cells between the same color pixels
    for x in range(input_grid.shape[0]):
        for y in range(input_grid.shape[1]):
            color = input_grid[x][y]
            if color == jail_color or color == Color.BLACK:
                continue

            # check if there is a cell with the same color in the same X value
            for y2 in range(y+1, input_grid.shape[1]):
                if input_grid[x][y2] == color:
                    for y3 in range(y+1, y2):
                        if input_grid[x][y3] == Color.BLACK:
                            output_grid[x][y3] = color
                    break

            # check if there is a cell with the same color in the same Y value
            for x2 in range(x+1, input_grid.shape[0]):
                if input_grid[x2][y] == color:
                    for x3 in range(x+1, x2):
                        if input_grid[x3][y] == Color.BLACK:
                            output_grid[x3][y] = color
                    break
                
    return output_grid

def generate_input() -> np.ndarray:

    grid_size = 32
    cell_size = 2

    # First create the array of rectangular cells, each of which is separated by horizontal and vertical bars dividing cells

    # pick a non-black color for the divider
    divider_color = random.choice(Color.NOT_BLACK)
    grid = np.zeros((grid_size, grid_size), dtype=int)
    r_offset_x, r_offset_y = np.random.randint(0, cell_size), np.random.randint(0, cell_size)

    # make horizontal bars with cell_size gaps, but +1 because we need to include the divider, which is one pixel wide
    for x in range(r_offset_x, grid_size, cell_size+1):
        grid[x, :] = divider_color
    # make vertical bars with cell_size gaps
    for y in range(r_offset_y, grid_size, cell_size+1):
        grid[:, y] = divider_color

    # Second we will color some of the cells with a random color

    # random number of cells to color
    number_to_color = np.random.randint(1, 4)
    for _ in range(number_to_color):
        # pick what we're going to color the inside of the cell, which needs to be a different color from the divider
        other_color = np.random.choice([c for c in Color.ALL_COLORS if c != divider_color and c != Color.BLACK])

        # get all coords of black cells
        black_coords = np.argwhere(grid == Color.BLACK)
        # pick a random black cell
        x, y = random.choice(black_coords)
        flood_fill(grid, x, y, other_color)

        # sometimes skip coloring the other side of the divider
        if random.random() <= 0.2:
            continue 

        # flip a coin to decide if horizontal or vertical
        h_or_v = random.random() < 0.5
        if h_or_v:
            # horizontal
            # get all the black cells in the same row
            black_coords = np.argwhere(grid[x, :] == Color.BLACK)
            # pick a random black cell
            other_y = random.choice(black_coords)
            flood_fill(grid, x, other_y, other_color)
        else:
            # vertical
            # get all the black cells in the same column
            black_coords = np.argwhere(grid[:, y] == Color.BLACK)
            # pick a random black cell
            other_x = random.choice(black_coords)
            flood_fill(grid, other_x, y, other_color)

    return grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
