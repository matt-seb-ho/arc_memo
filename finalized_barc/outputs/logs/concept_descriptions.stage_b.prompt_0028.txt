You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
orientation detection, shape normalization, centroid-to-tip vector, direction quantization

Description: 
Input is a grid containing a single pointer-shaped object on a background. Normalize the pointer by rotating and/or flipping it to match a canonical orientation. Determine the pointer's facing direction by computing the vector from its centroid to its tip and quantizing this vector to one of the cardinal directions (N, S, E, W). Output the determined direction as a label.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def draw_line(grid, x, y, end_x=None, end_y=None, length=None, direction=None, color=None, stop_at_color=[]):
    """
    Draws a line starting at (x, y) extending to (end_x, end_y) or of the specified length in the specified direction
    Direction should be a vector with elements -1, 0, or 1.
    If length is None, then the line will continue until it hits the edge of the grid.

    stop_at_color: optional list of colors that the line should stop at. If the line hits a pixel of one of these colors, it will stop.

    Returns the endpoint of the line.

    Example:
    # blue diagonal line from (0, 0) to (2, 2)
    stop_x, stop_y = draw_line(grid, 0, 0, length=3, color=blue, direction=(1, 1))
    draw_line(grid, 0, 0, end_x=2, end_y=2, color=blue)
    assert (stop_x, stop_y) == (2, 2)
    """

def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def bounding_box(grid, background=Color.BLACK):
    """
    Find the bounding box of the non-background pixels in the grid.
    Returns a tuple (x, y, width, height) of the bounding box.

    Example usage:
    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=8)
    teal_object = [ obj for obj in objects if np.any(obj == Color.TEAL) ][0]
    teal_x, teal_y, teal_w, teal_h = bounding_box(teal_object)
    """

def object_position(obj, background=Color.BLACK, anchor='upper left'):
    """
    (x,y) position of the provided object. By default, the upper left corner.

    anchor: "upper left", "upper right", "lower left", "lower right", "center", "upper center", "lower center", "left center", "right center"

    Example usage:
    x, y = object_position(obj, background=background_color, anchor="upper left")
    middle_x, middle_y = object_position(obj, background=background_color, anchor="center")
    """

def crop(grid, background=Color.BLACK):
    """
    Crop the grid to the smallest bounding box that contains all non-background pixels.

    Example usage:
    # Extract a sprite from an object
    sprite = crop(an_object, background=background_color)
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

def random_sprite(n, m, density=0.5, symmetry=None, color_palette=None, connectivity=4, background=Color.BLACK):
    """
    Generate a sprite (an object), represented as a numpy array.

    n, m: dimensions of the sprite. If these are lists, then a random value will be chosen from the list.
    symmetry: optional type of symmetry to apply to the sprite. Can be 'horizontal', 'vertical', 'diagonal', 'radial', 'mirror', 'not_symmetric'. If None, a random symmetry type will be chosen.
    color_palette: optional list of colors to use in the sprite. If None, a random color palette will be chosen.

    Returns an (n,m) NumPy array representing the sprite.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# direction, lines, pointing

# description:
# In the input, you will see several objects of the same color that are in an arrowhead shape and facing different directions.
# The goal is to find the directions of the arrowheads and draw lines that would represent the path they had been moving in to go in that direction.

def main(input_grid):
    # copy the input grid to the output grid
    output_grid = np.copy(input_grid)

    # find the objects in the input grid
    objects = find_connected_components(input_grid, connectivity=8)

    # for each object, find the direction the arrowhead is pointing in by finding the relative mean position of colored and black pixels in the bounding box of the object
    for obj in objects:
        # find the bounding box of the object
        x, y, w, h = bounding_box(obj)

        # crop the object to extract the sprite
        sprite = crop(obj)

        # find the color of the object
        color = np.unique(obj[obj != Color.BLACK])[0]

        # find the mean position of the colored pixels
        mean_pos = np.mean(np.argwhere(sprite != Color.BLACK), axis=0)

        # find the mean position of all the black pixels
        mean_black_pos = np.mean(np.argwhere(sprite == Color.BLACK), axis=0)

        # find the direction the arrowhead is pointing in, it is from the mean position of the colored pixels to the mean position of the black pixels
        direction = np.sign(mean_black_pos - mean_pos).astype(int)

        # draw a line in the direction the arrowhead is pointing in from the corresponding corner of the bounding box
        # list the corners of the bounding box
        corners = [(x - 1, y - 1), (x + w, y - 1), (x - 1, y + h), (x + w, y + h)]
        # compute the center of the object
        center = (x + w / 2, y + h / 2)
        # if the direction of the corner from the center of the object matches the direction we want to draw a line in, then draw a line
        for corner in corners:
            # check if the corner is in the direction that the arrowhead is pointing
            vector_to_corner = np.array(corner) - np.array(center)
            if np.all(np.sign(vector_to_corner) == direction):
                draw_line(output_grid, corner[0], corner[1], length=None, color=color, direction=direction)

    return output_grid

def generate_input():
    # make a 10x10 grid as background
    grid = np.zeros((10, 10), dtype=int)

    # choose the color of the arrowheads
    color = np.random.choice(Color.NOT_BLACK)

    # make the arrowheads by making a 2x2 square then removing one of the corners randomly and placing it randomly on the grid
    for i in range(4):
        # make at arrowhead
        arrowhead = np.full((2, 2), color)
        corner = np.random.randint(4)
        arrowhead[corner // 2, corner % 2] = Color.BLACK
        
        # place it in a random free location with 1 cell padding
        x, y = random_free_location_for_sprite(grid, arrowhead, padding=1)
        blit_sprite(grid, arrowhead, x=x, y=y)
 
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# rotate, position

# description:
# In the input you will see a grid with 3 regions separated by grey horizontal lines. The leftmost region contains a multicolored sprite and the others are empty (black)
# To make the output, rotate the leftmost region 90 degree clockwise and place it in the first empty region, then rotate it a further 90 degrees and put it in the second empty region, etc.

def main(input_grid):
    # Get all the regions separated by the divider in the input grid
    divider_color = Color.GRAY
    regions = find_connected_components(input_grid, connectivity=4, background=divider_color, monochromatic=False)

    # Sort the region by x position so that we can get the leftmost, middle, and rightmost regions
    regions.sort(key=lambda region: object_position(region, background=divider_color)[0])

    # We are going to draw on top of the input
    output_grid = input_grid.copy()

    # Get the leftmost region which contains the multicolored sprite
    leftmost_region = regions[0]
    template_sprite = crop(grid=leftmost_region, background=divider_color)

    empty_regions = regions[1:]

    for empty_region in empty_regions:
        # Rotate the template sprite 90 degree clockwise
        template_sprite = np.rot90(template_sprite)

        # Place the rotated template sprite in the empty region
        x, y = object_position(empty_region, background=divider_color)
        blit_sprite(output_grid, sprite=template_sprite, x=x, y=y)
    
    return output_grid

def generate_input():
    # Create a grid with some regions separated by vertical grey lines
    # This is generalized so that there can be various numbers of regions
    n_regions = random.choice([2, 3, 4, 5])
    region_size = np.random.randint(3, 6)
    n_dividers = n_regions - 1
    width, height = n_regions * region_size + n_dividers, region_size
    grid = np.full((width, height), Color.BLACK)

    # Draw lines for the dividers
    line_color = Color.GRAY
    for x in range(region_size, width, region_size + 1):
        draw_line(grid, x=x, y=0, direction=(0, 1), color=line_color)

    # Draw one template
    possible_colors = [color for color in Color.NOT_BLACK if color != line_color]
    template_sprite = random_sprite(region_size, region_size, color_palette=possible_colors, density=1.0)

    # Place the template pattern in the first black region
    x, y = 0, 0
    blit_sprite(grid, sprite=template_sprite, x=x, y=y)

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *


# concepts:
# patterns, growing, horizontal/vertical bars

# description:
# In the input you will see a 30x30 grid with at least two rectangles, each with at least one special pixel of a different color, and a crosshair-type pattern outside these rectangles.
# For each of these special pixels, apply the crosshair pattern and extend the points inside the rectangle that special pixel is in, until it reaches the edge.

def main(input_grid):
    # first get the grid size
    n, m = input_grid.shape

    # figure out background color by assuming it is the most common color
    background_color = np.bincount(input_grid.flatten()).argmax()

    # with this background color, find the polychromatic objects
    objects = find_connected_components(input_grid, background=background_color, connectivity=8, monochromatic=False)

    # sort the objects by their size in terms of area, the crosshair is the smallest object
    sorted_objects = sorted(objects, key=lambda x: np.count_nonzero(x != background_color))
    crosshair_object = sorted_objects[0]
    rectangles = sorted_objects[1:]

    # now find the crosshair sprite coordinates
    crosshair_sprite = crop(crosshair_object, background=background_color)
    width, height = crosshair_sprite.shape
    
    # if the crosshair is wider than it is tall, it extends horizontally, vertically if taller, both if square
    horizontal = True
    vertical = True
    if width > height:
        vertical = False
        point_color = crosshair_sprite[0, height // 2]
    elif height > width:
        horizontal = False
        point_color = crosshair_sprite[width // 2, 0]
    else:
        point_color = crosshair_sprite[width // 2, 0]

    # now we prepare the output grid
    output_grid = np.full_like(input_grid, background_color)

    # for each rectangle, crop it to just the rectangle, find the special pixel, extend the crosshair pattern from it, then add it back to the grid
    for rectangle in rectangles:
        # crop the rectangle to just the rectangle, while preserving its position in the grid
        rec_x, rec_y, w, h = bounding_box(rectangle, background=background_color)
        cropped_rectangle = crop(rectangle, background=background_color)

        # find the special color, it is the least common color in the rectangle
        colors, counts = np.unique(cropped_rectangle, return_counts=True)
        # colors are sorted by their frequency, so choose least common as the special color
        special_color = colors[-1]
        rectangle_color = colors[-2]

        # for each special pixel, extend the crosshair pattern
        for x, y in np.argwhere(cropped_rectangle == special_color):
            # first color the special pixel with the crosshair sprite centered on it
            cropped_rectangle = blit_sprite(cropped_rectangle, crosshair_sprite, x - width // 2, y - height // 2, background=background_color)

            # then extend the points in the crosshair pattern until they reach the edge of the rectangle
            if horizontal:
                for x0 in range(w):
                    if cropped_rectangle[x0, y] == rectangle_color:
                        cropped_rectangle[x0, y] = point_color
            if vertical:
                for y0 in range(h):
                    if cropped_rectangle[x, y0] == rectangle_color:
                        cropped_rectangle[x, y0] = point_color
        
        # add the rectangle back to the grid
        blit_sprite(output_grid, cropped_rectangle, rec_x, rec_y, background=background_color)

    return output_grid


def generate_input():
    # not complete

    return None
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# non-black background, diagonal lines

# description:
# In the input you will see a grid there's all the same color except for a single black pixel in the middle. Equivalently, a black pixel on a non-black background.
# To make the output, draw black diagonal lines outward from the single black pixel in all 4 diagonal directions.

def main(input_grid):
    # Plan:
    # 1. Find the black pixel
    # 2. Draw diagonal lines outward from the black pixel

    # Find the possible locations that are black, then check that there is exactly one
    black_pixel_locations = np.argwhere(input_grid == Color.BLACK)
    assert len(black_pixel_locations) == 1
    black_pixel_location = black_pixel_locations[0]
    black_x, black_y = black_pixel_location

    # We are going to draw on top of the input grid
    output_grid = input_grid.copy()

    # Draw the diagonal lines
    for dx, dy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
        direction = (dx, dy)
        draw_line(output_grid, black_x, black_y, direction=direction, color=Color.BLACK)

    return output_grid

def generate_input():
    # Make a grid with a random background color (not black)
    background_color = np.random.choice(Color.NOT_BLACK)
    width, height = np.random.randint(3, 30, size=2)
    input_grid = np.full((width, height), background_color)

    # Place a black pixel in the middle
    input_grid[width // 2, height // 2] = Color.BLACK

    return input_grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
