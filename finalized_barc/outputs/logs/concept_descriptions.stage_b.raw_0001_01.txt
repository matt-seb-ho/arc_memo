Here is an implementation for the given puzzle description:

```python
from common import *

import numpy as np
from typing import *

# concepts:
# holes, enclosed regions, flood fill, background detection

# description:
# Identify holes as background-color regions fully enclosed by a guide object, not connected to the grid border. Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole. Fill these holes with the target object color, ensuring they are completely enclosed by the guide object.

def main(input_grid):
    # Create a copy of the input grid to work on
    output_grid = input_grid.copy()
    
    # Detect the background color (most common color connected to the border)
    border_mask = np.zeros(input_grid.shape, dtype=bool)
    border_mask[0, :] = border_mask[-1, :] = border_mask[:, 0] = border_mask[:, -1] = True
    border_colors = input_grid[border_mask]
    background_color = np.argmax(np.bincount(border_colors))
    
    # Perform flood fill from the border to mark exterior background
    exterior_background = np.full(input_grid.shape, False)
    flood_fill_from_border(input_grid, exterior_background, background_color)
    
    # Find all connected components of the background color
    components = find_connected_components(input_grid, background=background_color, connectivity=4, monochromatic=True)
    
    # Identify components that are completely enclosed (not marked as exterior)
    for component in components:
        if not np.any(exterior_background[component]):
            # This is a completely enclosed hole, fill it with the target object color
            target_color = find_target_color_around(component, input_grid)
            component[component == background_color] = target_color
            blit_object(output_grid, component, background=background_color)

    return output_grid

def flood_fill_from_border(grid, fill_mask, background_color):
    from queue import Queue
    q = Queue()
    for x in range(grid.shape[0]):
        for y in [0, grid.shape[1] - 1]:
            if grid[x, y] == background_color and not fill_mask[x, y]:
                q.put((x, y))
                fill_mask[x, y] = True
    for y in range(grid.shape[1]):
        for x in [0, grid.shape[0] - 1]:
            if grid[x, y] == background_color and not fill_mask[x, y]:
                q.put((x, y))
                fill_mask[x, y] = True
    
    while not q.empty():
        x, y = q.get()
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:
                if grid[nx, ny] == background_color and not fill_mask[nx, ny]:
                    fill_mask[nx, ny] = True
                    q.put((nx, ny))

def find_target_color_around(component, grid):
    # Check the colors surrounding the component and choose the most common non-background color
    x, y = np.where(component)
    candidate_colors = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        for xi, yi in zip(x, y):
            nx, ny = xi + dx, yi + dy
            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1]:
                color = grid[nx, ny]
                if color != Color.BLACK:
                    candidate_colors.append(color)
    return max(set(candidate_colors), key=candidate_colors.count)


def generate_input():
    # Generate a grid of arbitrary size between 12x12 to 20x20
    n = np.random.randint(12, 20)
    grid = np.full((n, n), Color.BLACK)

    # Define the background color
    background_color = Color.BLACK

    # Create guide objects with possible holes inside them
    num_objects = np.random.randint(1, 4)
    for _ in range(num_objects):
        obj_w, obj_h = np.random.randint(4, n // 2), np.random.randint(4, n // 2)
        obj = np.full((obj_w, obj_h), np.random.choice(list(Color.NOT_BLACK)))
        interior = object_interior(obj, background=background_color)
        boundary = object_boundary(obj, background=background_color)
        interior[boundary] = False
        obj[~interior] = background_color

        # Randomly choose a location for the object within the grid
        try:
            x, y = random_free_location_for_sprite(grid, obj, background=background_color, border_size=1, padding=1)
            blit_sprite(grid, obj, x, y, background=background_color)
        except ValueError:
            continue

    return grid
```

This implementation follows the puzzle's instructions, using flood fill from the grid's border to identify exterior background and then determining fully enclosed holes to fill them with the target object's color. The `generate_input` function creates stochastic inputs with the described characteristics.