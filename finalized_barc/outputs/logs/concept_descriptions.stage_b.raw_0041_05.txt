Certainly! Let's create a new puzzle where the transformation involves identifying a guide object within the grid and performing a position-based transformation.

### Concepts:
- Object detection, guide object, position-based transformation

### Description:
- In the input, you will see a grid containing various objects of different colors. One of these objects will be distinctly colored, acting as a guide object.
- The task is to identify this guide object and use its position to initiate a transformation: rotate all other objects around the guide object by 90 degrees clockwise.
- The guide object itself remains unchanged in its position.

Now let's implement the `generate_input` and `main` functions using these concepts.

```python
from common import *

import numpy as np
from typing import *

# concepts:
# object detection, guide object, position-based transformation

# description:
# In the input, you will see a grid with colored objects. One object has a unique color and acts as a guide.
# Detect the guide object and use its position as the center to rotate all other objects 90 degrees clockwise around it.
# The guide object remains unchanged.

def main(input_grid):
    # Detect all objects in the grid
    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)

    # Identify the guide object by its unique color (assuming it's the only object with that color)
    guide_object = None
    guide_color = None
    for obj in objects:
        colors = object_colors(obj, background=Color.BLACK)
        if len(colors) == 1:
            color = colors[0]
            if guide_object is None or color != guide_color:
                guide_object = obj
                guide_color = color

    if guide_object is None:
        raise ValueError("No guide object found")

    # Calculate the guide object's center position
    gx, gy, gw, gh = bounding_box(guide_object, background=Color.BLACK)
    guide_center = (gx + gw // 2, gy + gh // 2)

    # Prepare the output grid
    output_grid = np.copy(input_grid)

    for obj in objects:
        if np.any(obj != guide_object):
            # Calculate object's center
            x, y, w, h = bounding_box(obj, background=Color.BLACK)
            obj_center = (x + w // 2, y + h // 2)

            # Calculate new position after 90-degree clockwise rotation
            new_x = guide_center[0] - (obj_center[1] - guide_center[1])
            new_y = guide_center[1] + (obj_center[0] - guide_center[0])

            # Translate the object to the new position
            translated_obj = translate(obj, new_x - x, new_y - y, background=Color.BLACK)
            blit_object(output_grid, translated_obj, background=Color.BLACK)

    return output_grid

def generate_input():
    # Generate the background grid
    n, m = np.random.randint(10, 15), np.random.randint(10, 15)
    grid = np.full((n, m), Color.BLACK)

    # Randomly select a unique color for the guide object
    guide_color = np.random.choice(Color.NOT_BLACK)
    
    # Generate the guide object
    guide_sprite = random_sprite(2, 2, color_palette=[guide_color])
    x, y = random_free_location_for_sprite(grid, guide_sprite, background=Color.BLACK, padding=1, border_size=1)
    blit_sprite(grid, guide_sprite, x, y)

    # Generate other objects with different colors
    for _ in range(np.random.randint(3, 6)):
        color = np.random.choice([c for c in Color.NOT_BLACK if c != guide_color])
        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[color])
        try:
            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)
            blit_sprite(grid, sprite, x, y)
        except ValueError:
            continue

    return grid
```

This puzzle challenges students to identify the unique guide object and apply a transformation to rotate other objects around it. The `generate_input` function ensures variability, while the `main` function applies a deterministic transformation based on the guide object's position.