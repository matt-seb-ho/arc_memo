You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
object identification, translation, erasure, grid manipulation

Description: 
Identify a single connected component (object) within the input grid. Determine its bounding box and erase the object by setting its pixels to the background color (0). Translate the object to a specified new position (row, column) by moving its bounding box to the new coordinates. Redraw the object at the new position, preserving its shape and color. The output grid reflects the object moved to the new location with its original position cleared.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def draw_line(grid, x, y, end_x=None, end_y=None, length=None, direction=None, color=None, stop_at_color=[]):
    """
    Draws a line starting at (x, y) extending to (end_x, end_y) or of the specified length in the specified direction
    Direction should be a vector with elements -1, 0, or 1.
    If length is None, then the line will continue until it hits the edge of the grid.

    stop_at_color: optional list of colors that the line should stop at. If the line hits a pixel of one of these colors, it will stop.

    Returns the endpoint of the line.

    Example:
    # blue diagonal line from (0, 0) to (2, 2)
    stop_x, stop_y = draw_line(grid, 0, 0, length=3, color=blue, direction=(1, 1))
    draw_line(grid, 0, 0, end_x=2, end_y=2, color=blue)
    assert (stop_x, stop_y) == (2, 2)
    """

def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_object(grid, obj, background=Color.BLACK):
    """
    Draws an object onto the grid using its current location.

    Example usage:
    blit_object(output_grid, an_object, background=background_color)
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def bounding_box(grid, background=Color.BLACK):
    """
    Find the bounding box of the non-background pixels in the grid.
    Returns a tuple (x, y, width, height) of the bounding box.

    Example usage:
    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=8)
    teal_object = [ obj for obj in objects if np.any(obj == Color.TEAL) ][0]
    teal_x, teal_y, teal_w, teal_h = bounding_box(teal_object)
    """

def object_position(obj, background=Color.BLACK, anchor='upper left'):
    """
    (x,y) position of the provided object. By default, the upper left corner.

    anchor: "upper left", "upper right", "lower left", "lower right", "center", "upper center", "lower center", "left center", "right center"

    Example usage:
    x, y = object_position(obj, background=background_color, anchor="upper left")
    middle_x, middle_y = object_position(obj, background=background_color, anchor="center")
    """

def crop(grid, background=Color.BLACK):
    """
    Crop the grid to the smallest bounding box that contains all non-background pixels.

    Example usage:
    # Extract a sprite from an object
    sprite = crop(an_object, background=background_color)
    """

def translate(obj, x, y, background=Color.BLACK):
    """
    Translate by the vector (x, y). Fills in the new pixels with the background color.

    Example usage:
    red_object = ... # extract some object
    shifted_red_object = translate(red_object, x=1, y=1)
    blit_object(output_grid, shifted_red_object, background=background_color)
    """

def collision(_=None, object1=None, object2=None, x1=0, y1=0, x2=0, y2=0, background=Color.BLACK):
    """
    Check if object1 and object2 collide when object1 is at (x1, y1) and object2 is at (x2, y2).

    Example usage:

    # Check if a sprite can be placed onto a grid at (X,Y)
    collision(object1=output_grid, object2=a_sprite, x2=X, y2=Y)

    # Check if two objects collide
    collision(object1=object1, object2=object2, x1=X1, y1=Y1, x2=X2, y2=Y2)
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

def object_interior(grid, background=Color.BLACK):
    """
    Computes the interior of the object (including edges)

    returns a new grid of `bool` where True indicates that the pixel is part of the object's interior.

    Example usage:
    interior = object_interior(obj, background=Color.BLACK)
    for x, y in np.argwhere(interior):
        # x,y is either inside the object or at least on its edge
    """

def random_sprite(n, m, density=0.5, symmetry=None, color_palette=None, connectivity=4, background=Color.BLACK):
    """
    Generate a sprite (an object), represented as a numpy array.

    n, m: dimensions of the sprite. If these are lists, then a random value will be chosen from the list.
    symmetry: optional type of symmetry to apply to the sprite. Can be 'horizontal', 'vertical', 'diagonal', 'radial', 'mirror', 'not_symmetric'. If None, a random symmetry type will be chosen.
    color_palette: optional list of colors to use in the sprite. If None, a random color palette will be chosen.

    Returns an (n,m) NumPy array representing the sprite.
    """

def detect_objects(grid, _=None, predicate=None, background=Color.BLACK, monochromatic=False, connectivity=None, allowed_dimensions=None, colors=None, can_overlap=False):
    """
    Detects and extracts objects from the grid that satisfy custom specification.

    predicate: a function that takes a candidate object as input and returns True if it counts as an object
    background: color treated as transparent
    monochromatic: if True, each object is assumed to have only one color. If False, each object can include multiple colors.
    connectivity: 4 or 8, for 4-way or 8-way connectivity. If None, the connectivity is determined automatically.
    allowed_dimensions: a list of tuples (n, m) specifying the allowed dimensions of the objects. If None, objects of any size are allowed.
    colors: a list of colors that the objects are allowed to have. If None, objects of any color are allowed.
    can_overlap: if True, objects can overlap. If False, objects cannot overlap.

    Returns a list of objects, where each object is a numpy array.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# objects, alignment by color

# description:
# In the input you will see some objects scattered around on a black grid. Each object has a single grey pixel, but everything else is a single other color.
# To make the output, place each object into the output grid such that the grey pixel is in the center of the output.
# Equivalently, move the objects to line up all their grey pixels so they overlap.
# The output grid should be the smallest possible size that contains all the objects (after they have been placed correctly), which for all the inputs here is 3x3.

def main(input_grid):
    # Plan:
    # 1. Extract the objects from the input, convert them into sprites by cropping them
    # 2. Make a big output grid
    # 3. Place each sprite into the output grid such that the grey pixel is in the center of the output
    # 4. Make the output as small as you can to contain all the objects

    # Extract the objects from the input. It is not monochromatic because the grey pixel is different, and they can be connected on the diagonals (connectivity=8)
    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)

    # Convert the objects into sprites by cropping them
    sprites = [crop(obj, background=Color.BLACK) for obj in objects]

    # Make a big output grid
    output_grid = np.full(input_grid.shape, Color.BLACK)

    # Place each sprite into the output grid such that the grey pixel is in the center of the output
    for sprite in sprites:
        # Find the grey pixel
        grey_pixel_x, grey_pixel_y = np.argwhere(sprite == Color.GREY)[0]

        # Find the center of the output. We want the grey pixel to end up here.
        center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2

        # Calculate the offset to ensure the grey pixel ends up in the center of the output
        x, y = center_x - grey_pixel_x, center_y - grey_pixel_y
        
        # Place the sprite into the output grid
        blit_sprite(output_grid, sprite, x, y, background=Color.BLACK)

    # Make the output as small as you can to contain all the objects
    output_grid = crop(output_grid)

    return output_grid


def generate_input():
    # Create a series of 3x3 objects, each of which has a great pixel at the center, and none of which overlap except for the grey pixels
    sprites = []

    # To make sure there is no overlap, we keep track of what pixels are already occupied
    occupied = np.full((3, 3), False)

    n_objects = np.random.randint(2, 4)
    for _ in range(n_objects):
        sprite = np.full((3, 3), Color.BLACK)
        sprite[1, 1] = Color.GREY
        other_color = random.choice([c for c in Color.NOT_BLACK if c != Color.GREY])

        # Randomly pick a subset of valid pixels to color
        # To be valid it has to be unoccupied and not grey (it will be black)
        valid_pixels = np.argwhere(~occupied & (sprite == Color.BLACK))
        if len(valid_pixels) == 0:
            break

        n_pixels = np.random.randint(1, len(valid_pixels) + 1)
        pixels = valid_pixels[np.random.choice(len(valid_pixels), n_pixels, replace=False)]
        for x, y in pixels:
            sprite[x, y] = other_color
            occupied[x, y] = True
        
        sprites.append(sprite)

    # Place the sprites randomly on a medium sized canvas but make sure they don't touch each other
    n, m = np.random.randint(10, 20), np.random.randint(10, 20)
    grid = np.full((n, m), Color.BLACK)
    for sprite in sprites:
        x, y = random_free_location_for_sprite(grid, sprite, padding=2, padding_connectivity=8)
        blit_sprite(grid, sprite, x, y)

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# filling, topology

# description:
# The input is a black 12x12 grid containing a few grey squares. Each square has a "hole" in it, a contiguous black region of pixels.
# To create the output, fill in the hole of each grey object with red if the hole is a square. Otherwise, leave the hole as is.

def main(input_grid):
    # get the grey squares
    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)

    # create an output grid to store the result
    output_grid = np.full(input_grid.shape, Color.BLACK)

    # for each grey square, fill in the hole if it is a square
    for obj in objects:
        # to check if the grey object contains a square hole, we can check if the bounding box of the hole is a square.
        # To do so, first crop the object, then find the black hole inside
        sprite = crop(obj, background=Color.BLACK)
        hole_mask = (sprite == Color.BLACK) & (object_interior(sprite, background=Color.BLACK))

        # check if the mask is square
        def is_square(thing):
            """thing can be a mask or a sprite or an object"""
            thing = crop(thing)
            return np.sum(thing != Color.BLACK) == thing.shape[0] * thing.shape[1] and thing.shape[0] == thing.shape[1]
        
        if is_square(hole_mask):
            sprite[hole_mask] = Color.RED

        # get location of object so we can blit the possibly edited sprite back into the grid
        x, y = object_position(obj, background=Color.BLACK)
        blit_sprite(output_grid, sprite, x, y)

    return output_grid


def generate_input():
    # create a 12x12 black grid
    grid = np.full((12, 12), Color.BLACK)

    # add 2-3 grey squares.
    # For each grey square, add a hole in the middle.
    # 50% chance the hole is a square, otherwise it's a random contiguous object.
    # The hole should not overlap with the border of the square.

    num_grey_squares = np.random.randint(2, 4)

    for _ in range(num_grey_squares):
        # create grey square, and try to find a location for it
        length = np.random.randint(4, 6)
        grey_square = np.full((length, length), Color.GREY)
        try:
            x, y = random_free_location_for_sprite(grid, grey_square, padding=1)
        except ValueError:
            # we were unable to find a space for a square; try over from scratch
            return generate_input()

        # # add a hole in the middle.
        # # 50% chance the hole is a square, otherwise it's a random contiguous object.
        # # The hole should not overlap with the border of the square.
        has_square_hole = np.random.choice([True, False])
        if has_square_hole:
            hole_size = np.random.randint(1, length - 1)
            hole_x, hole_y = np.random.randint(1, length - hole_size), np.random.randint(1, length - hole_size)
            grey_square[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK
        else:
            hole_obj = random_sprite(length-2, length-2, color_palette=[Color.BLACK], background=Color.GREY)
            grey_square[1:-1, 1:-1] = hole_obj

        grid = blit_sprite(grid, grey_square, x, y)

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# growing

# description:
# In the input you will see a grid with some green rectangles. Each rectangle has one red pixel on one of its borders.
# To make the output, you should extend the green region of each rectangle to the border of the grid in the direction of the red pixel, with the extent of the line increasing with the extent of the rectangle.
# Also you should draw a red line from the red pixel to the border of the grid.


def main(input_grid):
    # Initialize the output grid
    output_grid = np.copy(input_grid)
    
    rectangle_color = Color.GREEN
    indicator_color = Color.RED
    background = Color.BLACK

    # get all the green rectangles on the grid. because of the red pixel on the border of the rectangle, they are not monochromatic.
    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=background)
    for obj in objects:
        # find the red indicator
        for red_x, red_y in np.argwhere(obj == indicator_color):
            break

        # Get the dimensions of the object, and its position
        x, y, width, height = bounding_box(obj, background=background)  

        # depending on which side of the rectangle that the indicator is on, we draw in different directions
        # left edge: draw to the left
        if red_x == x:
            # Extend the green rectangle to the left until it reaches the border
            output_grid[0:red_x, red_y-(width-1) : red_y+(width-1)+1] = rectangle_color
            # Draw the red line from the red pixel to the border
            draw_line(output_grid, x=red_x, y=red_y, direction=(-1, 0), color=indicator_color)
        elif red_x == x + width - 1:
            # Extend the green rectangle to the right until it reaches the border
            output_grid[red_x:, red_y-(width-1) : red_y+(width-1)+1] = rectangle_color
            # Draw the red line from the red pixel to the border
            draw_line(output_grid, x=red_x, y=red_y, direction=(1, 0), color=indicator_color)
        elif red_y == y:
            # Extend the green rectangle to the top until it reaches the border
            output_grid[red_x-(height-1) : red_x+(height-1)+1, 0:red_y] = rectangle_color
            # Draw the red line from the red pixel to the border
            draw_line(output_grid, x=red_x, y=red_y, direction=(0, -1), color=indicator_color)
        elif red_y == y + height - 1:
            # Extend the green rectangle to the bottom until it reaches the border
            output_grid[red_x-(height-1) : red_x+(height-1)+1, red_y:] = rectangle_color
            # Draw the red line from the red pixel to the border
            draw_line(output_grid, x=red_x, y=red_y, direction=(0, 1), color=indicator_color)
        else:
            assert False, "The red pixel is not on the border of the rectangle"

    return output_grid

def generate_input():
    # Create the background grid
    n, m = np.random.randint(20, 30), np.random.randint(20, 30)
    grid = np.full((n, m), Color.BLACK)

    rectangle_num = 2
    rectangle_color = Color.GREEN
    indicator_color = Color.RED

    # Draw rectangles on the grid
    for i in range(rectangle_num):
        width, height = np.random.randint(3, 20), np.random.randint(3, 20)

        # The width should be twice smaller than the height
        while (width * 2 + 2) >= height:
            width, height = np.random.randint(3, 20), np.random.randint(3, 20)

        green_rectangle = np.full((width, height), rectangle_color)

        # Place one indicator pixel on one random border of the rectangle
        # Spare enough space for the extend line with the same size of width - 1
        x_coord = np.random.choice([0, width - 1])
        y_coord = np.random.choice(range(width + 1, height - (width + 1)))
        green_rectangle[x_coord, y_coord] = indicator_color
        # Randomly rotate the object so that we get a variety of orientations
        if np.random.choice([True, False]):
            green_rectangle = np.rot90(green_rectangle)
            x_coord, y_coord = y_coord, x_coord

        # Place the rectangle on the grid
        try:
            x, y = random_free_location_for_sprite(grid=grid, sprite=green_rectangle, padding=2, padding_connectivity=8)        
        # Check if there is no space for the rectangle
        except:
            return generate_input()
        blit_sprite(grid, green_rectangle, x=x, y=y)

    # Check if the generated grid is valid
    transformed_grid = main(grid)
    objects = find_connected_components(grid=transformed_grid, connectivity=4, monochromatic=False)

    # After transformation, the two objects should not touch each other
    if len(objects) != rectangle_num:
        # Regenerate the grid
        return generate_input()

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# alignment, copy to object border

# description:
# In the input you will see a teal object on a black background, and several colored pixels on the border of canvas.
# To make the output grid, you should copy the colored pixels horizontally/vertically so that they are just barely overlapping/colliding with the teal object.

def main(input_grid):
    # Plan:
    # 1. Detect the teal object
    # 2. Detect the colored pixels on the border
    # 3. Slide the colored pixels in the 4 cardinal directions until we find how to make them overlapping with the teal object

    output_grid = np.copy(input_grid)

    # Detects the rectangle in the input grid that is TEAL
    teal_objects = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=4)
    
    # There should only be one rectangle of the color TEAL has been detected in the grid.
    assert len(teal_objects) == 1
    teal_object = teal_objects[0]

    # colored pixels are NOT black and NOT TEAL.
    colors_except_teal = [c for c in Color.NOT_BLACK if c != Color.TEAL]
    
    # Detects all other colored pixels in the grid 
    pixels = detect_objects(grid=input_grid,
                            # Exclude teal from the search
                            colors=colors_except_teal, 
                            # only consider single pixels
                            allowed_dimensions=[(1,1)], 
                            monochromatic=True, connectivity=4)

    # Copy the colored pixels to the teal object by moving them either vertically or horizontally.
    for pixel in pixels:
        # consider translating the pixel in the 4 cardinal directions, and consider translating as far as possible
        possible_displacements = [ (slide_distance*dx, slide_distance*dy)
                                   # We could slide as far as the maximum grid extent
                                   for slide_distance in range(max(input_grid.shape))
                                   # (dx, dy) ranges over 4 cardinal directions
                                   for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)] ]
        for dx, dy in possible_displacements:
            # check if the objects are colliding/overlapping after translating
            translated_pixel = translate(pixel, dx, dy, background=Color.BLACK)
            if collision(object1=teal_object, object2=translated_pixel):
                # put the red object where it belongs
                blit_object(output_grid, translated_pixel, background=Color.BLACK)
                break
    
    return output_grid


def generate_input():
    # Initialize a 10x10 grid representing a black background.
    n = m = 10
    grid = np.zeros((n, m), dtype=int)
    
    # Randomly determine the width and height of the TEAL rectangle between 2 and 5.
    width, height = np.random.randint(2, 6), np.random.randint(2, 6)
    teal_sprite = np.full((width, height), Color.TEAL)

    # Find a free location for this sprite and blit it to the grid
    x, y = random_free_location_for_sprite(grid, teal_sprite, background=Color.BLACK, padding=1, border_size=1)
    blit_sprite(grid, teal_sprite, x, y, background=Color.BLACK)

    # list to hold the available positions, which are all on the border of the canvas
    border_locations = [ (0, y) for y in range(n) ] + [ (m-1, y) for y in range(n) ] + [ (x, 0) for x in range(1, m-1) ] + [ (x, n-1) for x in range(1, m-1) ]
    
    # Put a random number of colored pixels on the border of the canvas
    for _ in range(np.random.randint(3, 8)):
        # Pick a random location on the border
        x, y = random.choice(border_locations)
        # Pick a random color that is not black or teal
        color = random.choice([c for c in Color.NOT_BLACK if c != Color.TEAL])

        grid[x, y] = color
    
    return grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
