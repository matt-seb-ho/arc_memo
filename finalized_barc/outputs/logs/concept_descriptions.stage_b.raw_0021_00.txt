```python
from common import *

import numpy as np
from typing import *

# concepts:
# grid partitioning, divider lines, horizontal/vertical slicing

# description:
# Input is a grid containing horizontal and/or vertical divider lines of a single color that segment the grid into distinct regions.
# Identify these uninterrupted divider lines and use them to partition the grid into separate sub-grids.
# Each sub-grid is bounded by the divider lines and contains no dividers within it. Output is a list of these non-empty sub-grids, preserving their original content.

def main(input_grid: np.ndarray) -> List[np.ndarray]:
    # Plan:
    # 1. Identify the color of the divider lines
    # 2. Determine positions of horizontal and vertical divider lines
    # 3. Use these dividers to slice the grid into sub-grids
    # 4. Return the list of sub-grids

    # 1. Identify the divider color by finding any line that extends fully horizontally or vertically
    divider_color = None
    for i in range(input_grid.shape[0]):
        if np.all(input_grid[i, :] == input_grid[i, 0]):
            divider_color = input_grid[i, 0]
            break
    
    for j in range(input_grid.shape[1]):
        if np.all(input_grid[:, j] == input_grid[0, j]):
            divider_color = input_grid[0, j]
            break

    assert divider_color is not None, "No divider color found"
    
    # 2. Determine positions of horizontal and vertical divider lines
    vertical_lines = [x for x in range(input_grid.shape[0]) if np.all(input_grid[x, :] == divider_color)]
    horizontal_lines = [y for y in range(input_grid.shape[1]) if np.all(input_grid[:, y] == divider_color)]

    # 3. Use these dividers to slice the grid into sub-grids
    sub_grids = []
    previous_vertical = 0
    for v in vertical_lines + [input_grid.shape[0]]:  # include end of grid
        previous_horizontal = 0
        for h in horizontal_lines + [input_grid.shape[1]]:  # include end of grid
            sub_grid = input_grid[previous_vertical:v, previous_horizontal:h]
            if sub_grid.size > 0 and np.any(sub_grid != divider_color):
                sub_grids.append(sub_grid)
            previous_horizontal = h + 1
        previous_vertical = v + 1

    return sub_grids

def generate_input() -> np.ndarray:
    # Set grid dimensions
    width, height = np.random.randint(20, 30), np.random.randint(20, 30)
    grid = np.random.choice(Color.NOT_BLACK, (width, height), replace=True)

    # Randomly select a color to be the divider
    divider_color = np.random.choice(Color.NOT_BLACK)

    # Randomly place horizontal and vertical dividers
    num_vertical_dividers = np.random.randint(1, 4)
    num_horizontal_dividers = np.random.randint(1, 4)

    vertical_indices = randomly_spaced_indices(max_len=width, n_indices=num_vertical_dividers, border_size=1, padding=2)
    horizontal_indices = randomly_spaced_indices(max_len=height, n_indices=num_horizontal_dividers, border_size=1, padding=2)

    for x in vertical_indices:
        grid[x, :] = divider_color

    for y in horizontal_indices:
        grid[:, y] = divider_color

    return grid
```