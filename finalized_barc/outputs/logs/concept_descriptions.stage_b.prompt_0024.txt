You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
recolor, connected components, color scheme

Description: 
Identify a single connected object in the input grid. Apply a given color scheme to recolor the entire object. The color scheme may be a single color applied uniformly or a logic that determines the color for each part of the object. All other grid elements remain unchanged.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def flood_fill(grid, x, y, color, connectivity=4):
    """
    Fill the connected region that contains the point (x, y) with the specified color.

    connectivity: 4 or 8, for 4-way or 8-way connectivity. 8-way counts diagonals as connected, 4-way only counts cardinal directions as connected.
    """

def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_object(grid, obj, background=Color.BLACK):
    """
    Draws an object onto the grid using its current location.

    Example usage:
    blit_object(output_grid, an_object, background=background_color)
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def bounding_box(grid, background=Color.BLACK):
    """
    Find the bounding box of the non-background pixels in the grid.
    Returns a tuple (x, y, width, height) of the bounding box.

    Example usage:
    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=8)
    teal_object = [ obj for obj in objects if np.any(obj == Color.TEAL) ][0]
    teal_x, teal_y, teal_w, teal_h = bounding_box(teal_object)
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

def object_interior(grid, background=Color.BLACK):
    """
    Computes the interior of the object (including edges)

    returns a new grid of `bool` where True indicates that the pixel is part of the object's interior.

    Example usage:
    interior = object_interior(obj, background=Color.BLACK)
    for x, y in np.argwhere(interior):
        # x,y is either inside the object or at least on its edge
    """

def random_sprite(n, m, density=0.5, symmetry=None, color_palette=None, connectivity=4, background=Color.BLACK):
    """
    Generate a sprite (an object), represented as a numpy array.

    n, m: dimensions of the sprite. If these are lists, then a random value will be chosen from the list.
    symmetry: optional type of symmetry to apply to the sprite. Can be 'horizontal', 'vertical', 'diagonal', 'radial', 'mirror', 'not_symmetric'. If None, a random symmetry type will be chosen.
    color_palette: optional list of colors to use in the sprite. If None, a random color palette will be chosen.

    Returns an (n,m) NumPy array representing the sprite.
    """

def detect_objects(grid, _=None, predicate=None, background=Color.BLACK, monochromatic=False, connectivity=None, allowed_dimensions=None, colors=None, can_overlap=False):
    """
    Detects and extracts objects from the grid that satisfy custom specification.

    predicate: a function that takes a candidate object as input and returns True if it counts as an object
    background: color treated as transparent
    monochromatic: if True, each object is assumed to have only one color. If False, each object can include multiple colors.
    connectivity: 4 or 8, for 4-way or 8-way connectivity. If None, the connectivity is determined automatically.
    allowed_dimensions: a list of tuples (n, m) specifying the allowed dimensions of the objects. If None, objects of any size are allowed.
    colors: a list of colors that the objects are allowed to have. If None, objects of any color are allowed.
    can_overlap: if True, objects can overlap. If False, objects cannot overlap.

    Returns a list of objects, where each object is a numpy array.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# object detection, color change

# description:
# In the input you will see a grid with a red pattern
# To make the output grid, you should find out any single isolated red objects with size of 1x1 and change them to blue.

def main(input_grid):
    # Detect all the red objects in the grid, ignoring objects of other colors
    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)

    # Convert 1x1 objects (isolated pixels) into blue
    output_grid = input_grid.copy()
    for object in red_objects:
        x, y, length, width = bounding_box(object, background=Color.BLACK)
        # Find out the single isolated red object with size of 1x1 and change it to blue.
        if length == 1 and width == 1:
            output_grid[x, y] = Color.BLUE

    return output_grid

def generate_input():
    # Generate the background grid with size of n x m.
    n, m = np.random.randint(3, 6), np.random.randint(3, 6)
    grid = np.zeros((n, m), dtype=int)

    colored = 0
    # Randomly scatter density of red pixels on the grid.
    density = 0.4
    while colored < density * n * m:
        x = np.random.randint(0, n)
        y = np.random.randint(0, m)
        if grid[x, y] == Color.BLACK:
            grid[x, y] = Color.RED
            colored += 1

    # Ensure there is at least one 1x1 single isolated red object in the grid.
    red_objects = detect_objects(grid=grid, colors=[Color.RED], monochromatic=True, connectivity=4)
    if not any(np.sum(object != Color.BLACK) == 1 for object in red_objects):
        return generate_input()
    
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# objects, topology

# description:
# In the input grid, you will see various blue objects. Some are "hollow" and contain a fully-enclosed region, while others do not have a middle that is separate from outside the object, and fully enclosed.
# To create the output grid, copy the input grid. Then, change the color of all "hollow" shapes to be green.

def main(input_grid):
    objects = find_connected_components(input_grid, connectivity=4)
    output_grid = input_grid.copy()
    for object in objects:
        if is_hollow(object):
            object[object != Color.BLACK] = Color.GREEN
        blit_object(output_grid, object, background=Color.BLACK)

    return output_grid

def is_hollow(object):
    # to check if it contains a fully enclosed region, find everything that is enclosed by the object (in its interior), but not actually part of the object
    interior_mask = object_interior(object)
    object_mask = object != Color.BLACK
    hollow_mask = interior_mask & ~object_mask
    return np.any(hollow_mask)


def generate_input():
    n = np.random.randint(10, 28)
    input_grid = np.full((n, n), Color.BLACK)
    # create a bunch of random objects. all objects are either (1) hollow, in which case they are the border of a rectangle of some size, or (2) not hollow, in which case they are a subset of a border of a rectangle of some size.
    # make sure we place at least one hollow and nonhollow object. then add random objects until somewhat full.

    def random_hollow_object():
        n, m = np.random.randint(3, 7), np.random.randint(3, 7)
        obj = np.full((n, m), Color.BLUE)
        obj[1:n-1, 1:m-1] = Color.BLACK
        return obj

    def random_nonhollow_object():
        obj = random_hollow_object()
        # remove a random number of dots from it
        size = np.count_nonzero(obj)
        new_size = np.random.randint(1, size)
        xs, ys = np.where(obj != Color.BLACK)
        for i in range(size - new_size):
            obj[xs[i], ys[i]] = Color.BLACK

        return obj

    try:
        # add one hollow and one nonhollow object, then add random objects until somewhat full.
        obj = random_hollow_object()
        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)
        blit_sprite(input_grid, obj, x=x, y=y)

        obj = random_nonhollow_object()
        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)
        blit_sprite(input_grid, obj, x=x, y=y)
    except ValueError:
        return generate_input()

    while True:
        obj = random_hollow_object() if np.random.rand() < 0.5 else random_nonhollow_object()
        try:
            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)
            blit_sprite(input_grid, obj, x=x, y=y)
        except ValueError:
            return input_grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# rectangular cells, flood fill, connecting same color

# description:
# In the input you will see horizontal and vertical bars that divide the grid into rectangular cells
# To make the output, find any pair of rectangular cells that are in the same row and column and have the same color, then color all the rectangular cells between them with that color

def main(input_grid: np.ndarray) -> np.ndarray:

    # find the color of the horizontal and vertical bars that divide the rectangular cells
    # this is the color of any line that extends all the way horizontally or vertically
    jail_color = None
    for i in range(input_grid.shape[0]):
        for j in range(input_grid.shape[1]):
            color = input_grid[i][j]
            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):
                jail_color = color
                break
    
    assert jail_color is not None, "No jail color found"

    output_grid = input_grid.copy()

    # color all the cells between the same color pixels
    for x in range(input_grid.shape[0]):
        for y in range(input_grid.shape[1]):
            color = input_grid[x][y]
            if color == jail_color or color == Color.BLACK:
                continue

            # check if there is a cell with the same color in the same X value
            for y2 in range(y+1, input_grid.shape[1]):
                if input_grid[x][y2] == color:
                    for y3 in range(y+1, y2):
                        if input_grid[x][y3] == Color.BLACK:
                            output_grid[x][y3] = color
                    break

            # check if there is a cell with the same color in the same Y value
            for x2 in range(x+1, input_grid.shape[0]):
                if input_grid[x2][y] == color:
                    for x3 in range(x+1, x2):
                        if input_grid[x3][y] == Color.BLACK:
                            output_grid[x3][y] = color
                    break
                
    return output_grid

def generate_input() -> np.ndarray:

    grid_size = 32
    cell_size = 2

    # First create the array of rectangular cells, each of which is separated by horizontal and vertical bars dividing cells

    # pick a non-black color for the divider
    divider_color = random.choice(Color.NOT_BLACK)
    grid = np.zeros((grid_size, grid_size), dtype=int)
    r_offset_x, r_offset_y = np.random.randint(0, cell_size), np.random.randint(0, cell_size)

    # make horizontal bars with cell_size gaps, but +1 because we need to include the divider, which is one pixel wide
    for x in range(r_offset_x, grid_size, cell_size+1):
        grid[x, :] = divider_color
    # make vertical bars with cell_size gaps
    for y in range(r_offset_y, grid_size, cell_size+1):
        grid[:, y] = divider_color

    # Second we will color some of the cells with a random color

    # random number of cells to color
    number_to_color = np.random.randint(1, 4)
    for _ in range(number_to_color):
        # pick what we're going to color the inside of the cell, which needs to be a different color from the divider
        other_color = np.random.choice([c for c in Color.ALL_COLORS if c != divider_color and c != Color.BLACK])

        # get all coords of black cells
        black_coords = np.argwhere(grid == Color.BLACK)
        # pick a random black cell
        x, y = random.choice(black_coords)
        flood_fill(grid, x, y, other_color)

        # sometimes skip coloring the other side of the divider
        if random.random() <= 0.2:
            continue 

        # flip a coin to decide if horizontal or vertical
        h_or_v = random.random() < 0.5
        if h_or_v:
            # horizontal
            # get all the black cells in the same row
            black_coords = np.argwhere(grid[x, :] == Color.BLACK)
            # pick a random black cell
            other_y = random.choice(black_coords)
            flood_fill(grid, x, other_y, other_color)
        else:
            # vertical
            # get all the black cells in the same column
            black_coords = np.argwhere(grid[:, y] == Color.BLACK)
            # pick a random black cell
            other_x = random.choice(black_coords)
            flood_fill(grid, other_x, y, other_color)

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# counting

# description:
# The input consists of several grey objects in a 10x10 grid.
# To create the output, change the color of all objects of area 6 to red, and all other objects to blue.

def main(input_grid):
    # extract objects
    objects = find_connected_components(input_grid, connectivity=4)

    # convert each object to the desired color
    for obj in objects:
        if np.sum(obj != Color.BLACK) == 6:
            obj[obj != Color.BLACK] = Color.RED
        else:
            obj[obj != Color.BLACK] = Color.BLUE

    # place new objects back into a grid
    output_grid = np.zeros_like(input_grid)
    for obj in objects:
        output_grid = blit_object(output_grid, obj, background=Color.BLACK)

    return output_grid


def generate_input():
    # create a 10x10 grid
    grid = np.full((10, 10), Color.BLACK)

    # generate objects and place into the grid until it is filled
    # we want some area six objects, and some non-area six objects.
    # to do so, first place a couple area six objects, then fill up the remaining space with random objects

    # place two area six objects
    for _ in range(2):
        while True:
            obj = random_sprite(list(range(1, 5)), list(range(1, 5)), color_palette=[Color.GREY])
            if np.sum(obj != Color.BLACK) == 6:
                break
        x, y = random_free_location_for_sprite(grid, obj, padding=1)
        grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)

    # now fill up the remaining space with random objects.
    while True:
        obj = random_sprite(list(range(1, 5)), list(range(1, 5)), color_palette=[Color.GREY])

        # try to place the object. if we can't, we're done
        try:
            x, y = random_free_location_for_sprite(grid, obj, padding=1)
            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)
        except ValueError:
            break

    return grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
