You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
gravity simulation, directional movement, cohesion modes, collision detection

Description: 
Input consists of blocks on a grid with a specified gravity direction ('down', 'up', 'left', 'right'). Apply gravity to translate blocks in the given direction until they rest on obstacles or boundaries. If cohesion mode is 'per-column', each column of blocks falls independently, stopping at blockers; if 'cohesive', treat the entire block structure as a single rigid shape and move it until contact. Maintain block order and shape; stop when further movement would result in collision or leaving the grid. The output grid shows blocks shifted flush against walls or other blocks along the gravity direction, with empty space opposite the fall direction.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_object(grid, obj, background=Color.BLACK):
    """
    Draws an object onto the grid using its current location.

    Example usage:
    blit_object(output_grid, an_object, background=background_color)
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def object_colors(obj, background=Color.BLACK):
    """
    Returns a list of colors in the object.

    Example usage:
    colors = object_colors(obj, background=background_color)
    """

def translate(obj, x, y, background=Color.BLACK):
    """
    Translate by the vector (x, y). Fills in the new pixels with the background color.

    Example usage:
    red_object = ... # extract some object
    shifted_red_object = translate(red_object, x=1, y=1)
    blit_object(output_grid, shifted_red_object, background=background_color)
    """

def collision(_=None, object1=None, object2=None, x1=0, y1=0, x2=0, y2=0, background=Color.BLACK):
    """
    Check if object1 and object2 collide when object1 is at (x1, y1) and object2 is at (x2, y2).

    Example usage:

    # Check if a sprite can be placed onto a grid at (X,Y)
    collision(object1=output_grid, object2=a_sprite, x2=X, y2=Y)

    # Check if two objects collide
    collision(object1=object1, object2=object2, x1=X1, y1=Y1, x2=X2, y2=Y2)
    """

def contact(_=None, object1=None, object2=None, x1=0, y1=0, x2=0, y2=0, background=Color.BLACK, connectivity=4):
    """
    Check if object1 and object2 touch each other (have contact) when object1 is at (x1, y1) and object2 is at (x2, y2).
    They are touching each other if they share a border, or if they overlap. Collision implies contact, but contact does not imply collision.

    connectivity: 4 or 8, for 4-way or 8-way connectivity. (8-way counts diagonals as touching, 4-way only counts cardinal directions as touching)

    Example usage:

    # Check if a sprite touches anything if it were to be placed at (X,Y)
    contact(object1=output_grid, object2=a_sprite, x2=X, y2=Y)

    # Check if two objects touch each other
    contact(object1=object1, object2=object2)
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

def orbit(grid, x, y, symmetries):
    """
    Compute the orbit of the point (x, y) under the symmetry transformations `symmetries`.
    The orbit is the set of points that the point (x, y) maps to after applying the symmetry transformations different numbers of times.
    Returns a list of points in the orbit.

    Example:
    symmetries = detect_rotational_symmetry(input_grid)
    for x, y in np.argwhere(input_grid != Color.BLACK):
        # Compute orbit on to the target grid, which is typically the output
        symmetric_points = orbit(output_grid, x, y, symmetries)
        # ... now we do something with them like copy colors or infer missing colors
    """

def detect_translational_symmetry(grid, ignore_colors=[Color.BLACK], background=None):
    """
    Finds translational symmetries in a grid.
    Satisfies: grid[x, y] == grid[x + translate_x, y + translate_y] for all x, y, as long as neither pixel is in `ignore_colors`, and as long as x,y is not background.

    Returns a list of Symmetry objects, each representing a different translational symmetry.

    Example:
    symmetries = detect_translational_symmetry(grid, ignore_colors=[occluder_color], background=background_color)
    for x, y in np.argwhere(grid != occluder_color & grid != background_color):
        # Compute orbit on to the target grid
        # When copying to an output, this is usually the output grid
        symmetric_points = orbit(grid, x, y, symmetries)
        for x, y in symmetric_points:
            assert grid[x, y] == grid[x, y] or grid[x, y] == occluder_color
    """

def random_sprite(n, m, density=0.5, symmetry=None, color_palette=None, connectivity=4, background=Color.BLACK):
    """
    Generate a sprite (an object), represented as a numpy array.

    n, m: dimensions of the sprite. If these are lists, then a random value will be chosen from the list.
    symmetry: optional type of symmetry to apply to the sprite. Can be 'horizontal', 'vertical', 'diagonal', 'radial', 'mirror', 'not_symmetric'. If None, a random symmetry type will be chosen.
    color_palette: optional list of colors to use in the sprite. If None, a random color palette will be chosen.

    Returns an (n,m) NumPy array representing the sprite.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """

class Symmetry:
    """
    Symmetry transformations, which transformed the 2D grid in ways that preserve visual structure.
    Returned by `detect_rotational_symmetry`, `detect_translational_symmetry`, `detect_mirror_symmetry`.
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# magnetism, direction, lines

# description:
# In the input, you will see a black grid with teal pixels scattered along one edge and red pixels scattered along an edge perpendicular to the teal one.
# To make the output, make the teal pixels flow from the edge they are on to the opposite edge. Whenever there is a red pixel in the same column or row as the flow of teal pixels, push the teal pixel's flow one pixel away from the red pixel.

def main(input_grid):
    # copy the input grid to the output grid
    output_grid = np.copy(input_grid)

    # figure out which edges the red and teal pixels are on and decide the direction of flow and push based on that
    top = output_grid[:,0]
    bottom = output_grid[:, -1]
    left = output_grid[0, :]
    if Color.RED in top:
        # push the teal pixels down
        push = (0, 1)

        # teal can only be on the left or right edge if red is on the top edge
        if Color.TEAL in left:
            flow = (1, 0) # flow right
        else:
            flow = (-1, 0) # flow left    
    elif Color.RED in bottom:
        # push the teal pixels up
        push = (0, -1)

        # teal can only be on the left or right edge if red is on the bottom edge
        if Color.TEAL in left:
            flow = (1, 0) # flow right
        else:
            flow = (-1, 0) # flow left
    elif Color.RED in left:
        # push the teal pixels to the right
        push = (1, 0)

        # teal can only be on the top or bottom edge if red is on the left edge
        if Color.TEAL in top:
            flow = (0, 1) # flow down
        else:
            flow = (0, -1) # flow up
    else: # red is on the right edge
        # push the teal pixels to the left
        push = (-1, 0)
        
        # teal can only be on the top or bottom edge if red is on the right edge
        if Color.TEAL in top:
            flow = (0, 1) # flow down
        else:
            flow = (0, -1) # flow up

    # find the coordinates of the teal and red pixels
    teal = np.where(input_grid == Color.TEAL)
    red = np.where(input_grid == Color.RED)

    # draw the flow of teal pixels
    for i in range(len(teal[0])):
        # start at a teal pixel
        x, y = teal[0][i], teal[1][i]

        # draw across the grid one pixel at a time adjusting for red pixel effects
        while x >= 0 and x < output_grid.shape[0] and y >= 0 and y < output_grid.shape[1]:
            # push the teal pixel away from the red pixel if it is in the same row or column
            if x in red[0] or y in red[1]:
                x += push[0]
                y += push[1]

                # stop this flow if it goes off the grid
                if x < 0 or x >= output_grid.shape[0] or y < 0 or y >= output_grid.shape[1]:
                    break
                
            # draw a teal pixel in the flow
            output_grid[x, y] = Color.TEAL

            # move the flow one pixel in the direction of flow
            x += flow[0]
            y += flow[1]

    return output_grid


def generate_input():
    # make a black grid as the background
    n = np.random.randint(10, 20)
    m = np.random.randint(10, 20)
    grid = np.zeros((n, m), dtype=int)

    # select which edges will be teal and which will be red
    top_or_bottom_color = np.random.choice([Color.TEAL, Color.RED])
    left_or_right_color = Color.TEAL if top_or_bottom_color == Color.RED else Color.RED

    # make a random vector of length m for the top or bottom edge of the grid
    top_or_bottom = np.zeros(m, dtype=int)

    # scatter the selected color anywhere along the vector except the ends
    top_or_bottom[np.random.choice(range(1, m-1), np.random.randint(2, 5), replace=False)] = top_or_bottom_color
    
    # make a random vector of length n for the left or right edge of the grid
    left_or_right = np.zeros(n, dtype=int)

    # scatter the selected color anywhere along the vector except the ends
    left_or_right[np.random.choice(range(1, n-1), np.random.randint(2, 5), replace=False)] = left_or_right_color

    # randomly put the top_or_bottom vector on the top or bottom of the grid
    if np.random.rand() < 0.5:
        grid[0] = top_or_bottom
    else:
        grid[-1] = top_or_bottom
    
    # randomly put the left_or_right vector on the left or right of the grid
    if np.random.rand() < 0.5:
        grid[:,0] = left_or_right
    else:
        grid[:,-1] = left_or_right
    
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# alignment, objects

# description:
# In the input you will see a red, blue, and yellow shape. Each are the same shape (but different color). They occur left to right in the input grid on a black background, but at different vertical heights.
# The output is the same as the input, but with the vertical heights of the red and yellow shapes adjusted to match the height of the blue shape.

def main(input_grid):
    # find the blue shape, red shape, and yellow shape
    blue_coords = np.where(input_grid == Color.BLUE)
    red_coords = np.where(input_grid == Color.RED)
    yellow_coords = np.where(input_grid == Color.YELLOW)

    # set the vertical height of the red and yellow shape to match
    red_coords = (red_coords[0], blue_coords[1])
    yellow_coords = (yellow_coords[0], blue_coords[1])

    # make output grid with the colored shapes at their new locations
    output_grid = np.full_like(input_grid, Color.BLACK)
    output_grid[blue_coords] = Color.BLUE
    output_grid[red_coords] = Color.RED
    output_grid[yellow_coords] = Color.YELLOW

    return output_grid


def generate_input():

    # All three shapes are the same shape, but different colors, so we generate one sprite and color it three ways
    # We put each sprite in a different grid, and concatenate the grids to make the input grid

    # make a random sprite of size (1-4)x(1-4)
    w = np.random.randint(1, 5)
    h = np.random.randint(1, 5)
    sprite = random_sprite(w, h)

    # Figure out the height of the output grid
    # This has to be the same across all three colors, because we concatenate them along the x axis
    grid_height = np.random.randint(h+1, 16)

    # for each color,
    # put a colored form of the shape in a random spot in a new grid
    subgrids = []
    for color in [Color.BLUE, Color.RED, Color.YELLOW]:
        # make a grid to put the shape in
        # the grid should be wide enough to fit the shape, which has width w
        grid_width = np.random.randint(w, 30//3)
        subgrid = np.full((grid_width, grid_height), Color.BLACK, dtype=int)

        # make the shape that color
        colored_sprite = np.copy(sprite)
        colored_sprite[sprite != Color.BLACK] = color

        # put the shape in a random spot in its grid
        x, y = random_free_location_for_sprite(subgrid, colored_sprite)
        blit_sprite(subgrid, colored_sprite, x, y)
        subgrids.append(subgrid)

    # now concatenate the subgrids along the x axis to make the input grid
    grid = np.concatenate(subgrids, axis=0)
    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# translational symmetry, symmetry detection

# description:
# In the input you will see a grid consisting of a blue sprite that is repeatedly translated vertically, forming a stack of the same sprite.
# To make the output, expand the input to have height 9, and continue to repeatedly translate the sprite vertically. Change color to red.
 
def main(input_grid):
    # Plan:
    # 1. Find the repeated translation, which is a symmetry
    # 2. Extend the pattern by copying the sprite and its symmetric copies
    # 3. Change the color from blue to red
    
    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[], background=Color.BLACK)
    assert len(symmetries) > 0, "No translational symmetry found"

    # make the output (the height is now 9)
    output_grid = np.full((input_grid.shape[0], 9), Color.BLACK)
    
    # Copy all of the input pixels to the output, INCLUDING their symmetric copies (i.e. their orbit)
    for x, y in np.argwhere(input_grid != Color.BLACK):
        # Compute the orbit into the output grid
        for x2, y2 in orbit(output_grid, x, y, symmetries):
            output_grid[x2, y2] = input_grid[x, y]
    
    # Color change: blue -> red
    output_grid[output_grid == Color.BLUE] = Color.RED

    return output_grid


def generate_input():
    # grid is always 3x6
    grid = np.zeros((3, 6),dtype = int)

    # The input is always blue
    color = Color.BLUE

    # Creates a random smaller sprite, where the height (period) is chosen randomly
    height = random.randint(2, 7)
    sprite = random_sprite(3, height, symmetry="not_symmetric", color_palette=[color], density=0.4, connectivity=8)

    # place the smaller pattern, tiling it so that it is repeated vertically
    # tile "infinitely" (x100)
    vertically_repeated = np.tile(sprite, (1, 100))
    # crop to the size of the grid
    vertically_repeated = vertically_repeated[:, :grid.shape[1]]
    # copy to the grid
    grid[:,:] = vertically_repeated

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# attraction, magnetism, color change

# description:
# In the input you will see a grey rectangle and colored pixels scattered around it.
# To make the output, move each colored pixel toward the grey rectangle until it touches, then turn its color to gray. If multiple colored pixels collide, they stack.

def main(input_grid):
    # Plan:
    # 1. Detect the objects; separate the gray rectangle from the other pixels
    # 2. Move each colored pixel toward the gray rectangle until it touches
    # 3. Change its color once it touches

    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)

    grey_objects = [ obj for obj in objects if Color.GREY in object_colors(obj, background=Color.BLACK) ]
    other_objects = [ obj for obj in objects if Color.GREY not in object_colors(obj, background=Color.BLACK) ]

    assert len(grey_objects) == 1, "There should be exactly one grey object"
    
    grey_object = grey_objects[0]

    # Make the output grid: Start with the gray object, then add the colored pixels one-by-one
    output_grid = np.full_like(input_grid, Color.BLACK)
    blit_object(output_grid, grey_object)

    # Move the colored objects and change their color once they hit grey
    for colored_object in other_objects:
        # First calculate what direction we have to move in order to contact the grey object
        # Consider all displacements, starting with the smallest translations first
        possible_displacements = [ (i*dx, i*dy) for i in range(0, 30) for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)] ]

        # Only keep the displacements that cause a contact between the colored object and the grey object
        valid_displacements = [ displacement for displacement in possible_displacements
                                if contact(object1=translate(colored_object, *displacement), object2=grey_object) ]
        assert valid_displacements, "There should be at least one valid displacement"

        # Pick the smallest valid displacement
        displacement = min(valid_displacements, key=lambda displacement: sum(abs(x) for x in displacement))

        # Extract the direction from the displacement
        direction = np.sign(displacement, dtype=int)

        # Now move the colored object in that direction until there is a collision with something else
        if not all( delta == 0 for delta in direction ):
            while not collision(object1=translate(colored_object, *direction), object2=output_grid):
                colored_object = translate(colored_object, *direction)
        
        # Finally change the color of the colored object to grey anne draw it onto the outlet
        colored_object[colored_object != Color.BLACK] = Color.GREY
        blit_object(output_grid, colored_object)
    
    return output_grid

def generate_input():
    # Make a grid with a grey horizontal rectangle stretching all the way through the middle, and some scattered points around it
    # Then randomly rotate to get a variety of orientations

    width, height = np.random.randint(10, 25), np.random.randint(10, 25)
    grid = np.full((width, height), Color.BLACK)

    rectangle_y1 = np.random.randint(0, height//2)
    rectangle_y2 = np.random.randint(height//2, height)
    grid[:, rectangle_y1:rectangle_y2] = Color.GREY

    # scatter some colored pixels around the grey rectangle
    for _ in range(np.random.randint(5, 10)):
        random_color = random.choice([color for color in Color.NOT_BLACK if color != Color.GREY])
        pixel_sprite = np.full((1,1), random_color)
        x, y = random_free_location_for_sprite(grid, pixel_sprite, background=Color.BLACK)
        blit_sprite(grid, pixel_sprite, x, y, background=Color.BLACK)
    
    # random rotation
    grid = np.rot90(grid, np.random.randint(0, 4))

    return grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
