Here's an implementation for the new puzzle based on the description provided:

```python
from common import *

import numpy as np
from typing import *

# concepts:
# divider detection, grid slicing, connected components, sub-grid extraction

# description:
# Input is a grid potentially divided by uninterrupted full rows or columns of a single color (e.g., grey). 
# Identify these divider lines and use them to split the grid into contiguous sub-grids. 
# Each sub-grid is extracted as a separate region between dividers. 
# Discard any empty sub-grids. 
# The output is a list of these non-empty sub-grids, preserving their original order and content.

def main(input_grid: np.ndarray) -> List[np.ndarray]:
    # Identify the divider color, assumed to be the most frequent color in uninterrupted lines
    divider_color = None
    for color in Color.ALL_COLORS:
        if color == Color.BLACK:
            continue
        if any(np.all(input_grid[row, :] == color) for row in range(input_grid.shape[0])) or \
           any(np.all(input_grid[:, col] == color) for col in range(input_grid.shape[1])):
            divider_color = color
            break

    assert divider_color is not None, "No divider color found"

    # Find all horizontal and vertical divider lines
    horizontal_dividers = [y for y in range(input_grid.shape[0]) if np.all(input_grid[y, :] == divider_color)]
    vertical_dividers = [x for x in range(input_grid.shape[1]) if np.all(input_grid[:, x] == divider_color)]

    # Add edges as implicit dividers
    horizontal_dividers = [-1] + horizontal_dividers + [input_grid.shape[0]]
    vertical_dividers = [-1] + vertical_dividers + [input_grid.shape[1]]

    # Extract sub-grids based on dividers
    sub_grids = []
    for h in range(len(horizontal_dividers) - 1):
        for v in range(len(vertical_dividers) - 1):
            y1, y2 = horizontal_dividers[h] + 1, horizontal_dividers[h + 1]
            x1, x2 = vertical_dividers[v] + 1, vertical_dividers[v + 1]
            sub_grid = input_grid[y1:y2, x1:x2]
            
            # Ensure the sub-grid is not entirely empty
            if np.any(sub_grid != Color.BLACK):
                sub_grids.append(sub_grid)

    return sub_grids

def generate_input() -> np.ndarray:
    # Randomly generate grid size
    width, height = np.random.randint(15, 25), np.random.randint(15, 25)
    grid = np.full((height, width), Color.BLACK)

    # Randomly select a color for dividers
    divider_color = np.random.choice(Color.NOT_BLACK)

    # Determine number of horizontal and vertical dividers
    num_horizontal_dividers = np.random.randint(1, 4)
    num_vertical_dividers = np.random.randint(1, 4)

    # Generate divider positions ensuring no overlap and adequate spacing
    horizontal_positions = randomly_spaced_indices(height, num_horizontal_dividers, border_size=1, padding=2)
    vertical_positions = randomly_spaced_indices(width, num_vertical_dividers, border_size=1, padding=2)

    # Draw the dividers
    for y in horizontal_positions:
        grid[y, :] = divider_color
    for x in vertical_positions:
        grid[:, x] = divider_color

    # Fill sub-grids with randomly scattered colors
    for h in range(len(horizontal_positions) + 1):
        for v in range(len(vertical_positions) + 1):
            y1 = 0 if h == 0 else horizontal_positions[h-1] + 1
            y2 = horizontal_positions[h] if h < len(horizontal_positions) else height
            x1 = 0 if v == 0 else vertical_positions[v-1] + 1
            x2 = vertical_positions[v] if v < len(vertical_positions) else width

            if y2 - y1 > 1 and x2 - x1 > 1:  # Ensure the sub-grid is big enough to fill
                color = np.random.choice(Color.NOT_BLACK)
                randomly_scatter_points(grid[y1:y2, x1:x2], color=color, density=0.3)

    return grid
```

This implementation identifies full rows or columns of a consistent color as dividers and then extracts sub-grids based on these dividers while ensuring that empty sub-grids are discarded. The `generate_input` function stochastically creates different grids each time, with random divider placements and scattered colors.