Here is the implementation of the puzzle based on the description provided:

```python
from common import *

import numpy as np
from typing import *

# concepts:
# orientation detection, recolor, connected components, bounding box

# description:
# Input is a single connected object on a grid. Determine the object's orientation by identifying the missing corner in its bounding box (top-left, top-right, bottom-left, bottom-right).
# Recolor the entire object uniformly based on this orientation using a fixed color map: top-left to red (3), top-right to yellow (4), bottom-left to green (2), and bottom-right to blue (1).
# The background and any other grid content remain unchanged.

def main(input_grid):
    # Extract the connected object
    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)
    assert len(objects) == 1, "There should be exactly one connected object in the input grid."
    obj = objects[0]

    # Find the bounding box of the object
    x, y, width, height = bounding_box(obj, background=Color.BLACK)

    # Determine the missing corner
    corners = {
        "top-left": (x, y),
        "top-right": (x, y + width - 1),
        "bottom-left": (x + height - 1, y),
        "bottom-right": (x + height - 1, y + width - 1),
    }

    # Check for the presence of these corners in the object
    missing_corner = None
    for corner, (cx, cy) in corners.items():
        if (cx < obj.shape[0]) and (cy < obj.shape[1]) and obj[cx, cy] == Color.BLACK:
            missing_corner = corner
            break

    # Map the missing corner to its color
    color_map = {
        "top-left": Color.RED,
        "top-right": Color.YELLOW,
        "bottom-left": Color.GREEN,
        "bottom-right": Color.BLUE
    }

    # Recolor the object based on its missing corner
    color = color_map[missing_corner]
    obj[obj != Color.BLACK] = color

    # Create the output grid and blit the recolored object back
    output_grid = np.copy(input_grid)
    blit_object(output_grid, obj, background=Color.BLACK)

    return output_grid


def generate_input():
    # Create a grid and define the size
    n, m = np.random.randint(10, 15), np.random.randint(10, 15)
    grid = np.full((n, m), Color.BLACK, dtype=int)

    # Generate a random connected object
    obj = random_sprite(
        n=[3, 4, 5],
        m=[3, 4, 5],
        density=0.7,
        symmetry='not_symmetric',
        color_palette=[Color.GREY],
        connectivity=8
    )

    obj = crop(obj, background=Color.BLACK)

    # Randomly choose a corner to remove
    corners = {
        "top-left": (0, 0),
        "top-right": (0, obj.shape[1] - 1),
        "bottom-left": (obj.shape[0] - 1, 0),
        "bottom-right": (obj.shape[0] - 1, obj.shape[1] - 1),
    }
    corner_to_remove = np.random.choice(list(corners.keys()))
    cx, cy = corners[corner_to_remove]
    obj[cx, cy] = Color.BLACK

    # Place the object randomly in the grid
    x, y = random_free_location_for_sprite(grid, obj, padding=1, padding_connectivity=8)
    blit_sprite(grid, obj, x, y, background=Color.BLACK)

    return grid
```

### Explanation:

- **Concepts**: The puzzle involves detecting the orientation by finding which corner of the bounding box is missing, then recoloring the object based on predefined rules.
- **Main Function**: Extracts the single object, determines the missing corner, and recolors the object accordingly.
- **Generate Input**: Creates a random connected object in a grid, removes one corner to introduce orientation, and places it onto the grid. The output from `generate_input` will vary each time it's called, producing diverse inputs for the puzzle.