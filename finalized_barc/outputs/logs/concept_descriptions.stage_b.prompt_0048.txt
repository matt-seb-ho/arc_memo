You are a puzzle maker designing geometric, physical, and topological puzzles for curious middle-schoolers.

Each puzzle consists of uncovering a deterministic rule, pattern, procedure, algorithm, or transformation law that maps inputs to outputs.
Both the inputs and outputs are 2D grids of colored pixels. There are 10 colors, but the order of the colors is never relevant to the puzzle.

The middle schoolers are trying to discover this deterministic transformation, which can be implemented as a Python function called `main`.
Designing a puzzle involves also creating example inputs, which can be implemented as a Python function called `generate_input`. Unlike `main`, the `generate_input` function should be stochastic, so that every time you run it, you get another good example of what the transformation can be applied to.

Here is a overview of the puzzle you are designing:

Concepts: 
color runs, recolor, bounding box, symmetry

Description: 
Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down). Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion.

Please implement the puzzle by writing code containing the `generate_input` and `main` functions. Use the following standard library (`common.py`):

```python
def flood_fill(grid, x, y, color, connectivity=4):
    """
    Fill the connected region that contains the point (x, y) with the specified color.

    connectivity: 4 or 8, for 4-way or 8-way connectivity. 8-way counts diagonals as connected, 4-way only counts cardinal directions as connected.
    """

def find_connected_components(grid, background=Color.BLACK, connectivity=4, monochromatic=True):
    """
    Find the connected components in the grid. Returns a list of connected components, where each connected component is a numpy array.

    connectivity: 4 or 8, for 4-way or 8-way connectivity.
    monochromatic: if True, each connected component is assumed to have only one color. If False, each connected component can include multiple colors.
    """

def blit_sprite(grid, sprite, x, y, background=Color.BLACK):
    """
    Draws a sprite onto the grid at the specified location.

    Example usage:
    blit_sprite(output_grid, the_sprite, x=x, y=y, background=background_color)
    """

def bounding_box(grid, background=Color.BLACK):
    """
    Find the bounding box of the non-background pixels in the grid.
    Returns a tuple (x, y, width, height) of the bounding box.

    Example usage:
    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=8)
    teal_object = [ obj for obj in objects if np.any(obj == Color.TEAL) ][0]
    teal_x, teal_y, teal_w, teal_h = bounding_box(teal_object)
    """

def crop(grid, background=Color.BLACK):
    """
    Crop the grid to the smallest bounding box that contains all non-background pixels.

    Example usage:
    # Extract a sprite from an object
    sprite = crop(an_object, background=background_color)
    """

def random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=0, padding=0, padding_connectivity=8):
    """
    Find a random free location for the sprite in the grid
    Returns a tuple (x, y) of the top-left corner of the sprite in the grid, which can be passed to `blit_sprite`

    border_size: minimum distance from the edge of the grid
    background: color treated as transparent
    padding: if non-zero, the sprite will be padded with a non-background color before checking for collision
    padding_connectivity: 4 or 8, for 4-way or 8-way connectivity when padding the sprite

    Example usage:
    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8, border_size=1, background=Color.BLACK) # find the location, using generous padding
    assert not collision(object1=grid, object2=sprite, x2=x, y2=y)
    blit_sprite(grid, sprite, x, y)

    If no free location can be found, raises a ValueError.
    """

class Color:
    """
    Enum for colors

    Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON

    Use Color.ALL_COLORS for `set` of all possible colors
    Use Color.NOT_BLACK for `set` of all colors except black

    Colors are strings (NOT integers), so you CAN'T do math/arithmetic/indexing on them.
    (The exception is Color.BLACK, which is 0)
    """
```

Here are some examples from puzzles with similar descriptions to show you how to use functions in `common.py`:

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# Coloring diagonal pixels, repetition

# description:
# Given an input grid of arbitrary size, with some small number of colored pixels on it.
# To produce the output, replicate the input grid 4 times, 2 on the top and 2 on the bottom. 
# Color all the diagonal pixels adjacent to a colored pixel teal if the diagonal pixels are black. 

def main(input_grid):
   # Replicate input grid 4 times to initialize output grid
   output_grid = np.zeros((2*input_grid.shape[0], 2* input_grid.shape[1]),dtype=int)
   for i in range(2):
      for j in range(2):
         blit_sprite(output_grid, input_grid, i*input_grid.shape[0], j*input_grid.shape[1])
  
   # Create diagonal directions
   diagonal_dx_dy = [(1,1),(-1,1),(1,-1),(-1,-1)]

   # Color diagonal pixels 
   for y in range(output_grid.shape[1]):
      for x in range(output_grid.shape[0]):
         if output_grid[x,y] != Color.BLACK and output_grid[x,y] != Color.TEAL:
            for dx,dy in diagonal_dx_dy:
               # Color diagonal pixel teal if it is black
               if x+dx >= 0 and x+dx < output_grid.shape[0] and y+dy >= 0 and y+dy < output_grid.shape[1] and output_grid[x+dx,y+dy] == Color.BLACK:
                  output_grid[x+dx,y+dy] = Color.TEAL
  
   return output_grid

def generate_input():
    # Have 1 to 4 number of colored pixels in the initial square
    n_colored_pixels = random.randint(1,4)
    
    # Random pixel color that is not black or teal. 
    pixel_color = random.choice(list(Color.NOT_BLACK))
    while pixel_color == Color.TEAL:
        pixel_color = random.choice(list(Color.NOT_BLACK))

    # Random size of input grid
    n,m= random.randint(2,10), random.randint(2,10)

    # Initialize grid
    grid = np.zeros((n,m),dtype=int)
  
    # Create a dummy sprite with one pixel. 
    sprite = np.array([pixel_color]).reshape(1,1)
    
    # Randomly place n_colored_pixels pixels on the grid
    for i in range(n_colored_pixels):
      x,y = random_free_location_for_sprite(grid,sprite)
      blit_sprite(grid, sprite, x,y)

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# objects, flood fill, connectivity

# description:
# In the input, you will see a black grid with a red line that starts in the top left corner and bounces off the borders of the grid until it reaches the right side of the grid.
# To make the output, find the black regions separated by the red lines, then, starting with the first region from the left, color every third region yellow.

def main(input_grid):
    # copy the input grid to the output grid
    output_grid = np.copy(input_grid)

    # find the black regions in the input grid
    black_regions = find_connected_components(input_grid, connectivity=4, background=Color.RED)

    # sort the regions from left to right using the coordinates of their bounding boxes
    black_regions = sorted(black_regions, key=lambda region: bounding_box(region, background=Color.RED)[0])

    # color every third black region yellow using flood fill
    for i, region in enumerate(black_regions):
        if i % 3 == 0:
            x, y = np.where(region == Color.BLACK)
            flood_fill(output_grid, x[0], y[0], Color.YELLOW)

    return output_grid



def generate_input():
    # make a black grid that is 3 cells tall and between 10 and 20 cells wide
    grid = np.zeros((np.random.randint(10,20), 3), dtype=int)

    # make a red line that starts in the top left corner and bounces off the borders of the grid until it reaches the right side of the grid
    x, y = 0, 0
    dx, dy = 1, 1
    # go until we reach the right side of the grid
    while x < grid.shape[0]:
        # make the current cell red
        grid[x, y] = Color.RED
        # if we are at the top or bottom of the grid, bounce off the top or bottom border
        if y + dy >= grid.shape[1]:
            dy = -1
        elif y + dy < 0:
            dy = 1
        x += dx
        y += dy

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# rectangular cells, color guide

# description:
# In the input you will see grey horizontal and vertical bars that divide the grid into nine 3x3 rectangular regions, each of which contains 4-5 colored pixels
# To make the output, find the region that has exactly 4 colored pixels, and use its colors as a guide to fill in all the other cells

def main(input_grid: np.ndarray) -> np.ndarray:

    # First identify 

    # Trick for decomposing inputs divided into rectangular regions by horizontal/vertical bars:
    # Treat the bar color as the background, and break the input up into connected components with that background color

    # The divider color is the color of the horizontal and vertical bars
    divider_colors = [ input_grid[x,y] for x in range(input_grid.shape[0]) for y in range(input_grid.shape[1])
                     if np.all(input_grid[x,:] == input_grid[x,0]) or np.all(input_grid[:,y] == input_grid[0,y]) ]
    assert len(set(divider_colors)) == 1, "There should be exactly one divider color"
    divider_color = divider_colors[0] # background=divider_color

    # Find multicolored regions, which are divided by divider_color, so we treat that as background, because it separates objects
    # Within each region there can be multiple colors
    regions = find_connected_components(input_grid, background=divider_color, monochromatic=False)
    # Tag the regions with their location within the 2D grid of (divided) regions
    # First get the bounding-box locations...
    locations = []
    for region in regions:
        x, y, w, h = bounding_box(region, background=divider_color)
        locations.append((x, y, region))
    # ...then re-index them so that (x, y) is the coordinate within the grid of rectangular regions
    grid_of_regions = []
    for x, y, region in locations:
        num_left_of_region = len({other_x for other_x, other_y, other_region in locations if other_x < x})
        num_above_region = len({other_y for other_x, other_y, other_region in locations if other_y < y})
        grid_of_regions.append((num_left_of_region, num_above_region, region))

    # Find the region with exactly 4 colors
    special_region = None
    for region in regions:
        not_divider_and_not_black = (region != divider_color) & (region != Color.BLACK)
        if np.sum(not_divider_and_not_black) == 4:
            assert special_region is None, "More than one special region found"
            special_region = region
    
    # Convert to a sprite
    special_sprite = crop(special_region, background=divider_color)
    
    # Create the output grid
    output_grid = np.zeros_like(input_grid)

    # Put the dividers back in
    output_grid[input_grid == divider_color] = divider_color

    # Fill in the cells with the special colors
    for x, y, region in grid_of_regions:
        output_grid[region != divider_color] = special_sprite[x, y]

    return output_grid



def generate_input() -> np.ndarray:
    
    divider_color = Color.GRAY

    # make the dividers, which comprise horizontal/vertical bars creating 3x3 cells, with 3 cells in each direction
    cell_size = 3
    n_cells = 3
    divider_size = 1 # the divider is a single pixel
    n_dividers = n_cells - 1
    distance_between_cells = cell_size + divider_size
    m = cell_size*n_cells + divider_size*n_dividers
    grid = np.full((m, m), Color.BLACK)
    for i in range(n_dividers):
        # horizontal dividers
        grid[cell_size + i*(cell_size + divider_size), :] = divider_color
        # vertical dividers
        grid[:, cell_size + i*(cell_size + divider_size)] = divider_color
    
    # pick one of the cells to have exactly 4 colors (the others will have 5)
    special_cell_x, special_cell_y = np.random.randint(3), np.random.randint(3)

    for x in range(3):
        for y in range(3):
            if x == special_cell_x and y == special_cell_y:
                n_colors = 4
            else:
                n_colors = 5

            # extract view of the cell
            # each of the cells is 3x3, but there is a divider in between them, so they are actually 4x4 apart
            cell = grid[x*distance_between_cells : x*distance_between_cells + cell_size,
                        y*distance_between_cells : y*distance_between_cells + cell_size]

            # color the cell by picking random positions and random colors until we have enough colored pixels
            while np.sum(cell!=Color.BLACK) < n_colors:
                # pick a random spot to color
                cell_x, cell_y = np.random.randint(cell_size), np.random.randint(cell_size)
                cell[cell_x, cell_y] = random.choice([color for color in Color.ALL_COLORS if color != Color.BLACK and color != divider_color])

    return grid
```

Example puzzle code:
```python
from common import *

import numpy as np
from typing import *

# concepts:
# bitmasks with separator, boolean logical operations

# description:
# Compute the XOR operation of where the two grids are red, turning the output green in those locations.
# In the input, you should see two 6x5 red patterns on top and bottom separated a horizontal yellow line in the middle of the grid.
# To make the output, you have to overlap the two patterns. If the overlapping cells are the same color, then the corresponding cell is colored black; otherwise, 
# if the overlapping cells are not the same color, then the corresponding cell is colored green

def main(input_grid):

    width, height = input_grid.shape
   
    # Find the yellow horizontal line/bar
    for y_bar in range(height):
        if np.all(input_grid[:, y_bar] == Color.YELLOW):
            break
    
    # extract left and right patterns
    left_pattern = input_grid[:, :y_bar]
    right_pattern = input_grid[:, y_bar+1:] 

    output_grid = np.zeros_like(left_pattern)

    # applying the XOR pattern, which is where they are different
    output_grid[(left_pattern!=right_pattern)] = Color.GREEN
    output_grid[(left_pattern==right_pattern)] = Color.BLACK

    return output_grid


def generate_input():
  
    # Define the grid size
    width = 5  
    height = 13 # 6 top + 1 yellow line + 6 bottom

    # Initialize an empty grid
    input_grid = np.full((width, height), Color.BLACK)

    # Randomly assign red or black to the top and bottom patterns
    for x in range(width):
        for y in range(height):
            input_grid[x, y] = np.random.choice([Color.BLACK, Color.RED])

    # Set the yellow vertical line
    input_grid[:, int(height//2)] = Color.YELLOW

    return input_grid
```

Your task is to implement the puzzle, following these steps:

1. Inspect the example puzzle implementations, making note of the functions used and the physical/geometric/topological/logical details
2. Inspect the new puzzle's description
3. Brainstorm a possible implementation for the new puzzle
4. Generate a code block formatted like the earlier examples with a comment starting `# concepts:` listing the concepts and `# description:` describing the inputs and transformation from the given description.

Be sure to make the transformation `main` deterministic. Follow the description closely.
