Below is a new puzzle implementation based on the provided description. This puzzle involves detecting full-length separators in a grid and partitioning it into sub-grids:

```python
from common import *

import numpy as np
from typing import *

# concepts:
# grid partitioning, separator detection, slicing

# description:
# The input grid contains full-length separator rows or columns of a single color that divide the grid into distinct regions.
# Identify these separators and use them to partition the grid into contiguous sub-grids. Each sub-grid is formed by slicing the input grid
# between consecutive separators, excluding the separators themselves. The output is a list of these sub-grids, preserving their original order and content.

def main(input_grid: np.ndarray) -> List[np.ndarray]:
    # Find the color used for separation
    separator_color = None
    # Assume the first complete row or column of identical color is the separator
    for i in range(input_grid.shape[0]):
        if np.all(input_grid[i, :] == input_grid[i, 0]):
            separator_color = input_grid[i, 0]
            break
    if separator_color is None:
        for j in range(input_grid.shape[1]):
            if np.all(input_grid[:, j] == input_grid[0, j]):
                separator_color = input_grid[0, j]
                break
    
    assert separator_color is not None, "No separator color found"

    # Identify separator indices
    separator_rows = [i for i in range(input_grid.shape[0]) if np.all(input_grid[i, :] == separator_color)]
    separator_cols = [j for j in range(input_grid.shape[1]) if np.all(input_grid[:, j] == separator_color)]

    # Initialize sub-grids list
    sub_grids = []

    # Create sub-grids by slicing between separators
    last_row_index = 0
    for row_index in separator_rows + [input_grid.shape[0]]:
        last_col_index = 0
        for col_index in separator_cols + [input_grid.shape[1]]:
            sub_grid = input_grid[last_row_index:row_index, last_col_index:col_index]
            if sub_grid.size > 0:
                sub_grids.append(sub_grid)
            last_col_index = col_index + 1
        last_row_index = row_index + 1

    return sub_grids

def generate_input() -> np.ndarray:
    # Randomly generate the grid size
    width, height = np.random.randint(10, 20), np.random.randint(10, 20)
    grid = np.full((width, height), Color.BLACK)

    # Randomly select the number of separators
    num_h_separators = np.random.randint(1, 3)
    num_v_separators = np.random.randint(1, 3)

    # Randomly determine separator positions
    h_separators = randomly_spaced_indices(width, num_h_separators, border_size=1, padding=1)
    v_separators = randomly_spaced_indices(height, num_v_separators, border_size=1, padding=1)

    # Choose a separator color
    separator_color = np.random.choice(Color.NOT_BLACK)

    # Draw the horizontal separators
    for x in h_separators:
        grid[x, :] = separator_color

    # Draw the vertical separators
    for y in v_separators:
        grid[:, y] = separator_color

    # Fill the sub-grids with random colors
    for i in range(len(h_separators) + 1):
        for j in range(len(v_separators) + 1):
            x_start = 0 if i == 0 else h_separators[i - 1] + 1
            x_end = h_separators[i] if i < len(h_separators) else width
            y_start = 0 if j == 0 else v_separators[j - 1] + 1
            y_end = v_separators[j] if j < len(v_separators) else height

            color = np.random.choice(Color.NOT_BLACK - {separator_color})
            grid[x_start:x_end, y_start:y_end] = color

    return grid
```

This puzzle requires students to detect separator lines in the grid and partition it into sub-grids based on those separators. The function `generate_input` creates a grid with randomly placed separators, and `main` performs the task of slicing the grid into sub-grids.