{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood fill, background detection\n\n# description:\n# The input grid contains a guide object formed by a closed shape (e.g., a rectangle or circle) and a background color. \n# The task is to identify holes, which are regions of the background color that are completely enclosed by the guide object and do not touch any grid borders.\n# Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole.\n# The output should be the input grid, but with these holes filled with the color of the guide object.\n\ndef main(input_grid):\n    # Make a copy of the grid to avoid modifying the input directly\n    output_grid = input_grid.copy()\n\n    # Identify the background color as the most frequent color in the grid\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    \n    # Identify the guide object's color by finding the most frequent non-background color\n    guide_color = max(Color.NOT_BLACK, key=lambda x: np.count_nonzero(input_grid == x))\n\n    # Flood-fill from the border to mark the exterior background\n    border_mask = np.full(input_grid.shape, False)\n    border_mask[0, :] = border_mask[-1, :] = border_mask[:, 0] = border_mask[:, -1] = True\n    flood_fill(input_grid, border_mask, background_color)\n\n    # Find the regions that are still background color; these are potential holes\n    potential_holes = (input_grid == background_color)\n\n    # Fill these holes with the guide object's color\n    output_grid[potential_holes] = guide_color\n\n    return output_grid\n\ndef flood_fill(grid, mask, target_color):\n    \"\"\"\n    Perform flood-fill from the border using a queue-based implementation.\n    This will mark all connected components of the target_color that are connected to the border.\n    \"\"\"\n    q = list(zip(*np.where(mask & (grid == target_color))))\n    while q:\n        x, y = q.pop(0)\n        grid[x, y] = -1  # Mark as visited with a temporary color\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < grid.shape[0] and 0 <= ny < grid.shape[1] and grid[nx, ny] == target_color:\n                q.append((nx, ny))\n\ndef generate_input():\n    # Create a grid of random size between 15x15 and 25x25 with a black background\n    n = np.random.randint(15, 26)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate a random guide object (e.g., a rectangle) with a random non-black color\n    guide_color = np.random.choice(list(Color.NOT_BLACK))\n    rect_height = np.random.randint(5, n-4)\n    rect_width = np.random.randint(5, n-4)\n    rect_x = np.random.randint(1, n-rect_height-1)\n    rect_y = np.random.randint(1, n-rect_width-1)\n    \n    grid[rect_x:rect_x+rect_height, rect_y:rect_y+rect_width] = guide_color\n    grid[rect_x+1:rect_x+rect_height-1, rect_y+1:rect_y+rect_width-1] = Color.BLACK\n\n    # Introduce random holes within the guide object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_height = np.random.randint(1, rect_height-2)\n        hole_width = np.random.randint(1, rect_width-2)\n        hole_x = np.random.randint(rect_x+1, rect_x+rect_height-hole_height-1)\n        hole_y = np.random.randint(rect_y+1, rect_y+rect_width-hole_width-1)\n        grid[hole_x:hole_x+hole_height, hole_y:hole_y+hole_width] = Color.BLACK\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["810b9b61.py", "44d8ac46.py", "00d62c1b.py", "264363fd_Kevin.py", "Concepts: \nholes, enclosed regions, flood fill, background detection\n\nDescription: \nIdentify holes as background-color regions fully enclosed by a guide object, not connected to the grid border. Use flood-fill from the grid border to mark exterior background; any remaining background component inside the object is a hole. Fill these holes with the target object color, ensuring they are completely enclosed by the guide object."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# Given a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels using a specified color.\n# The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color. The rest of the grid remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Get start and end positions\n    start_pos = np.argwhere((input_grid != Color.BLACK) & (input_grid != Color.RED))\n    start_x, start_y = start_pos[0]\n\n    end_pos = np.argwhere(input_grid == Color.RED)\n    end_x, end_y = end_pos[0]\n\n    # Determine the color for the line\n    line_color = input_grid[start_x, start_y]\n\n    # Draw a line from start to end using Bresenham's line algorithm\n    def bresenham(x0, y0, x1, y1):\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n        err = dx - dy\n\n        while True:\n            output_grid[x0, y0] = line_color\n            if x0 == x1 and y0 == y1:\n                break\n            e2 = 2 * err\n            if e2 > -dy:\n                err -= dy\n                x0 += sx\n            if e2 < dx:\n                err += dx\n                y0 += sy\n\n    # Draw the line\n    bresenham(start_x, start_y, end_x, end_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random color for the line\n    line_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly place the start pixel\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[start_x, start_y] = line_color\n\n    # Randomly place the end pixel (red) ensuring it's not the same as the start\n    end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    while end_x == start_x and end_y == start_y:\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[end_x, end_y] = Color.RED\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["23581191.py", "6cdd2623.py", "834ec97d.py", "2dd70a9a.py", "Concepts: \nline drawing, pixel connectivity, grid update\n\nDescription: \nGiven a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels using a specified color. The line is drawn using pixel connectivity, updating the grid by coloring each pixel along the path with the given color. The rest of the grid remains unchanged."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line finding, detours\n\n# description:\n# In the input, you will see a grid with a start point marked in green, an endpoint marked in red, and several obstacles marked in blue.\n# The task is to connect the start point to the endpoint with a continuous line that avoids the obstacles.\n# The line should be drawn in yellow. If an obstacle is encountered, the path should take a detour around it.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Parse the input to find the start point, endpoint, and obstacles\n    # 2. Use a pathfinding algorithm like A* to navigate from start to end, avoiding obstacles\n    # 3. Draw the path on the grid using yellow color\n\n    # 1. Parse the input\n    background = Color.BLACK\n    start_position = np.argwhere(input_grid == Color.GREEN)[0]\n    end_position = np.argwhere(input_grid == Color.RED)[0]\n    obstacles = (input_grid == Color.BLUE)\n\n    # 2. Implement A* pathfinding algorithm\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def astar(start, goal, obstacles):\n        from heapq import heappop, heappush\n        open_set = []\n        heappush(open_set, (0, start))\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: heuristic(start, goal)}\n\n        while open_set:\n            _, current = heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                path.reverse()\n                return path\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # 4 directions\n                neighbor = (current[0] + dx, current[1] + dy)\n                if 0 <= neighbor[0] < input_grid.shape[0] and 0 <= neighbor[1] < input_grid.shape[1]:\n                    if obstacles[neighbor]:\n                        continue\n                    tentative_g_score = g_score[current] + 1\n                    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                        came_from[neighbor] = current\n                        g_score[neighbor] = tentative_g_score\n                        f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                        heappush(open_set, (f_score[neighbor], neighbor))\n        return []\n\n    # 3. Draw the path\n    path = astar(tuple(start_position), tuple(end_position), obstacles)\n    output_grid = input_grid.copy()\n    for x, y in path:\n        if output_grid[x, y] not in [Color.GREEN, Color.RED]:\n            output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a start point, endpoint, and several obstacles\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Place start point\n    start_x, start_y = np.random.randint(0, n, size=2)\n    grid[start_x, start_y] = Color.GREEN\n\n    # Place endpoint at a different location\n    end_x, end_y = start_x, start_y\n    while end_x == start_x and end_y == start_y:\n        end_x, end_y = np.random.randint(0, n, size=2)\n    grid[end_x, end_y] = Color.RED\n\n    # Place obstacles\n    num_obstacles = np.random.randint(n // 2, n)\n    for _ in range(num_obstacles):\n        obs_x, obs_y = np.random.randint(0, n, size=2)\n        if grid[obs_x, obs_y] == Color.BLACK:\n            grid[obs_x, obs_y] = Color.BLUE\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 2, 4, 4, 4, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 4, 4, 4, 3, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]]], [[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 4, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 4, 3], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["2dd70a9a.py", "2c608aff.py", "6aa20dc0.py", "e8dc4411.py", "Concepts: \nobstacles, path blocking, line drawing, detours\n\nDescription: \nIdentify any non-background pixels (obstacles) that lie along a planned line or replication path. These obstacles block the direct path and require handling such as detours, bypassing, or recoloring. The transformation involves navigating around these obstacles to complete the path without overwriting them, ensuring the line or replication reaches its intended destination while preserving existing objects."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# guide object, mirroring, position-based transformation\n\n# description:\n# In the input, you will find a grid containing a single teal pixel, which serves as the guide object.\n# The task is to reflect the entire grid around the teal pixel's position, creating a mirrored version of the grid.\n# The output should be a mirrored grid, with the teal pixel's position acting as the axis of reflection.\n\ndef main(input_grid):\n    # Find the position of the guide object (teal pixel)\n    teal_x, teal_y = np.argwhere(input_grid == Color.TEAL)[0]\n\n    # Create the output grid by mirroring the input grid around the teal pixel's position\n    output_grid = input_grid.copy()\n    n, m = input_grid.shape\n\n    # Reflect horizontally around the teal pixel\n    for i in range(n):\n        for j in range(m):\n            # Calculate the mirrored position\n            mirrored_x = 2 * teal_x - i\n            mirrored_y = 2 * teal_y - j\n\n            # Check if the mirrored position is within bounds\n            if 0 <= mirrored_x < n and 0 <= mirrored_y < m:\n                output_grid[mirrored_x, mirrored_y] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size with random colored pixels\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))\n\n    # Place a single teal pixel within the grid as the guide object\n    teal_x, teal_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[teal_x, teal_y] = Color.TEAL\n\n    return grid", "examples": [[[[6, 9, 8, 5, 6, 7, 9, 3], [3, 7, 7, 9, 7, 5, 7, 1], [6, 5, 8, 7, 4, 8, 2, 7], [7, 3, 7, 1, 8, 3, 3, 8], [8, 4, 5, 9, 8, 9, 7, 4], [4, 3, 7, 8, 5, 6, 6, 8], [5, 9, 1, 8, 8, 4, 4, 5], [4, 6, 1, 3, 8, 9, 8, 1]], [[6, 5, 8, 9, 6, 7, 9, 3], [3, 7, 7, 9, 7, 5, 7, 1], [6, 5, 8, 7, 4, 8, 2, 7], [7, 3, 7, 1, 8, 3, 3, 8], [8, 4, 5, 9, 8, 9, 7, 4], [4, 3, 7, 8, 5, 6, 6, 8], [5, 9, 1, 8, 8, 4, 4, 5], [4, 6, 1, 3, 8, 9, 8, 1]]], [[[4, 1, 2, 3, 6, 1, 5], [2, 7, 9, 1, 8, 8, 5], [9, 9, 8, 8, 9, 6, 7], [1, 7, 9, 6, 3, 3, 4], [4, 7, 4, 1, 8, 8, 6], [7, 1, 3, 2, 6, 1, 8], [2, 8, 5, 6, 5, 4, 8]], [[4, 1, 7, 6, 9, 8, 8], [2, 7, 5, 8, 8, 1, 9], [9, 9, 5, 1, 6, 3, 2], [1, 7, 9, 6, 3, 3, 4], [4, 7, 4, 1, 8, 8, 6], [7, 1, 3, 2, 6, 1, 8], [2, 8, 5, 6, 5, 4, 8]]], [[[9, 4, 4, 2, 3, 1, 7, 8, 6], [7, 5, 6, 1, 8, 4, 7, 3, 8], [1, 1, 9, 3, 7, 5, 2, 4, 6], [8, 7, 5, 6, 8, 9, 4, 9, 6], [1, 5, 3, 5, 1, 1, 8, 7, 8], [2, 9, 3, 1, 3, 4, 3, 1, 4], [4, 1, 8, 4, 9, 9, 6, 8, 1]], [[9, 4, 4, 2, 3, 1, 6, 8, 7], [7, 5, 6, 1, 8, 4, 7, 3, 8], [1, 1, 9, 3, 7, 5, 2, 4, 6], [8, 7, 5, 6, 8, 9, 4, 9, 6], [1, 5, 3, 5, 1, 1, 8, 7, 8], [2, 9, 3, 1, 3, 4, 3, 1, 4], [4, 1, 8, 4, 9, 9, 6, 8, 1]]], [[[6, 5, 3, 6, 9, 5, 9, 1, 6], [5, 6, 5, 6, 9, 9, 7, 6, 6], [6, 8, 9, 4, 1, 7, 7, 6, 5], [1, 2, 6, 9, 2, 8, 7, 1, 7], [4, 8, 3, 5, 7, 2, 6, 3, 8], [9, 7, 8, 8, 4, 1, 3, 2, 8], [8, 9, 7, 9, 4, 1, 6, 1, 4], [5, 5, 2, 8, 1, 2, 4, 7, 1], [5, 8, 7, 3, 8, 3, 6, 2, 4]], [[3, 8, 4, 6, 9, 5, 9, 1, 6], [6, 2, 1, 6, 9, 9, 7, 6, 6], [9, 8, 6, 4, 1, 7, 7, 6, 5], [5, 6, 5, 9, 2, 8, 7, 1, 7], [3, 5, 6, 5, 7, 2, 6, 3, 8], [9, 7, 8, 8, 4, 1, 3, 2, 8], [8, 9, 7, 9, 4, 1, 6, 1, 4], [5, 5, 2, 8, 1, 2, 4, 7, 1], [5, 8, 7, 3, 8, 3, 6, 2, 4]]], [[[4, 5, 8, 1, 3, 8, 8, 2, 6], [2, 5, 7, 6, 3, 6, 8, 5, 3], [6, 5, 8, 3, 8, 5, 7, 8, 8], [8, 1, 4, 1, 6, 3, 5, 5, 6], [9, 4, 4, 5, 2, 6, 5, 1, 4], [3, 4, 1, 1, 1, 3, 1, 2, 3], [5, 3, 9, 6, 4, 6, 6, 2, 9], [5, 7, 6, 9, 1, 7, 6, 2, 8]], [[3, 1, 8, 5, 4, 8, 8, 2, 6], [2, 5, 7, 6, 3, 6, 8, 5, 3], [6, 5, 8, 3, 8, 5, 7, 8, 8], [8, 1, 4, 1, 6, 3, 5, 5, 6], [9, 4, 4, 5, 2, 6, 5, 1, 4], [3, 4, 1, 1, 1, 3, 1, 2, 3], [5, 3, 9, 6, 4, 6, 6, 2, 9], [5, 7, 6, 9, 1, 7, 6, 2, 8]]]], "seeds": ["a8c38be5.py", "137eaa0f.py", "aedd82e4.py", "48d8fb45.py", "Concepts: \nguide object, starting point, position-based transformation\n\nDescription: \nIdentify a guide object within the grid, characterized by a unique color or distinct feature. Use the position of this guide object as a starting point for a transformation or operation. The specific transformation depends on the task context but consistently originates from the guide object's location. The rest of the grid is processed based on this positional reference, ensuring a deterministic output transformation."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, connected components\n\n# description:\n# The input grid contains a single object that can enclose empty spaces (holes). \n# The task is to identify holes, which are regions of background-color (0) that are fully enclosed by the object and not touching the grid border. \n# Use flood-fill from the border to exclude non-enclosed regions. \n# The output is the grid where the holes are marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions.\n\ndef main(input_grid):\n    # Create a copy of the input grid to use as the output grid\n    output_grid = input_grid.copy()\n\n    # Use flood-fill from the border to mark all regions connected to the border\n    border_filled = flood_fill_from_border(input_grid)\n\n    # Find the holes by identifying regions that are not part of the border-flooded area and are background\n    holes = (input_grid == Color.BLACK) & ~border_filled\n\n    # Fill the holes with a target color, e.g., Color.RED\n    output_grid[holes] = Color.RED\n\n    return output_grid\n\ndef flood_fill_from_border(grid):\n    # Initialize a mask for the border-flooded areas\n    # Start with a mask of False (background)\n    border_filled = np.zeros(grid.shape, dtype=bool)\n\n    # Flood-fill from each edge of the grid\n    for x in range(grid.shape[0]):\n        flood_fill(grid, border_filled, x, 0)\n        flood_fill(grid, border_filled, x, grid.shape[1] - 1)\n\n    for y in range(grid.shape[1]):\n        flood_fill(grid, border_filled, 0, y)\n        flood_fill(grid, border_filled, grid.shape[0] - 1, y)\n\n    return border_filled\n\ndef flood_fill(grid, mask, x, y):\n    # If the pixel is out of bounds or already filled or not background, return\n    if not (0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]):\n        return\n    if mask[x, y] or grid[x, y] != Color.BLACK:\n        return\n\n    # Mark the current pixel as filled\n    mask[x, y] = True\n\n    # Recurse in all 4 directions (up, down, left, right)\n    flood_fill(grid, mask, x + 1, y)\n    flood_fill(grid, mask, x - 1, y)\n    flood_fill(grid, mask, x, y + 1)\n    flood_fill(grid, mask, x, y - 1)\n\ndef generate_input():\n    # Create a grid of size 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate a single large object with potential holes\n    object_height = np.random.randint(5, n - 3)\n    object_width = np.random.randint(5, n - 3)\n    object_x = np.random.randint(1, n - object_height - 1)\n    object_y = np.random.randint(1, n - object_width - 1)\n\n    object_grid = np.full((object_height, object_width), np.random.choice(Color.NOT_BLACK))\n    grid[object_x:object_x + object_height, object_y:object_y + object_width] = object_grid\n\n    # Create random enclosed holes within the object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_height = np.random.randint(1, object_height - 2)\n        hole_width = np.random.randint(1, object_width - 2)\n        hole_x = np.random.randint(object_x + 1, object_x + object_height - hole_height - 1)\n        hole_y = np.random.randint(object_y + 1, object_y + object_width - hole_width - 1)\n        grid[hole_x:hole_x + hole_height, hole_y:hole_y + hole_width] = Color.BLACK\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 0, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 2, 2, 2, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 2, 2, 2, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 2, 2, 2, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 2, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0], [0, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 2, 2, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 2, 2, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 2, 2, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 2, 2, 2, 2, 2, 2, 5, 5, 5, 0, 0, 0], [0, 5, 2, 2, 2, 2, 2, 2, 5, 5, 5, 0, 0, 0], [0, 5, 2, 2, 2, 2, 2, 2, 5, 5, 5, 0, 0, 0], [0, 5, 2, 2, 2, 2, 2, 2, 5, 5, 5, 0, 0, 0], [0, 5, 5, 2, 2, 2, 2, 2, 5, 5, 5, 0, 0, 0], [0, 5, 5, 2, 2, 2, 2, 2, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 2, 2, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 2, 2, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 2, 2, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 2, 2, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 2, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 2, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["44d8ac46.py", "810b9b61.py", "00d62c1b.py", "e73095fd.py", "Concepts: \nholes, enclosed regions, flood-fill, connected components\n\nDescription: \nInput consists of a grid with a single object enclosing empty spaces (holes). Identify holes as background-color (0) regions fully enclosed by the object, not touching the grid border. Use flood-fill from the border to exclude non-enclosed regions. Output the grid with holes marked or filled by a target object or color, while preserving the enclosing object and other non-hole regions."]}
{"source": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, enclosed regions, flood-fill, background components\n\n# description:\n# Input consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border.\n# Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes with a distinct color, such as blue.\n\ndef main(input_grid):\n    # Create an initial copy of the input grid to store the result\n    output_grid = input_grid.copy()\n\n    # Find the boundary of the grid\n    n, m = input_grid.shape\n\n    # Use flood-fill to mark connected components from the border\n    border_connected = np.zeros((n, m), dtype=bool)\n\n    def flood_fill(x, y):\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return\n        if input_grid[x, y] != 0 or border_connected[x, y]:\n            return\n        border_connected[x, y] = True\n        flood_fill(x + 1, y)\n        flood_fill(x - 1, y)\n        flood_fill(x, y + 1)\n        flood_fill(x, y - 1)\n\n    # Apply flood fill from the border\n    for i in range(n):\n        flood_fill(i, 0)\n        flood_fill(i, m - 1)\n    for j in range(m):\n        flood_fill(0, j)\n        flood_fill(n - 1, j)\n\n    # Highlight the enclosed holes\n    for x in range(n):\n        for y in range(m):\n            if input_grid[x, y] == 0 and not border_connected[x, y]:\n                output_grid[x, y] = Color.BLUE  # Highlight enclosed holes\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a single object\n    n, m = np.random.randint(12, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random object\n    obj_n, obj_m = np.random.randint(6, min(n, m) - 2, size=2)\n    obj_x, obj_y = np.random.randint(1, n - obj_n), np.random.randint(1, m - obj_m)\n\n    grid[obj_x:obj_x + obj_n, obj_y:obj_y + obj_m] = Color.RED\n\n    # Add random holes within the object\n    num_holes = np.random.randint(1, 4)\n    for _ in range(num_holes):\n        hole_n, hole_m = np.random.randint(2, min(obj_n, obj_m) // 2, size=2)\n        hole_x, hole_y = np.random.randint(obj_x + 1, obj_x + obj_n - hole_n), np.random.randint(obj_y + 1, obj_y + obj_m - hole_m)\n        grid[hole_x:hole_x + hole_n, hole_y:hole_y + hole_m] = Color.BLACK\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 2, 2, 0, 0, 2, 2, 2, 0, 0, 0, 2, 0, 0], [0, 0, 2, 2, 0, 0, 2, 2, 2, 0, 0, 0, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0], [0, 0, 2, 2, 1, 1, 2, 2, 2, 1, 1, 1, 2, 0, 0], [0, 0, 2, 2, 1, 1, 2, 2, 2, 1, 1, 1, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 1, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 1, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 1, 1, 1, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 1, 1, 1, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["44d8ac46.py", "810b9b61.py", "e73095fd.py", "00d62c1b.py", "Concepts: \nholes, enclosed regions, flood-fill, background components\n\nDescription: \nInput consists of a grid with a single object and background (0). Identify holes as fully enclosed 0-regions within the object that are not connected to the grid border. Use flood-fill from the border to detect and exclude non-enclosed regions. The output grid highlights these enclosed holes, typically for further processing or filling."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, pixel connectivity, grid update\n\n# description:\n# In the input, you will see a grid with two distinct pixels marked as start and end with specific colors.\n# To make the output, draw a straight line connecting these two pixels using Bresenham's line algorithm.\n# Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the start and end points by their unique colors\n    start_color = Color.RED\n    end_color = Color.BLUE\n    line_color = Color.GREEN  # The color of the line to be drawn\n\n    # Find the position of the start and end pixels\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    end_pos = np.argwhere(input_grid == end_color)[0]\n\n    # Extract the coordinates\n    x_start, y_start = start_pos\n    x_end, y_end = end_pos\n\n    # Draw the line using Bresenham's line algorithm\n    draw_line(output_grid, x_start, y_start, end_x=x_end, end_y=y_end, color=line_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two distinct random colors for start and end\n    start_color = Color.RED\n    end_color = Color.BLUE\n\n    # Randomly select two distinct positions on the grid for start and end\n    x_start, y_start = np.random.randint(0, n), np.random.randint(0, m)\n    x_end, y_end = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Ensure the start and end points are distinct\n    while (x_start == x_end and y_start == y_end):\n        x_end, y_end = np.random.randint(0, n), np.random.randint(0, m)\n\n    # Set the start and end colors on the grid\n    grid[x_start, y_start] = start_color\n    grid[x_end, y_end] = end_color\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["23581191.py", "2dd70a9a.py", "b527c5c6.py", "834ec97d.py", "Concepts: \nline drawing, pixel connectivity, grid update\n\nDescription: \nGiven a grid with two distinct pixels marked as start and end, draw a straight line connecting these two pixels. Use Bresenham's line algorithm to determine the path of the line. Update the grid by coloring each pixel along the path with a specified line color. All other pixels in the grid remain unchanged."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacle navigation, fixed direction turn, pathfinding\n\n# description:\n# Input is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered.\n# When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear. \n# Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, always turning the same way as specified.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the starting point and the initial direction.\n    # 2. Traverse the path while checking for obstacles.\n    # 3. When an obstacle is encountered, turn in the specified direction ('left' or 'right').\n    # 4. Continue moving in the new direction until the path is clear.\n    # 5. Return to the original direction and continue traversal.\n    # 6. Mark the traversed path on the output grid.\n\n    # Colors in the grid\n    path_color = Color.YELLOW\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n    direction_color = Color.BLUE\n\n    # Copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the start position and initial direction\n    start_pos = np.argwhere(input_grid == start_color)[0]\n    direction_pos = np.argwhere(input_grid == direction_color)[0]\n\n    # Calculate the initial direction vector\n    direction = (direction_pos - start_pos).flatten()\n    direction = tuple(direction)\n\n    # Set the turn direction\n    turn_direction = 'right'  # or 'left'\n\n    # Function to turn left or right\n    def turn(current_direction, turn_direction):\n        if turn_direction == 'right':\n            return (current_direction[1], -current_direction[0])\n        elif turn_direction == 'left':\n            return (-current_direction[1], current_direction[0])\n        return current_direction\n\n    # Traverse the path\n    x, y = start_pos\n    while 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1]:\n        # Mark the path\n        output_grid[x, y] = path_color\n\n        # Check the next position\n        nx, ny = x + direction[0], y + direction[1]\n\n        # Check if next position hits an obstacle\n        if 0 <= nx < input_grid.shape[0] and 0 <= ny < input_grid.shape[1]:\n            if input_grid[nx, ny] == obstacle_color:\n                # Turn in the specified direction\n                direction = turn(direction, turn_direction)\n            else:\n                # Move forward\n                x, y = nx, ny\n        else:\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Create a basic grid\n    n = np.random.randint(10, 15)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Define colors\n    path_color = Color.YELLOW\n    obstacle_color = Color.RED\n    start_color = Color.GREEN\n    direction_color = Color.BLUE\n\n    # Randomly place the start point on the grid\n    start_x, start_y = np.random.randint(0, n, size=2)\n    grid[start_x, start_y] = start_color\n\n    # Define an initial direction (e.g., to the right)\n    direction = (1, 0)  # right\n    direction_x, direction_y = start_x + direction[0], start_y + direction[1]\n    if 0 <= direction_x < n and 0 <= direction_y < n:\n        grid[direction_x, direction_y] = direction_color\n\n    # Place obstacles\n    num_obstacles = np.random.randint(3, 6)\n    for _ in range(num_obstacles):\n        ox, oy = np.random.randint(0, n, size=2)\n        grid[ox, oy] = obstacle_color\n\n    # Create a path\n    for _ in range(np.random.randint(5, 10)):\n        path_x, path_y = np.random.randint(0, n, size=2)\n        if grid[path_x, path_y] == Color.BLACK:\n            grid[path_x, path_y] = path_color\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 4, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 4, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0]], [[0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 4, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 2, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 4, 0, 0, 0, 0, 4, 0, 0], [0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3], [0, 0, 0, 0, 4, 4, 0, 0, 2, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4], [0, 0, 0, 0, 4, 4, 0, 0, 2, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 4, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["2dd70a9a.py", "b782dc8a.py", "6e19193c.py", "5168d44c.py", "Concepts: \nobstacle navigation, fixed direction turn, pathfinding\n\nDescription: \nInput is a grid with a path and obstacles. Starting from a given point, navigate the path until an obstacle is encountered. When an obstacle is hit, turn in the specified direction ('left' or 'right') and continue moving until the path is clear. Resume the original direction once past the obstacle. The output grid shows the path with consistent detours around obstacles, always turning the same way as specified."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# obstacles, path blocking, line drawing, pathfinding\n\n# description:\n# Identify obstacles as distinct objects in the grid that block the path of line drawing. When drawing a line between two points,\n# the line must navigate around these obstacles, ensuring no part of the line overlaps with any obstacle. The output grid shows\n# the line drawn from start to end, avoiding obstacles, while all other grid content remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = input_grid.copy()\n\n    # Get the start and end points, which are the only two non-black pixels\n    start_point = None\n    end_point = None\n\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        if start_point is None:\n            start_point = (x, y)\n        else:\n            end_point = (x, y)\n            break  # We found both start and end points\n\n    # Check for obstacles and define the blocked regions\n    obstacles = (input_grid != Color.BLACK) & (input_grid != input_grid[start_point]) & (input_grid != input_grid[end_point])\n\n    # Perform a simple BFS to find a path from start to end avoiding obstacles\n    queue = [(start_point, [start_point])]\n    visited = set([start_point])\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n\n    while queue:\n        (current, path) = queue.pop(0)\n\n        if current == end_point:\n            # Draw the path on the output grid\n            for x, y in path:\n                output_grid[x, y] = input_grid[start_point]\n            break\n\n        for direction in directions:\n            next_x, next_y = current[0] + direction[0], current[1] + direction[1]\n            if (0 <= next_x < output_grid.shape[0] and 0 <= next_y < output_grid.shape[1] and\n                    not obstacles[next_x, next_y] and (next_x, next_y) not in visited):\n                visited.add((next_x, next_y))\n                queue.append(((next_x, next_y), path + [(next_x, next_y)]))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly place a start and end point\n    start_color = random.choice(list(Color.NOT_BLACK))\n    end_color = random.choice([color for color in Color.NOT_BLACK if color != start_color])\n\n    grid[0, 0] = start_color\n    grid[-1, -1] = end_color\n\n    # Scatter obstacle blocks randomly\n    num_obstacles = random.randint(10, 20)\n    obstacle_color = random.choice([color for color in Color.NOT_BLACK if color not in [start_color, end_color]])\n\n    for _ in range(num_obstacles):\n        x, y = np.random.randint(0, grid_size, size=2)\n        if (x, y) not in [(0, 0), (grid_size - 1, grid_size - 1)]:\n            grid[x, y] = obstacle_color\n\n    return grid", "examples": [[[[9, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 5], [0, 0, 0, 0, 0, 5, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 5, 5, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 4]], [[9, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 5], [0, 0, 0, 0, 0, 5, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 5, 5, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 4]]], [[[3, 6, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 6, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 6, 0, 6, 0, 0], [6, 0, 0, 6, 0, 0, 0, 0, 6, 8]], [[3, 3, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 6, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 6, 0, 6, 0, 0], [6, 0, 0, 6, 0, 0, 0, 0, 6, 8]]], [[[5, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7]], [[5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7]]], [[[2, 0, 0, 0, 0, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 9, 0, 9, 9, 0, 0, 9, 0], [0, 0, 0, 0, 0, 9, 0, 0, 9, 9], [0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3]], [[2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 9, 0, 9, 9, 0, 0, 9, 0], [0, 0, 0, 0, 0, 9, 0, 0, 9, 9], [0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3]]], [[[5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 9, 0, 0], [9, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 9, 9, 0, 9, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 0, 0, 9, 0, 0, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 4]], [[5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 9, 0, 0], [9, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 0, 0], [0, 9, 9, 0, 9, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 0, 0, 9, 0, 0, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 4]]]], "seeds": ["d9f24cd1.py", "2dd70a9a.py", "a78176bb.py", "8d510a79.py", "Concepts: \nobstacles, path blocking, line drawing\n\nDescription: \nIdentify obstacles as distinct objects in the grid that block the path of line drawing. When drawing a line between two points, the line must navigate around these obstacles, ensuring no part of the line overlaps with any obstacle. The output grid shows the line drawn from start to end, avoiding obstacles, while all other grid content remains unchanged."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean mask, predicate evaluation, pattern recognition, template creation\n\n# description:\n# Input is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask,\n# where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template\n# for identifying the pattern in other grid regions.\n\ndef main(input_grid):\n    # Define a simple predicate function for demonstration.\n    # This predicate returns True if the color is not black.\n    def predicate(color):\n        return color != Color.BLACK\n\n    # Initialize an output grid with the same shape as the input grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Evaluate the predicate function on each cell of the input grid\n    mask = np.vectorize(predicate)(input_grid)\n\n    # Fill the corresponding cells in the output grid with a color (e.g., yellow) where the mask is True\n    output_grid[mask] = Color.YELLOW\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter a few colors into the grid\n    num_colors = np.random.randint(1, 5)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    for color in colors:\n        randomly_scatter_points(grid, color=color, density=0.3)\n\n    return grid", "examples": [[[[5, 5, 8, 5, 7, 8, 8, 8, 5, 5, 5, 8], [5, 7, 5, 7, 5, 7, 7, 5, 7, 8, 5, 7], [0, 5, 8, 7, 5, 8, 8, 7, 5, 5, 8, 5], [7, 7, 7, 5, 8, 0, 0, 5, 7, 8, 7, 5], [7, 7, 8, 8, 7, 5, 7, 8, 0, 8, 8, 7], [5, 5, 7, 7, 0, 5, 7, 8, 0, 7, 8, 0], [8, 5, 8, 8, 7, 7, 8, 8, 5, 8, 5, 7], [5, 5, 0, 0, 8, 5, 8, 8, 7, 7, 7, 8]], [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4], [4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4]]], [[[8, 5, 8, 5, 5, 7, 5, 7, 8, 0], [5, 8, 5, 5, 5, 8, 0, 8, 7, 5], [0, 7, 8, 5, 5, 8, 8, 8, 7, 7], [7, 5, 0, 7, 5, 0, 5, 7, 5, 8], [7, 7, 5, 8, 8, 8, 7, 8, 7, 8], [7, 8, 7, 8, 5, 0, 7, 0, 5, 7], [7, 5, 8, 7, 5, 8, 8, 7, 7, 5]], [[4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [4, 4, 4, 4, 4, 4, 0, 4, 4, 4], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 0, 4, 4, 0, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 0, 4, 0, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4]]], [[[6, 0, 0, 6, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 6, 0, 0, 6, 0, 0, 6, 0], [6, 0, 6, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0], [0, 0, 6, 0, 0, 6, 0, 0, 0, 6, 6], [0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 0], [6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0]], [[4, 0, 0, 4, 0, 4, 0, 4, 0, 0, 0], [0, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0], [4, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0], [4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0]]], [[[0, 0, 4, 9, 0, 0, 4, 0, 0], [0, 0, 0, 9, 0, 4, 9, 4, 9], [0, 9, 0, 9, 4, 9, 0, 0, 4], [4, 0, 0, 0, 9, 0, 0, 4, 0], [4, 9, 0, 0, 9, 9, 9, 9, 9], [9, 9, 4, 0, 4, 4, 9, 4, 4], [9, 4, 9, 0, 0, 4, 0, 4, 4], [9, 9, 9, 4, 0, 0, 4, 0, 4], [4, 4, 9, 4, 9, 0, 4, 0, 9]], [[0, 0, 4, 4, 0, 0, 4, 0, 0], [0, 0, 0, 4, 0, 4, 4, 4, 4], [0, 4, 0, 4, 4, 4, 0, 0, 4], [4, 0, 0, 0, 4, 0, 0, 4, 0], [4, 4, 0, 0, 4, 4, 4, 4, 4], [4, 4, 4, 0, 4, 4, 4, 4, 4], [4, 4, 4, 0, 0, 4, 0, 4, 4], [4, 4, 4, 4, 0, 0, 4, 0, 4], [4, 4, 4, 4, 4, 0, 4, 0, 4]]], [[[0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [7, 0, 0, 0, 7, 0, 0, 0, 0, 7], [0, 0, 0, 0, 7, 0, 7, 0, 7, 0], [7, 7, 0, 0, 0, 0, 7, 0, 0, 7], [0, 0, 0, 0, 0, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [0, 7, 0, 7, 0, 0, 0, 0, 0, 0], [7, 0, 7, 7, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0, 7, 0], [7, 0, 0, 0, 0, 0, 7, 0, 7, 7], [0, 0, 7, 0, 7, 7, 0, 7, 0, 7], [0, 0, 0, 0, 0, 7, 0, 0, 7, 0], [0, 7, 0, 7, 0, 7, 7, 7, 0, 0], [7, 7, 0, 0, 0, 0, 0, 0, 7, 0]], [[0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [4, 0, 0, 0, 4, 0, 0, 0, 0, 4], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [4, 4, 0, 0, 0, 0, 4, 0, 0, 4], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0, 0], [4, 0, 4, 4, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 4, 4, 0, 4, 0], [4, 0, 0, 0, 0, 0, 4, 0, 4, 4], [0, 0, 4, 0, 4, 4, 0, 4, 0, 4], [0, 0, 0, 0, 0, 4, 0, 0, 4, 0], [0, 4, 0, 4, 0, 4, 4, 4, 0, 0], [4, 4, 0, 0, 0, 0, 0, 0, 4, 0]]], [[[0, 0, 9, 9, 0, 0, 9], [0, 9, 0, 9, 9, 0, 0], [0, 8, 0, 9, 8, 8, 0], [9, 8, 0, 0, 9, 0, 8], [9, 8, 0, 9, 9, 8, 0], [0, 9, 0, 0, 0, 8, 9], [9, 8, 8, 0, 9, 0, 0], [8, 0, 8, 8, 8, 0, 8], [0, 8, 9, 0, 8, 9, 0], [8, 8, 8, 9, 9, 8, 9]], [[0, 0, 4, 4, 0, 0, 4], [0, 4, 0, 4, 4, 0, 0], [0, 4, 0, 4, 4, 4, 0], [4, 4, 0, 0, 4, 0, 4], [4, 4, 0, 4, 4, 4, 0], [0, 4, 0, 0, 0, 4, 4], [4, 4, 4, 0, 4, 0, 0], [4, 0, 4, 4, 4, 0, 4], [0, 4, 4, 0, 4, 4, 0], [4, 4, 4, 4, 4, 4, 4]]], [[[1, 1, 9, 0, 9, 9], [0, 1, 1, 0, 0, 0], [9, 0, 0, 1, 1, 9], [1, 1, 9, 9, 9, 0], [9, 0, 0, 1, 9, 1], [0, 1, 9, 0, 0, 1], [9, 1, 1, 0, 1, 0], [9, 9, 0, 0, 0, 9], [1, 9, 0, 1, 0, 9]], [[4, 4, 4, 0, 4, 4], [0, 4, 4, 0, 0, 0], [4, 0, 0, 4, 4, 4], [4, 4, 4, 4, 4, 0], [4, 0, 0, 4, 4, 4], [0, 4, 4, 0, 0, 4], [4, 4, 4, 0, 4, 0], [4, 4, 0, 0, 0, 4], [4, 4, 0, 4, 0, 4]]]], "seeds": ["00d62c1b.py", "90c28cc7.py", "bc1d5164.py", "780d0b14.py", "Concepts: \nboolean mask, predicate evaluation, pattern recognition, template creation\n\nDescription: \nInput is a grid region (block) and a predicate function. Evaluate the predicate at each cell in the block to produce a boolean mask, where each mask cell is True if the predicate is satisfied at that location, otherwise False. This mask serves as a reusable template for identifying the pattern in other grid regions."]}
{"source": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color runs, recolor, bounding box, symmetry\n\n# description:\n# Identify contiguous horizontal or vertical runs of cyan (color=4) in the grid. \n# For each run, compute k as the minimum of 3 or half the run's length (rounded down). \n# Recolor the first k and last k cells of each run to yellow (color=3), \n# leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Define cyan and yellow\n    cyan = 4\n    yellow = 3\n\n    # Process each row for horizontal runs\n    for row in range(output_grid.shape[0]):\n        col = 0\n        while col < output_grid.shape[1]:\n            if output_grid[row, col] == cyan:\n                start = col\n                while col < output_grid.shape[1] and output_grid[row, col] == cyan:\n                    col += 1\n                end = col\n                run_length = end - start\n                k = min(3, run_length // 2)\n                output_grid[row, start:start + k] = yellow\n                output_grid[row, end - k:end] = yellow\n            col += 1\n\n    # Process each column for vertical runs\n    for col in range(output_grid.shape[1]):\n        row = 0\n        while row < output_grid.shape[0]:\n            if output_grid[row, col] == cyan:\n                start = row\n                while row < output_grid.shape[0] and output_grid[row, col] == cyan:\n                    row += 1\n                end = row\n                run_length = end - start\n                k = min(3, run_length // 2)\n                output_grid[start:start + k, col] = yellow\n                output_grid[end - k:end, col] = yellow\n            row += 1\n\n    return output_grid\n\ndef generate_input():\n    # Random size of input grid\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n\n    # Initialize grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide on the number of cyan runs\n    n_runs = np.random.randint(1, 4)\n\n    for _ in range(n_runs):\n        # Randomly decide if the run is horizontal or vertical\n        if np.random.choice(['horizontal', 'vertical']) == 'horizontal':\n            row = np.random.randint(0, n)\n            start_col = np.random.randint(0, m - 2)\n            run_length = np.random.randint(2, m - start_col + 1)\n            grid[row, start_col:start_col + run_length] = 4  # cyan\n        else:\n            col = np.random.randint(0, m)\n            start_row = np.random.randint(0, n - 2)\n            run_length = np.random.randint(2, n - start_row + 1)\n            grid[start_row:start_row + run_length, col] = 4  # cyan\n\n    return grid", "examples": [[[[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 4, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 4], [0, 0, 0, 0, 4, 0, 0, 0, 4], [0, 0, 0, 0, 4, 0, 0, 0, 4], [0, 0, 0, 0, 4, 0, 0, 0, 4], [0, 0, 0, 0, 4, 0, 0, 0, 4]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 3], [0, 0, 0, 0, 4, 0, 0, 0, 3], [0, 0, 0, 0, 3, 0, 0, 0, 4], [0, 0, 0, 0, 3, 0, 0, 0, 3], [0, 0, 0, 0, 3, 0, 0, 0, 3]]], [[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]]], "seeds": ["10fcaaa3.py", "7447852a.py", "09629e4f.py", "3428a4f5.py", "Concepts: \ncolor runs, recolor, bounding box, symmetry\n\nDescription: \nIdentify contiguous horizontal or vertical runs of cyan (color=4) in the grid. For each run, compute k as the minimum of 3 or half the run's length (rounded down). Recolor the first k and last k cells of each run to yellow (color=3), leaving the interior cells unchanged. This transformation applies symmetrically to both ends of each cyan run, capping them with yellow while preserving the run's central portion."]}
