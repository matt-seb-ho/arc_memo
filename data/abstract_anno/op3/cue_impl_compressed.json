[["```yaml\ncues:\n  - if the solution checks if multiple regions or objects are identical, possibly allowing for symmetry, reflection, or scaling\n  - if only objects of a specific size or proportional dimensions are selected for further processing\n  - if the output depends on counting, detecting, or selecting objects of a fixed shape or scaled version of another object\n\nimplementation:\n  - compare the object's bounding box dimensions or aspect ratio to the given size or shape\n  - for allow_scale, check if one shape is an integer multiple of the other in both dimensions\n  - for allow_partial, ignore pixels that are off-grid when comparing shapes\n```"],["```yaml\ncues:\n  - if structures or objects from the input grid appear in the output grid with different colors\n  - if all pixels of one color in the output grid are replaced with another color (systematic color swap)\n  - if regions or objects are recolored based on a property (e.g., size, position, or matching a specific pixel)\n  - if the output grid contains regions filled with a new color not present in the input\n  - if background or other colors are systematically replaced in the output grid\n  - if the output grid is visually similar to the input except for a color swap\n  - if colored pixels or regions appear in the output grid at positions that were black or missing in the input, especially adjacent to colored pixels or aligned with features of input objects\n  - if a region or contiguous area is uniformly recolored, possibly based on a pixel in a special position (e.g., corner, interior of a container)\n  - if an input pixel or object is removed or replaced with background color in the output grid (deletion by recoloring)\n  - if a special color (e.g., grey or yellow) appears at a position determined by the interaction or meeting of input objects or paths\n\nimplementation:\n  - for a single pixel, set grid[position] = color\n  - after drawing operations that may overwrite a pixel, restore that pixel to its intended color\n  - for each pixel, if its color is in the color scheme, replace it with the mapped color\n  - for a region or object, iterate over its pixels and set each to the target color or according to the color scheme\n  - for a region, if a pixel is background (e.g., black), set it to the specified color; otherwise, leave it unchanged\n  - at special positions (e.g., meeting points or intersections), set the pixel to a designated color (e.g., grey) instead of either input color\n```"],["```yaml\ncues:\n  - divider lines (of any color) that span the grid and partition it into regions\n  - visually distinct regions or objects that are processed separately, often separated by colored or black lines, columns, or rows\n  - color-based regions where pixels of a certain color only appear within specific sections of the grid\n```"],["```yaml\ncues:\n  - if input objects are replicated or overlaid one or more times in the output\n  - if a sprite, motif, or pattern is drawn or overlaid at a specific position in the output grid\n  - if a completed, modified, or transformed region is overlaid back onto the original grid at its original or a specified position\n  - if colored regions, patterns, or sprites are overlaid at specific positions or inside larger objects/frames in the output grid\n  - if layers or patterns are built up by drawing on top of each other, or objects are redrawn to restore outlines or details\n  - if the output grid is constructed by assembling multiple copies of an object at specified positions\nimplementation:\n  - overlay the sprite's non-background pixels onto the base grid at the specified position, leaving background pixels unchanged\n```"],["```yaml\ncues:\n  - if existing structures from the input grid appear in the output grid with different positions\n  - if the output grid is a shifted version of the input grid or of an object in the input grid\n  - if objects are repositioned to align with another object's coordinate (e.g., matching y or x position)\n  - if pixels or objects in the input grid appear to \"fall\" or move vertically to the lowest available position in their column in the output grid, or are shifted downward, possibly stacking on a baseline or other pixels\n  - if a pixel or object in the input grid appears shifted by one row or column in the output grid, including single colored pixels moving to a new position\n  - if the solution checks for adjacency by moving an object one step in a direction and testing for overlap/contact\n\nimplementation:\n  - erase the object pixels from the old position before drawing the object at the new position\n  - to move an object by one pixel in a direction, increment the object's coordinate(s) accordingly and redraw it at the new position\n  - to align objects along a coordinate, set the desired coordinate (e.g., y) to match the reference object while keeping the other coordinate unchanged\n  - for relative moves, update all pixel positions of the object by the direction and step\n```"],["```yaml\ncues:\n  - if an object or motif from the input grid is repeated in a regular, evenly spaced pattern in the output grid (e.g., filling a dimension, forming a rectangular grid, or along a line)\n  - if the output grid is larger than the input grid and consists of exact or regularly spaced copies of the input or its sub-objects\n  - if an object is repeatedly moved and drawn at regular intervals in a fixed direction in the output grid\n\nimplementation:\n  - use numpy.tile or nested loops to repeat the input grid or object the specified number of times along each axis or direction, applying the specified gap between repetitions\n  - repeatedly move and draw the object by the specified gap in the given direction, stopping when the placement would go out of bounds\n```"],["```yaml\ncues:\n  - if output grid dimensions differ from input grid dimensions\n  - if output grid content is initialized as blank or filled with a single color before further drawing or tiling\n  - if output grid is a fixed size (e.g., 1x1, single row/column, or specific pattern) regardless of input grid size or content\n  - if output grid dimensions depend on the number of objects or layers in the input\n  - if output grid is larger or smaller than any input region and not a direct copy of any input region\n\nimplementation:\n  - use numpy.full or numpy.zeros to create a new grid with the specified dimensions and fill color\n  - ensure the grid is initialized before any drawing or overlay operations\n  - parameterize the grid size and fill color to allow for flexible reuse in different contexts\n```"],["```yaml\ncues:\n  - Presence of an object in the input grid that appears rotated in the output grid\n  - Same object appears multiple times with different rotations\n  - Emergence of rotational symmetry in the output grid not present in the input\n\nimplementation:\n  - Use numpy functions such as np.rot90 or affine transformations to rotate the object's pixels around the specified center\n```"],["```yaml\ncues:\n  - if objects are colored differently based on their size\n  - if the output grid shows objects of a particular area or pixel count treated specially\n  - if only 1x1, 2x2, or other specific-sized objects are affected in the output\n\nimplementation:\n  - compare the object's size attribute (such as area or pixel count) to the given value using the specified operator\n```"],["```yaml\ncues:\n  - output grid contains lines not present in the input grid\n  - output grid contains lines passing through, extending from, or adjacent to specific pixels or objects in the input grid\n  - lines span the entire grid in a direction from a given pixel, or terminate at a colored object or grid edge\n  - lines are drawn in straight, diagonal, or staircase patterns, possibly alternating directions or forming an \"X\"\n  - lines are drawn from specific points (e.g., object corners, edges, or centers) outward in one or more directions\n  - output grid contains lines connecting objects, pixels, or scattered points to the edge of a region or frame\n  - lines are repeated at regular intervals along a row or column, or show periodic gaps (e.g., every other cell colored)\n  - output grid contains new horizontal or vertical bars aligned with colored pixels in the input grid, possibly replacing single pixels with full-length bars\n  - lines are drawn from or to specific colored pixels and stop at another color, object, or grid boundary\n  - output grid contains lines that \"navigate\" around obstacles or change direction at the grid edge\n  - output grid shows objects with longer arms or bars than in the input, or arms extended from a central axis\n  - output grid contains new colored bars or lines at the center or top of rectangles or other shapes\n\nimplementation:\n  - draw the line pixel by pixel from the starting point, updating the position by the direction vector until the end point, grid edge, or stopping condition is met\n  - for lines spanning the grid, set length to grid height (vertical) or grid width (horizontal); for \"to_edge\", continue until the grid boundary\n  - use a loop to set each pixel along the line to the specified color; for step > 1, color every step-th pixel\n  - for diagonal lines, increment/decrement both x and y according to the direction\n  - for staircase or alternating patterns, update the direction and starting position as needed\n  - stop drawing if the next pixel is the stop_at_color, stop_at object, or if a custom stopping criteria is met\n  - for repeated lines at regular intervals, loop over offsets and call the line-drawing routine for each\n  - for vertical or horizontal bars, fix one coordinate and vary the other across the grid dimension\n  - to extend arms or bars, use the center or relevant object edge as the start and draw in each direction with the desired length\n  - for lines that must avoid obstacles, include logic to change direction or skip blocked positions\n  - return the last position reached (end_pixel) if further processing is needed\n```"],["```yaml\ncues:\n  - if there is an object with a cavity\n  - if there are objects with an empty interior and a single pixel inside, and the output fills the interior with that pixel's color\nimplementation: []\n```"],["```yaml\ncues:\n  - if a specific color is systematically replaced by another in the output grid\n  - if a specific color is systematically assigned based on object rank or order, or if output grid colors follow a fixed palette in a ranked or ordered fashion\nimplementation:\n  - assign colors to objects in the order determined by sorting or ranking\n```"],["```yaml\ncues:\n  - if the grid is visually partitioned into rectangles by lines of a specific color (e.g., black or grey)\nimplementation:\n  - identify continuous lines of the divider color that span the grid and use them to slice the grid into regions via array slicing\n```"],["```yaml\ncues:\n  - Presence of objects in the input grid with empty regions or cavities inside them.\n  - Output grid distinguishes between objects with internal holes and solid objects.\n\nimplementation:\n  - Use a background color mask to identify holes within the object if the background color is known.\n  - Alternatively, perform a flood fill from non-object pixels to determine if empty regions inside the object are not connected to the grid edge, indicating holes.\n```"],["```yaml\ncues:\n  - when you need to determine the direction from one object or part of an object to another, such as from colored to background pixels\n  - when the output depends on the orientation or pointing direction of an object\n  - when movement or transformation is constrained to cardinal directions (up, down, left, right), or output grids show pixels moving only along rows or columns\nimplementation:\n  - can be applied to positions, such as using the mean position of colored pixels versus background pixels\n  - compute the vector from the source to the target and select the closest matching direction from allowed_directions\n```"],["```yaml\ncues:\n  - If objects or structures in the input grid appear in the output grid shifted in a cardinal direction, often stopping just before contacting another object or the grid boundary.\n  - If movement is limited to a certain number of steps, or objects move stepwise in a direction until a condition is met (such as collision or reaching a target).\n  - If pixels or objects move in straight lines toward a target or region, with the output showing their new positions after such movement.\n\nimplementation:\n  - Move the object one step at a time in the specified direction, checking the stopping_criteria after each step; stop when the criteria is met or after the specified number of steps.\n  - Alternatively, consider all possible displacements in the direction and select the furthest valid position before a collision or boundary, according to the stopping_criteria.\n```"],["```yaml\ncues:\n  - if movement stops when a pixel contacts a specific object (not just any non-background pixel)\n  - if output grid shows pixels stopping at a colored region or object\nimplementation:\n  - check if the object is adjacent to the specified target object in the movement direction after each step\n```"],["```yaml\ncues:\n  - presence of horizontal and vertical lines that partition the grid into non-overlapping regions or tiles\n  - input grid is visually organized as a grid of distinct regions, or output grid has one pixel per input region, preserving region order\nimplementation:\n```"],["```yaml\ncues:\n  - Input grid contains a region grid, but output grid does not preserve the region grid structure.\n  - Output grid dimensions match the number of regions along each axis of the input region grid (i.e., one output pixel per region).\n  - Output pixel colors correspond to a representative color from each region in the input grid.\n\nimplementation:\n  - Create a new grid with the same dimensions as the region grid; for each region, use the color selection logic to determine a representative color (e.g., the color of the top-left pixel or the dominant/only color in the region) and assign it to the corresponding output pixel.\n```"],["```yaml\ncues:\n  - if a region is divided into two halves along a symmetry axis for further processing\n  - if the output grid contains mirrored or transformed halves of an input pattern\nimplementation:\n```"],["```yaml\ncues:\n  - if the output depends on the frequency or count of objects of each color\n  - if colors are selected or ordered based on how many objects have that color\n  - if the output grid size or content depends on the number of unique colors in the input grid, excluding background\nimplementation:\n  - if by=\"color\", count the number of objects for each color and return a dict mapping color to count\n  - can use collections.Counter or similar to tally counts by attribute\n```"],["```yaml\ncues:\n  - if a region is extended from an edge or indicator pixel, with width or height matching another object's extent or extending to the grid border in a specific direction\n  - if output grid contains bars or rectangles extending from an object to the grid edge, with size determined by the object's dimensions\n\nimplementation:\n  - for a \"rectangle_bar\" pattern, create a rectangle of the appropriate width or height starting at the indicator and extending in the given direction to the grid edge; scale parameter determines the width (if extending horizontally) or height (if vertically)\n```"],["```yaml\ncues:\n  - if structures or objects in the input grid appear in the output grid with mirrored orientation\n  - if objects in the output are mirrored versions of input objects, especially when the axis of reflection is not always the grid center\n  - if reflection occurs relative to another object, such as a frame, guide, or adjacent colored pixel\n  - if the output grid contains repeated or tiled mirrored copies of an input object or region, possibly with different orientations (e.g., original, horizontally flipped, vertically flipped)\n  - if the solution tests for equality up to reflection\n  - if the axis of reflection is determined by the position of an indicator, marker, or is aligned with an object's edge\n  - if mirrored halves or regions are reflected before being placed or used to cover another region in the output\n\nimplementation:\n  - use np.flip for standard horizontal or vertical axis reflections\n  - calculate the mirror axis (line of symmetry) based on the position of a reference object, indicator, or specified coordinate\n  - for each pixel in the object, compute its reflected position across the specified axis and mirror_axis; for non-grid-aligned axes, perform custom coordinate transforms\n  - for grid-aligned axes, use np.flip; for arbitrary axes or positions, compute new coordinates manually\n  - reflect the object across the specified axis and position, ensuring placement aligns with the intended region or adjacent object\n```"],["```yaml\ncues:\n  - if objects or pixels move until they reach another object in the output grid\n  - if output pixels stop at the edge of a bar or larger object\n  - if the output depends on whether two objects are connected, touching, or form a single contiguous region\n  - if the presence of a path or connection between objects determines the output\n  - if objects are grouped, merged, or considered in contact based on adjacency or connectivity (i.e., not separated by background pixels)\n  - if the output grid shows two objects just touching, with one moved to abut the other\n  - if the stopping condition for movement is adjacency or overlap with a target object\n\nimplementation:\n  - check if the moved object is adjacent to or overlapping the target object after each step\n  - for each pair of objects, check if their pixel sets are adjacent or overlap (using 4-way or 8-way connectivity as appropriate), ignoring background color\n  - can use connected components labeling to see if two regions are part of the same component\n```"],["```yaml\ncues:\n  - if the output grid is smaller than the input grid\n  - if the output grid contains only a subset of the objects in the input grid\n  - if the output grid is a contiguous subregion of the input grid, especially one corresponding to a single object, region of interest, frame, or container\n  - if a central pattern or minimal sprite is extracted from a larger grid for further manipulation\n  - if only the content of an object (without surrounding background) is drawn elsewhere in the output grid\n  - if patterns or objects are copied from the input grid but appear tightly cropped in the output\n  - if the output grid is a rectangle bounded by colored lines or a minimal bounding box containing a single object from the input grid\n  - if you need to extract the content of a region or square, ignoring divider lines or background\n\nimplementation:\n  - find the extrema for x and y coordinates of the specified objects and use them to slice the grid\n  - to remove a border, crop the bounding box of the object and then trim the specified number of pixels from each edge\n  - after cropping, optionally trim away a border of background color pixels or mask out pixels of the background color if specified\n  - to extract a sprite or region, crop the bounding box of the object, possibly by specifying (row, col, height, width)\n```"],["```yaml\ncues:\n  - if a region or object contains a single colored pixel and that color is used elsewhere in the output\n  - if the output grid uses a color that appears only inside another object in the input grid\nimplementation:\n  - use np.unique, then filter out excluded colors\n```"],["```yaml\ncues:\n  - if only edge pixels are selected for further processing or movement\n  - if output grid features originate from the border of the input grid\n  - if the process starts from colored pixels on a specific edge (e.g., bottom row)\nimplementation:\n  - for grid, check if object's pixel positions coincide with the border (i.e., row or column index is 0 or at max index)\n```"],["```yaml\ncues:\n  - if input objects appear with extra layer(s) of pixels around them in the output grid\n  - if a single pixel in the input grid is surrounded by a colored border in the output grid, with all other pixels set to background\n  - if the output grid contains a square or rectangular border centered on a unique pixel\n\nimplementation:\n  - identify outermost pixels of the object and color their empty neighbors to create the border\n  - for a border of width 1, create a 3x3 square centered at the target pixel and set the border pixels to the border color, using array slicing or coordinate offsets\n  - alternatively, draw a larger version of the object (including the border), then overwrite the original object pixels to preserve their color\n```"],["```yaml\ncues:\n  - if objects or regions need to be processed in a specific spatial order (e.g., top-to-bottom, left-to-right, diagonal, or by position)\n  - if objects are processed in an order determined by a property (e.g., size, area, color count, frequency, or another attribute)\n  - if the output grid's arrangement, coloring, or features depend on the order or ranking of objects by position, size, or attribute\n  - if nested, layered, or composite objects must be processed from outermost to innermost (or vice versa)\n  - if distinguishing or extracting inner and outer components by size is required\n  - if the crop region or output arrangement is defined by the spatial order of boundary or container objects\n  - if multiple frames, containers, lines, or bars must be processed in a specific spatial order (e.g., left-to-right, top-to-bottom)\nimplementation:\n  - use Python's sorted() with a lambda function extracting the relevant key (e.g., x or y coordinate, position tuple, size, area, count, or attribute)\n  - for diagonal ordering, use a lambda extracting the diagonal index (e.g., x+y or x-y)\n  - for left-to-right or top-to-bottom sorting, use a lambda extracting the object's minimum x or y coordinate (e.g., bounding box edge)\n  - for sorting by frequency or size, use the count or area as the key and set reverse=True for descending order if needed\n  - for top-left ordering, use a lambda extracting (y, x) from the object's position attribute\n  - set reverse=True to sort from largest to smallest (e.g., tallest to shortest, outermost to innermost)\n```"],["```yaml\ncues:\n  - if the grid contains objects that are long and thin, spanning the width or height of a region\n  - if the output grid consists of a single row or column of colored pixels, especially with one color per pixel\n  - if the output grid is a vertical or horizontal line of colors\n\nimplementation:\n  # (No implementation notes were provided in the original annotation)\n```"],["```yaml\ncues:\n  - if objects are all of height 1 or all of width 1\n  - if objects are all aligned in a row or column (e.g., stripes, green dots, lines)\n  - if the direction of movement, extension, or symmetry depends on the orientation or alignment of objects\n  - if the output grid's orientation (vertical/horizontal) depends on the arrangement of input objects\n  - if the track or path is defined by a set of aligned markers\nimplementation:\n  - check if all objects have height 1 (horizontal) or width 1 (vertical)\n  - check if all objects have the same x (vertical alignment) or y (horizontal alignment) coordinate\n```"],["```yaml\ncues:\n  - if output grid contains concentric square frames or borders centered on a point or object\n  - if there are repeated square outlines expanding from a central point\n  - if frames are always a fixed multiple of the object size (e.g., twice as large)\nimplementation:\n  - create a grid with pixels set to the color on the four sides of the square defined by center and half_width\n  - compute the side length as twice the object's size (or another scale factor), center the frame on the object, and set the border pixels to the specified color\n```"],["```yaml\ncues:\n  - if the output depends on whether the input grid is symmetric or not\n  - if the input grid appears unchanged or is referenced as a whole in the output logic\n  - if output grid contains only an object that is symmetric (mirror or rotational) and other objects are omitted\n  - if the solution logic selects objects based on their symmetry properties\n  - if the output grid is a cropped symmetric object from the input grid\n\nimplementation:\n  - compare the grid or object to its reflection along the specified axis using np.flip or similar\n  - for rotational symmetry, check if the object is invariant under 90/180/270 degree rotation using np.rot90 or equivalent\n```"],["```yaml\ncues:\n  - if output grid contains special markings or a distinct color at the crossing points of lines\n  - if lines of different colors cross and a third color appears at the intersection\n  - if lines cross at a single pixel, especially where a colored pixel exists in the input grid\nimplementation:\n  - Detect line segments in the grid, then identify overlapping positions by checking for shared coordinates among lines\n  - Mark intersection points with a special color or object as specified by the transformation rule\n```"],["```yaml\ncues:\n  - presence of a repeating pattern or objects along a specific direction in the grid\n  - output grid fills or reconstructs regions by repeating content from the input\n  - regions of the grid are missing but the rest exhibits a translationally repeating pattern\n\nimplementation:\n  - compare shifted versions of the grid, excluding ignored colors, to identify translation vectors that map the pattern onto itself\n  - use cross-correlation or brute-force shifting and comparison to detect repeating units\n  - for vertical or horizontal symmetry, specifically check for repeating rows or columns or objects at regular intervals in the specified direction\n```"],["```yaml\ncues:\n  - if filling in missing pixels by referencing symmetric positions in the grid\n  - if the output grid contains repeated copies of a pixel or object at positions related by symmetry\n  - if the solution logic involves mapping a pixel to all its symmetric counterparts\n\nimplementation:\n  - repeatedly apply the symmetry transformation to the position, collecting all unique positions until a cycle is detected or for a fixed number of steps (order)\n  - for each i in 0 to order-1, apply the symmetry transformation i times to the starting position and collect the results (e.g., for rotational symmetry, rotate the position by i * angle around the center)\n```"],["```yaml\ncues:\n  - if pixels are placed at a fixed offset from a reference position, especially along diagonals\n  - if output grid contains features grown outward from a central pixel in diagonal directions\n  - if a process moves stepwise in a direction, possibly changing direction to avoid obstacles\n  - if output features are constructed by updating a position iteratively\n\nimplementation:\n  - update the position coordinates according to the direction and distance (e.g., for \"up\", subtract from row index; for \"right\", add to column index)\n  - for each direction and distance, add the direction vector multiplied by the step to the starting position\n```"],["```yaml\ncues:\n  - if lines or features in the output originate from the corners of objects\n  - if logic depends on or selects the color of a corner pixel of a cropped or bounded region or object\n\nimplementation:\n  - find min and max x and y coordinates among the object's pixels to determine the four corners\n  - can be used to extract the color of a corner pixel for use in recoloring\n```"],["```yaml\ncues:\n  - if output grid contains reflected copies of an object or pixel, especially around the center of a symmetric object\n  - if the output grid restores symmetry by mirroring pixels across an axis\n  - if pixels in the output grid appear in symmetric positions relative to an axis\nimplementation:\n  - for each axis, compute the reflected position with respect to the center; for multiple axes, produce all combinations\n```"],["```yaml\ncues:\n  - if multiple objects are drawn onto a blank or new grid in the output\n  - if the output grid is constructed by overlaying recolored or transformed objects\n  - if the output grid is a minimal bounding rectangle containing all objects, with no empty space\nimplementation:\n  - for each object, draw its pixels onto the base grid at its position, possibly using the draw object routine\n  - if bounding_box_only is True, crop the output to the minimal rectangle containing all objects\n```"],["```yaml\ncues:\n  - If the reflection axis is not fixed but depends on the spatial relationship between objects, such as when reflection is determined by the position of another object or pixel.\n  - If mirrored objects appear adjacent to indicator pixels in the output grid.\n  - If the mirror axis must be computed dynamically for each object-frame pair, especially when reflection is not always across the frame center but depends on which side the object is on.\n\nimplementation:\n  - For vertical or horizontal orientation, determine the mirror axis coordinate (row or column) based on the object's position relative to the frame or indicator; this may be just beyond the object's edge closest to the indicator or relative to the frame's center.\n  - Compare the object's position to the frame's center or to the indicator's position to determine the correct side and select the appropriate axis and coordinate for reflection.\n```"],["```yaml\ncues:\n  - if objects or regions are selected, sorted, or processed based on the number of pixels of a certain color or their area (number of colored pixels)\nimplementation:\n  - count the number of pixels in the object's mask or region that match the specified color or satisfy the given criteria; for regions, count pixels not equal to the background or divider color; can use np.sum or boolean masks for implementation\n```"],["```yaml\ncues:\n  - if the solution tries all possible placements of an object within a region\n  - if the output grid is constructed by fitting pieces into a container\n  - if logic iterates over every pixel in a grid\nimplementation:\n  - slide the object's bounding box over all positions where it remains within the container's bounding box, typically using nested loops over the grid's shape to yield all (row, col) positions\n```"],["```yaml\ncues:\n  - if lines or objects are drawn in both a direction and its opposite from a point\n  - if lines or objects change direction at the edge of the grid or upon collision with a wall\n  - if a \"bouncing\" or reflection effect is observed in the output grid\nimplementation:\n  - map each direction to its reverse (e.g., \"up-right\" <-> \"down-left\", \"up\" <-> \"down\", \"left\" <-> \"right\")\n  - reverse the x component for horizontal bounces and the y component for vertical bounces\n```"],["```yaml\ncues:\n  - if the grid contains objects that are as wide or as tall as the grid itself\n  - if output pixels are aligned with or stop at such objects\n  - if the output grid consists of colored rectangles or lines spanning the grid\nimplementation:\n```"],["```yaml\ncues:\n  - presence of isolated single pixels in the input grid that are moved or removed in the output\n  - output grid is a single pixel (1x1), possibly with its color encoding a result\n\nimplementation:\n  - represent as a tuple of (row, column, color) or as a mask identifying single non-background pixels\n  - detect by scanning for grid positions where a non-background color is surrounded by background pixels\n```"],["```yaml\ncues:\n  - if regions are recolored or selected based on their size or area\n  - if the output grid treats the largest or smallest regions differently\nimplementation:\n  - count the number of non-background pixels in the region, e.g., using np.sum(region != background_color)\n```"],["```yaml\ncues:\n  - if the solution needs to find the \"center\" or \"center of mass\" of a colored region, object, or grid\n  - if movement or direction is determined from the center of one region to another within the same object\n  - if objects are aligned or overlaid at the center of a grid or another object\nimplementation:\n  - if color is specified, only consider pixels matching the color (or those selected by the predicate)\n  - compute the center by averaging the x and y coordinates of the selected pixels (center of mass)\n```"],["```yaml\ncues:\n  - if regions, rows, or bars in the output grid are uniformly filled with a single color\n  - if the output grid shows regions recolored based on a property (e.g., size, count, or position)\n  - if a bar, region, or path is extended and filled with a color in the output grid\n  - if output grid shows new colored pixels extending from a base pixel, object, or along a sequence (path/trail)\n  - if the output grid is initialized as blank and then filled with colored pixels based on a count or property\n\nimplementation:\n  - set all pixels in the specified region, row, or path to the given color, optionally using array assignment or masking\n  - for each position along the intended region or path, set the pixel to the specified color if it matches a condition (e.g., is background), possibly using a loop until a stopping condition is met\n  - set the first N pixels (in a specified order, e.g., left-to-right, top-to-bottom) to the color, where N is determined by a count or property\n```"],["```yaml\ncues:\n  - if pixel counting or selection ignores certain colors (e.g., background or divider)\n  - if the logic applies to all colors except a specific set (e.g., black and teal, or black and line colors)\nimplementation:\n  - return True if color not in exclude\n```"],["```yaml\ncues:\n  - output grid contains a path or trail connecting two objects or regions, especially with turns only at specific pixels\n  - movement is constrained by barriers or only allowed to turn at special markers\n  - path is colored in the output grid following a specific rule set\n  - process moves stepwise, changing direction only when blocked, and fills a path or region in the output grid\n\nimplementation:\n  - use BFS or DFS to explore possible states, expanding successors according to the movement rules\n  - maintain visited states to avoid cycles\n  - return the sequence of positions forming the path once a goal is reached\n```"],["```yaml\ncues:\n  - presence of objects in the grid that are a single row or column in extent\n  - output lines are aligned with or terminate at such single-row or single-column objects\nimplementation:\n  - determine if the object's height is 1 (for horizontal) or width is 1 (for vertical)\n  - if orientation is specified, check only the corresponding dimension; otherwise, check if either dimension is 1\n```"],["```yaml\ncues:\n  - if logic depends on whether a pixel is part of an object or not\n  - if movement or extension is blocked by an object's boundary\nimplementation:\n  - check if the position is in the object's pixel set or mask\n```"],["```yaml\ncues:\n  - if the output grid is affected only for every nth region/object in a spatial or ordered list\n  - if output features (e.g., lines or objects) are repeated at regular intervals (e.g., every second or third column)\n  - if a pattern is applied periodically across a row or column\nimplementation:\n  - use Python slicing: sequence[offset::n]\n```"],["```yaml\ncues:\n  - if the grid contains objects that are perfect squares (equal height and width)\n  - if the output grid treats square-shaped objects differently, such as centering frames or expansions on them\n  - if the output grid is composed of concentric or nested square regions\n  - if the output grid is a square whose size is determined by properties of the input grid (e.g., width, color count)\n  - if the output grid is composed of repeated or stacked copies of an input object, filling a square region\nimplementation: []\n```"],["```yaml\ncues:\n  - if the solution requires identifying a special color used for bars, dividers, frames, or background\n  - if the grid contains rows or columns that are all the same color\n  - if a color appears in lines that separate or partition regions in the grid\n  - if the output grid uses a color from the input grid that is not the bar, divider, or background color\n  - if a color appears exactly once in the input grid and is highlighted, bordered, or framed in the output\n  - if output features are colored to match scattered pixels inside a frame or rectangle\n\nimplementation:\n  - for each unique color in the grid, check if it satisfies the provided criteria function\n  - to find a bar or divider color, check for any row or column where all pixels are equal and use that color\n  - to find a background color, select any color in the grid that is not the bar or divider color\n  - to identify a color used for uninterrupted lines, check if a color forms continuous rows or columns\n```"],["```yaml\ncues:\n  - if the output grid contains changes to pixels that are diagonally adjacent to colored pixels\n  - if diagonal adjacency is relevant for coloring, movement, or pattern extension\n  - if output features or patterns extend from a pixel to its diagonally adjacent positions\n\nimplementation:\n  - for a given (x, y), diagonal neighbors are at (x-1, y-1), (x-1, y+1), (x+1, y-1), (x+1, y+1)\n  - ensure neighbor positions are within grid bounds before accessing or modifying them\n```"],["```yaml\ncues:\n  - when a process (such as line drawing or movement) interacts with the grid edge or must avoid out-of-bounds errors when updating grid pixels\nimplementation:\n  - check that 0 <= x < grid width and 0 <= y < grid height\n```"],["```yaml\ncues:\n  - if a pixel or object is recolored, merged, or absorbed into another object only when it is adjacent to or touching that object\n  - if output grid shows noise pixels being absorbed into larger objects when adjacent, but deleted otherwise\n  - if isolated pixels are removed from the output grid\n\nimplementation:\n  - for each pixel in the object, check all neighbors (according to connectivity) and count how many are in the reference object's pixel set and satisfy the criteria\n  - sum across all pixels in the object if it is more than a single pixel\n  - for noise removal, use a criteria that excludes background color (e.g., is_not_color(black))\n```"],["```yaml\ncues:\n  - if pixels or objects are removed in the output grid by being set to black\n  - if the output grid uses black to represent absence or background\nimplementation: []\n```"],["```yaml\ncues:\n  - if a small object in the input grid appears larger or smaller in the output, especially filling a frame or container\n  - if the output object is a scaled (enlarged or reduced) version of an input object, with regions that visually match the input but at a different size\n  - if each pixel or object in the input grid is replaced by a larger or smaller version in the output grid\n\nimplementation:\n  - use numpy.kron or similar functions to repeat the object's pixels according to the scaling factor\n  - for non-uniform scaling, repeat rows and columns separately based on the scaling factors for each axis\n  - ensure the scaled object fits within the intended container or frame in the output grid\n```"],["```yaml\ncues:\n  - if the output grid contains a rectangular border (often of a specific color) surrounding another object or region\n  - if an object is placed inside a colored rectangular outline in the output\n  - if the output region is cropped to a rectangle containing a border and its contents\nimplementation: []\n```"],["```yaml\ncues:\n  - if the output grid is initialized with a single color before other drawing\n  - if unused or empty grid regions are filled with a uniform color\nimplementation: []\n```"],["```yaml\ncues:\n  - if objects, regions, or rectangles are selected or filtered based on being uniformly a single color (e.g., all grey, all black, or another color)\n  - if only monochrome regions are processed in the output\nimplementation:\n  - check if all pixels in the object's mask or region are equal to the specified color\n```"],["```yaml\ncues:\n  - if the output grid is the same shape as input regions and each pixel depends only on the corresponding pixels in the regions\n  - if the output grid is a logical combination (e.g., AND, OR, XOR, NOR, difference) of two regions\n  - if the output grid highlights differences or similarities between two regions or patterns\nimplementation:\n  - for each position, apply the operation to the list of pixel values from each grid at that position\n  - for difference or highlighting, set the output pixel to a special color if the inputs differ, and another color if they match\n```"],["```yaml\ncues:\n  - if the output grid is initialized as a copy of a region or object from the input grid\n  - if further drawing or overlaying is performed on a grid that should preserve the original content\nimplementation:\n  - use numpy.copy or similar to duplicate the grid\n```"],["```yaml\ncues:\n  - when the solution involves selecting the best candidate from a set based on a scoring or evaluation function, such as maximizing a specific criterion (e.g., number of holes plugged, largest area, etc.)\nimplementation:\n  - use Python's max() function with the key argument to select the element with the maximum value according to the provided key function\n```"],["```yaml\ncues:\n  - if a recognizable, fixed-size pattern or motif (such as a colored square or diagonal) appears in the output grid, especially centered on an input pixel or object, or used to overwrite regions\n  - if the output grid contains motifs or templates of a fixed size (e.g., 4x4) not present in the input, or if patterns are matched to a reference set to determine output properties\nimplementation:\n  # (No implementation notes were provided in the original annotation)\n```"],["```yaml\ncues:\n  - If each region in the input grid is filled with a single color (other than the background/divider)\n  - If output grid pixels correspond to the color of regions in the input grid\n\nimplementation:\n  - Use np.unique to find colors in the region, exclude the background/divider color, and return the remaining color\n```"],["```yaml\ncues:\n  - when you need to identify or enumerate unique items (such as positions, colors, or attributes) from a list, especially if the solution logic depends on finding a unique value among candidates (e.g., a unique color among quadrants)\nimplementation:\n  - use a set to track seen elements and filter duplicates while preserving the original order of the sequence\n```"],["```yaml\ncues:\n  - Presence of repeated regions or sprites in the grid, possibly with reflection.\n  - Output consists of a single tile or sprite extracted from a repeated pattern in the input grid.\nimplementation:\n  - For each possible period, partition the grid along the specified axis and check if all regions are identical, allowing for possible reflection symmetry.\n  - Utilize shape matching and reflection operations to account for symmetric repetitions.\n```"],["```yaml\ncues:\n  - if a fixed-size pattern is centered on a pixel or object in the output grid\n  - if the overlay must be positioned so its center matches a reference position\nimplementation:\n  - subtract half the overlay's height and width (using integer division) from the center position to get the anchor\n```"],["```yaml\ncues:\n  - if the output grid is manipulated or recolored on a row-by-row basis\n  - if each row is processed independently in the solution logic\n  - if each row of the output grid is filled with a single color corresponding to an input pattern\n  - if output grid is constructed row by row, with each row determined by input features\nimplementation: []\n```"],["```yaml\ncues:\n  - if the output or solution logic depends on the number of distinct items (e.g., colors, objects) or the frequency of a color in regions or objects\nimplementation:\n  - use len() on the sequence\n```"],["```yaml\ncues:\n  - if the output grid contains regions, objects, or background areas filled with green that are not present in the input\nimplementation: []\n```"],["```yaml\ncues:\n  - if the output grid contains filled rectangles of a single color, especially adjacent to or below input objects\n  - if new rectangular regions are added in the output grid with dimensions determined by properties of input objects\n  - if the solution searches for or processes rectangular regions in the grid\nimplementation: []\n```"],["```yaml\ncues:\n  - if the solution distinguishes between different types of symmetry (e.g., mirror vs. rotational)\n  - if objects are selected based on being symmetric under one or more transformations\nimplementation: []\n```"],["```yaml\ncues:\n  - when the background color varies and must be inferred from the grid\n  - when object extraction or masking relies on identifying the most common color\nimplementation:\n  - use numpy or collections.Counter to count color frequencies and select the most common color\n```"],["```yaml\ncues:\n  - if output grid contains repeated, evenly spaced copies of an object in a straight line, diagonal, or other direction\n  - if an object is \"stamped\" multiple times in a regular pattern to fill a region, possibly with recoloring\n\nimplementation:\n  - for each repetition, compute the new position by adding stride * direction to the start position and draw the object at that position\n  - stop if the object would go out of bounds or overlap non-background pixels\n  - for diagonal translation, increment both row and column by the stride for each repetition\n```"],["```yaml\ncues:\n  - if objects are sorted, ranked, or selected based on their size or area\n  - if output depends on comparing the sizes of input objects or regions\nimplementation:\n  - count the number of non-background pixels in the object's mask or region\n```"],["```yaml\ncues:\n  - if a row in the grid is fully filled with a single color, corresponding to a feature or object\n  - if the output depends on the position of a row with a special property\nimplementation:\n  - iterate over rows and apply the criteria; return the index of the matching row\n```"],["```yaml\ncues:\n  - presence of a plus-shaped pattern formed by a row and column of the same color in the grid\n  - output grid is created by drawing a filled row and column intersecting at a specific position\nimplementation:\n```"],["```yaml\ncues:\n  - output grid is filled by extending a pattern using a symmetry transformation (e.g., translation)\n  - a motif or colored pixel is repeated at regular intervals in the output grid\nimplementation:\n  - repeatedly apply the symmetry transformation to the starting position, collecting all unique positions within the grid until a cycle is detected or a position goes out of bounds\n```"],["```yaml\ncues:\n  - if output grid rows are filled with a repeating or cyclical color pattern derived from an input row, such as lower rows matching the top row's color sequence\nimplementation:\n  - for each row starting from start_row, fill the row with color_sequence[i % len(color_sequence)]\n```"],["```yaml\ncues:\n  - if the output grid is a minimal rectangle containing multiple objects\n  - if objects are packed together with no empty space between them in the output\n  - if the region to be cropped is defined by the outermost extent of objects (e.g., lines, bars)\n  - if the crop region is determined by the bounding boxes of boundary objects\nimplementation:\n  - find the minimum and maximum x and y coordinates among all object pixels to define the bounding box, then slice the grid accordingly\n```"],["```yaml\ncues:\n  - if the output grid contains vertical lines of a single color, especially extending from a pixel to the grid edge\n  - if repeated vertical lines are drawn at regular intervals along a row\n  - if vertical lines are used as boundaries for cropping or region selection\nimplementation:\n```"],["```yaml\ncues:\n  - presence of lines or patterns extending in diagonal directions (up-right, down-right, up-left, down-left) from a pixel or object in the output grid\n  - diagonal symmetry or repeated diagonal patterns in the output grid\n\nimplementation:\n  - represent diagonal directions using direction vectors: (1,1), (1,-1), (-1,1), (-1,-1) corresponding to up-right, down-right, up-left, and down-left\n```"],["```yaml\ncues:\n  - if the solution requires identifying pixels on the perimeter of a region or object\n  - if lines or features are drawn from the edge of a region or container\nimplementation:\n  - compare the pixel's coordinates to the min/max x and y of the bounding box\n```"],["```yaml\ncues:\n  - if the grid contains a region bounded on all sides except one (the opening)\n  - if the output grid fills a region inside a container and extends features from its open edge\nimplementation:\n```"],["```yaml\ncues:\n  - if the output grid or a sprite is a tight crop of an object from the input grid\n  - if a region or subregion of the output grid is extracted for further manipulation, such as flipping, tiling, or other transformations\n  - if the output grid contains only the content inside a frame or border, possibly with the border width trimmed\n  - if a contiguous subregion of the input grid, bounded by lines, colored markers, or special pixels (e.g., vertical bars, corner markers), is used in the output\nimplementation:\n  - find the minimum and maximum x and y coordinates of the object's pixels and slice the grid accordingly\n  - allow specifying the crop region via bounding boxes, explicit coordinates, or by referencing special markers\n  - optionally mask out or ignore pixels of the background color if specified\n```"],["```yaml\ncues:\n  - if the solution logic starts from or processes only colored pixels on the grid edge\n  - if output features originate from the border of the input grid\n  - if distance, adjacency, coloring, or assignment depends on proximity to the edge of a region, object, or the grid itself\n\nimplementation:\n  - for each pixel in the grid or object, if its color matches and its position is on the grid edge, or if any neighboring position is not part of the object, include it as an edge pixel\n```"],["```yaml\ncues:\n  - if a process (e.g., line drawing or movement) stops at the grid edge\n  - if logic must avoid out-of-bounds errors when updating grid pixels\n  - if pixel placement or drawing is conditional on staying within grid boundaries or avoids placing pixels outside the grid when expanding objects\nimplementation:\n  - check that 0 <= y < grid_shape[0] and 0 <= x < grid_shape[1] before assigning or accessing a grid position\n```"],["```yaml\ncues:\n  - if a single pixel is removed, recolored, or changed in the output grid\n  - if a specific pixel (such as a corner or center pixel) is missing, changed, or set to a specific color in the output\n  - if individual pixels are colored at computed positions, especially when expanding, growing, or restoring objects\n  - if the output grid contains new colored pixels at positions not present in the input\n\nimplementation:\n  - assign the specified color to the given position in the grid (e.g., grid[position] = color)\n```"]]